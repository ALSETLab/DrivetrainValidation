within DrivetrainValidation.FMU;
model Rotor_fmu "This FMU calculates the forces and moments produced by a typical small eVTOL rotor using Blade Element Theory and a Uniform Inflow Model. All Units are SI (mks).

Inputs:
- Rotor Rotational Speed (1x1 Double)
- Rotor Linear Velocity (3x1 Double)
- Rotor Angular Velocity (3x1 Double)
- Rotor Radius (1x1 Double)
- Spin Direction (1x1 Boolean)

The two velocity inputs are defined in a hub-attached reference frame, and represent the velocity of the rotor hub with respect to the air. X-axis is positive forward, Y-axis is positive toward the right, and Z-axis is positive down.

The spin direction is 0 for counter-clockwise spin, 1 for clockwise spin

The outputs are:

- Rotor Forces (3x1 Double)
- Rotor Moment (3x1 Double)

The forces and moments are evaluated at the rotor hub, and are defined in the same coordinate frame as the velocities (e.g. thrust is positive down)"
extends fmuIcon;
// Model automatically generated by Dymola from FMI model description
public
  parameter Real _In1_start = 0 "Rotational speed"
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _In1_old;
public
  Modelica.Blocks.Interfaces.RealInput Rotor_Speed(start=_In1_start)
    "Input Port: In1"
    annotation (Placement(transformation(extent={{-114,70},{-94,90}})));
  parameter Real _In2_1__start = 0 "Forward speed of rotor (X)"
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _In2_1__old;
public
  Modelica.Blocks.Interfaces.RealInput ForwardSpeed_X(start=_In2_1__start)
    "Input Port: In2"
    annotation (Placement(transformation(extent={{-114,50},{-94,70}})));
  parameter Real _In2_2__start = 0 "Rightward speed (Y)"
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _In2_2__old;
public
  Modelica.Blocks.Interfaces.RealInput RightwardSpeed_Y(start=_In2_2__start)
    "Input Port: In2"
    annotation (Placement(transformation(extent={{-114,30},{-94,50}})));
  parameter Real _In2_3__start = 0 "Downward speed (Z)"
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _In2_3__old;
public
  Modelica.Blocks.Interfaces.RealInput DownwardSpeed_Z(start=_In2_3__start)
    "Input Port: In2"
    annotation (Placement(transformation(extent={{-114,10},{-94,30}})));
  parameter Real _In3_1__start = 0 "Roll rate (positive right side up)"
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _In3_1__old;
public
  Modelica.Blocks.Interfaces.RealInput Roll(start=_In3_1__start)
    "Input Port: In3"
    annotation (Placement(transformation(extent={{-114,-10},{-94,10}})));
  parameter Real _In3_2__start = 0 "Pitch rate (positive nose up)"
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _In3_2__old;
public
  Modelica.Blocks.Interfaces.RealInput Pitch(start=_In3_2__start)
    "Input Port: In3"
    annotation (Placement(transformation(extent={{-114,-30},{-94,-10}})));
  parameter Real _In3_3__start = 0 "Yaw rate (positive nose right, clockwise)"
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _In3_3__old;
public
  Modelica.Blocks.Interfaces.RealInput Yaw(start=_In3_3__start)
    "Input Port: In3"
    annotation (Placement(transformation(extent={{-114,-50},{-94,-30}})));
  parameter Real _In4_start = 0 "rotor radius (m)"
  annotation (Dialog( group="Start values for inputs "));
protected
  Real _In4_old;
public
  Modelica.Blocks.Interfaces.RealInput RotorRadius(start=_In4_start)
    "Input Port: In4"
    annotation (Placement(transformation(extent={{-114,-70},{-94,-50}})));
  parameter Boolean _In5_start = false "spin direction (0 CCW, 1 CW)"
  annotation (Dialog( group="Start values for inputs "));
protected
  Boolean _In5_old;
public
  Modelica.Blocks.Interfaces.BooleanInput Direction(start=_In5_start)
    "Input Port: In5"
    annotation (Placement(transformation(extent={{-114,-90},{-94,-70}})));
  Modelica.Blocks.Interfaces.RealOutput Force_X "Output Port: Out1"
  annotation (Placement(transformation(extent={{100,62},{120,82}})));
  Modelica.Blocks.Interfaces.RealOutput Force_Y "Output Port: Out1"
  annotation (Placement(transformation(extent={{100,33},{120,53}})));
  Modelica.Blocks.Interfaces.RealOutput Force_Z "Output Port: Out1"
  annotation (Placement(transformation(extent={{100,3},{120,23}})));
  Modelica.Blocks.Interfaces.RealOutput Moment_X "Output Port: Out2"
    annotation (Placement(transformation(extent={{100,-24},{120,-4}})));
  Modelica.Blocks.Interfaces.RealOutput Moment_Y "Output Port: Out2"
    annotation (Placement(transformation(extent={{100,-52},{120,-32}})));
  Modelica.Blocks.Interfaces.RealOutput Moment_Z "Output Port: Out2"
    annotation (Placement(transformation(extent={{100,-81},{120,-61}})));
public
  parameter String fmi_instanceName="Rotor_fmu"
  annotation (Dialog(tab="FMI", group="Instance name"));
  parameter Boolean fmi_loggingOn=false
  annotation (Dialog(tab="FMI", group="Enable logging"));
  parameter Boolean fmi_InputTime=false
  "Time point of input used when calling doStep."
  annotation (Evaluate=true,Dialog(tab="FMI", group="Input Handling"),choices(choice= false "StepEnd", choice= true "StepStart"));
  parameter Boolean fmi_UsePreOnInputSignals=true
  annotation (Evaluate=true,Dialog(tab="FMI", group="Input Handling"));
  parameter Real fmi_StartTime = 0
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_StopTime = 10
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_NumberOfSteps = 500
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_CommunicationStepSize=(fmi_StopTime-fmi_StartTime)/fmi_NumberOfSteps
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Integer stepSizeScaleFactor = 1 "Number of doSteps called between two CommunicationStepSize"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Boolean fmi_forceShutDownAtStopTime=false
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter Real fmi_rTol=1e-6 "relative tolerance for the internal solver of the fmu"
  annotation (Dialog(tab="FMI", group="Step time"));
  parameter String fmi_resourceLocation="file:///"+ModelicaServices.ExternalReferences.loadResource("modelica://Rotor_fmu/Resources/Library/FMU/Rotor/resources")
  annotation (Dialog(tab="FMI", group="Instantiation"));
protected
  fmi_Functions.fmiModel fmi;
  Boolean fmi_exitInit(start=false,fixed=true);
  Boolean fmi_flip(start=false,fixed=true);
  parameter Real fmi_rdum(start=0,fixed=false);
  parameter Integer fmi_idum(start=0,fixed=false);
  Boolean fmi_StepOK;
  parameter Real zeroOffset = 0;
  parameter Real myTimeStart(fixed=false);
  Real Out1_1__internal;
  Real Out1_2__internal;
  Real Out1_3__internal;
  Real Out2_1__internal;
  Real Out2_2__internal;
  Real Out2_3__internal;
package fmi_Functions
    class fmiModel
      extends ExternalObject;
      function constructor "Initialize FMI model"
        extends Modelica.Icons.Function;
        input String instanceName;
        input Boolean loggingOn;
        input String resourceLocation;
        output fmiModel fmi;
        external"C" fmi = Rotor0318979747797308800234_fmiInstantiateModel2(instanceName, loggingOn, resourceLocation)
        annotation(Header="
#ifndef Rotor0318979747797308800234_Instantiate_C
#define Rotor0318979747797308800234_Instantiate_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void Rotor0318979747797308800234Logger(fmi2ComponentEnvironment componentEnvironment, fmi2String instanceName, fmi2Status status,
  fmi2String category, fmi2String message, ...) {
  char msg[4096];
  char buf[4096];
  va_list ap;
  int len;
  va_start(ap,message);
#if defined(_MSC_VER) && _MSC_VER>=1200
  len = _snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = _vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#else
  len = snprintf(msg, sizeof(msg)/sizeof(*msg), \"%s: %s\", instanceName, message);
  if (len < 0) goto fail;
  len = vsnprintf(buf, sizeof(buf)/sizeof(*buf) - 2, msg, ap);
  if (len < 0) goto fail;
#endif
  if( len>0 && len < 4096 && buf[len - 1]!='\\n'){
    buf[len] = '\\n';
    buf[len + 1] = 0;
  }
  va_end(ap);
  switch (status) {
    case fmi2Fatal:
      ModelicaMessage(\"[fmi2Fatal]: \");
      break;
    case fmi2Error:
      ModelicaMessage(\"[fmi2Error]: \");
      break;
    case fmi2Discard:
      ModelicaMessage(\"[fmi2Discard]: \");
      break;
    case fmi2Warning:
      ModelicaMessage(\"[fmi2Warning]: \");
      break;
    case fmi2OK:
      ModelicaMessage(\"[fmi2OK]: \");
      break;
  }
  ModelicaMessage(buf);
  return;
fail:
  ModelicaMessage(\"Logger failed, message too long?\");
}
void * Rotor0318979747797308800234_fmiInstantiateModel2(const char*instanceName, fmi2Boolean loggingOn, fmi2String resourceLocation) {
  static fmi2CallbackFunctions funcs = {&Rotor0318979747797308800234Logger, &calloc, &free, NULL, NULL};
  struct dy_fmi2Extended* res;
  res = calloc(1, sizeof(struct dy_fmi2Extended));
  if (res!=0) {
    if (!(res->hInst=LoadLibraryW(L\"Rotor.dll\"))) {
      ModelicaError(\"Loading of FMU dynamic link library (Rotor.dll) failed!\");
      return 0;
    }
    if (!(res->dyFmiInstantiate=(fmi2InstantiateFunc)GetProcAddress(res->hInst,\"fmi2Instantiate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Instantiate!\");
      return 0;
    }
    if (!(res->dyFmiFreeInstance=(fmi2FreeInstanceFunc)GetProcAddress(res->hInst,\"fmi2FreeInstance\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2FreeInstance!\");
      return 0;
    }
    if (!(res->dyFmiSetupExperiment=(fmi2SetupExperimentFunc)GetProcAddress(res->hInst,\"fmi2SetupExperiment\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetupExperiment!\");
      return 0;
    }
    if (!(res->dyFmiEnterInitializationMode=(fmi2EnterInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2EnterInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2EnterInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiExitInitializationMode=(fmi2ExitInitializationModeFunc)GetProcAddress(res->hInst,\"fmi2ExitInitializationMode\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2ExitInitializationMode!\");
      return 0;
    }
    if (!(res->dyFmiTerminate=(fmi2TerminateFunc)GetProcAddress(res->hInst,\"fmi2Terminate\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Terminate!\");
      return 0;
    }
    if (!(res->dyFmiReset=(fmi2ResetFunc)GetProcAddress(res->hInst,\"fmi2Reset\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2Reset!\");
      return 0;
    }
    if (!(res->dyFmiSetReal=(fmi2SetRealFunc)GetProcAddress(res->hInst,\"fmi2SetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetReal!\");
      return 0;
    }
    if (!(res->dyFmiGetReal=(fmi2GetRealFunc)GetProcAddress(res->hInst,\"fmi2GetReal\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetReal!\");
      return 0;
    }
    if (!(res->dyFmiSetInteger=(fmi2SetIntegerFunc)GetProcAddress(res->hInst,\"fmi2SetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetInteger!\");
      return 0;
    }
    if (!(res->dyFmiGetInteger=(fmi2GetIntegerFunc)GetProcAddress(res->hInst,\"fmi2GetInteger\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetInteger!\");
      return 0;
    }
    if (!(res->dyFmiSetBoolean=(fmi2SetBooleanFunc)GetProcAddress(res->hInst,\"fmi2SetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiGetBoolean=(fmi2GetBooleanFunc)GetProcAddress(res->hInst,\"fmi2GetBoolean\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetBoolean!\");
      return 0;
    }
    if (!(res->dyFmiSetDebugLogging=(fmi2SetDebugLoggingFunc)GetProcAddress(res->hInst,\"fmi2SetDebugLogging\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetDebugLogging!\");
      return 0;
    }
    if (!(res->dyFmiSetString=(fmi2SetStringFunc)GetProcAddress(res->hInst,\"fmi2SetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2SetString!\");
      return 0;
    }
    if (!(res->dyFmiGetString=(fmi2GetStringFunc)GetProcAddress(res->hInst,\"fmi2GetString\"))) {
      ModelicaError(\"GetProcAddress failed for fmi2GetString!\");
      return 0;
    }
    if(!(res->dyFmiDoStep=(fmi2DoStepFunc)GetProcAddress(res->hInst,\"fmi2DoStep\"))){
      ModelicaError(\"GetProcAddress failed for fmi2DoStep!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiDoStep\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    if(!(res->dyFmiGetBooleanStatus=(fmi2GetBooleanStatusFunc)GetProcAddress(res->hInst,\"fmi2GetBooleanStatus\"))){
      ModelicaError(\"GetProcAddress failed for fmi2GetBooleanStatus!\\n The model was imported as a Co-Simulation FMU but could not load the CS specific function fmiGetBooleanStatus\\n Verify that the FMU supports Co-Simulation\");
      return 0;
    }
    res->m=res->dyFmiInstantiate(instanceName, fmi2CoSimulation, \"c0d31e8b-97b9-747f-d797-30d8aa800234\",resourceLocation, &funcs, fmi2False, loggingOn);
    if (0==res->m) {free(res);res=0;ModelicaError(\"InstantiateModel failed\");}
    else {res->dyTriggered=0;res->dyTime=res->dyLastTime=-1e37;res->discreteInputChanged=1;res->currentMode=dyfmi2InstantiationMode;res->dyLastStepTime=0;res->dyFMUstate=NULL;}
  }
  return res;
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
      end constructor;

      function destructor "Release storage of FMI model"
        extends Modelica.Icons.Function;
        input fmiModel fmi;
        external"C"
                   Rotor0318979747797308800234_fmiFreeModelInstance2(fmi);
        annotation (Header="
#ifndef Rotor0318979747797308800234_Free_C
#define Rotor0318979747797308800234_Free_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void Rotor0318979747797308800234_fmiFreeModelInstance2(void*m) {
  struct dy_fmi2Extended*a=m;
  if (a) {
    /*a->dyFmiSetDebugLogging(a->m,fmi2True,0,NULL);*/
    a->dyFmiTerminate(a->m);
    a->dyFmiFreeInstance(a->m);
    FreeLibrary(a->hInst);
    free(a);
  }
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
      end destructor;
    end fmiModel;

    function fmiDoStep
    input fmiModel fmi;
    input Real currentTime;
    input Real stepSize;
    input Real preAvailable;
    output Boolean stepOK;
    output Real postAvailable=preAvailable;
    external"C" stepOK= Rotor0318979747797308800234_fmiDoStep2(fmi, currentTime, stepSize);
      annotation (Header="
#ifndef Rotor0318979747797308800234_DoStep_C
#define Rotor0318979747797308800234_DoStep_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double Rotor0318979747797308800234_fmiDoStep2(void*m, double currentTime, double stepSize) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  fmi2Boolean value=fmi2False;
  if (a) {
    status=a->dyFmiDoStep(a->m, currentTime, stepSize, fmi2True);
    if(status==fmi2Discard){
      status = a->dyFmiGetBooleanStatus(a->m, fmi2Terminated, &value);
      if(value==fmi2True){
        terminate(\"Terminate signaled by the FMU\");
      }
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"DoStep failed\");
  return 1.0;
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiDoStep;

    function fmiReset
      input fmiModel fmi;
      output Boolean resetOK;
      external"C" resetOK = Rotor0318979747797308800234_fmiReset2(fmi);
      annotation (Header="
#ifndef Rotor0318979747797308800234_Reset_C
#define Rotor0318979747797308800234_Reset_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
double Rotor0318979747797308800234_fmiReset2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiReset(a->m);
    a->currentMode=dyfmi2InstantiationMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiReset failed\");
    return 1.0;
  }
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiReset;

    function fmiGetRealScalar
      input fmiModel fmi;
      input Integer ref;
      output Real val;
    algorithm
        val := scalar(fmiGetReal(fmi, {ref}));
    end fmiGetRealScalar;

    function fmiGetReal
      input fmiModel fmi;
      input Integer refs[:];
      output Real vals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef Rotor0318979747797308800234_GetReal_C
#define Rotor0318979747797308800234_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiGetReal;

    function fmiGetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real preAvailable;
      output Real vals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiGetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef Rotor0318979747797308800234_GetReal_C
#define Rotor0318979747797308800234_GetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiGetReal2(void*m, const int*refs, size_t nrefs, double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetReal failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiGetRealwf;

    function fmiSetReal
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      external"C"
                 Rotor0318979747797308800234_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef Rotor0318979747797308800234_SetReal_C
#define Rotor0318979747797308800234_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetReal;

    function fmiSetRealwf
      input fmiModel fmi;
      input Integer refs[:];
      input Real vals[size(refs, 1)];
      input Real preAvailable;
      output Real postAvailable=preAvailable;
      external"C"
                 Rotor0318979747797308800234_fmiSetReal2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef Rotor0318979747797308800234_SetReal_C
#define Rotor0318979747797308800234_SetReal_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiSetReal2(void*m, const int*refs, size_t nrefs, const double*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetReal(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetReal failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetRealwf;

    function fmiGetIntegerScalar
      input fmiModel fmi;
      input Integer ref;
      output Integer val;
    algorithm
        val := scalar(fmiGetInteger(fmi, {ref}));
    end fmiGetIntegerScalar;

    function fmiGetInteger
      input fmiModel fmi;
      input Integer refs[:];
      output Integer vals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef Rotor0318979747797308800234_GetInteger_C
#define Rotor0318979747797308800234_GetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiGetInteger;

    function fmiGetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Integer vals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiGetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef Rotor0318979747797308800234_GetInteger_C
#define Rotor0318979747797308800234_GetInteger_C 1
#include \"FMI/fmi2Import.h\"
#include <stdlib.h>
void Rotor0318979747797308800234_fmiGetInteger2(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiGetIntegerwf;

    function fmiSetInteger
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
    protected
      Integer oldVals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiSetInteger2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        oldVals);
      annotation (Header="
#ifndef Rotor0318979747797308800234_SetInteger_C
#define Rotor0318979747797308800234_SetInteger_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiSetInteger2(void*m, const int*refs, size_t nrefs, int*vals, int*oldVals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetInteger(a->m, refs, nrefs, oldVals);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetInteger failed in SetInteger\");
      for( i = 0; i < nrefs; ++i){
        if(oldVals[i] != vals[i]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetInteger;

    function fmiSetIntegerwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer vals[size(refs, 1)];
      input Integer preAvailable;
      output Integer postAvailable=preAvailable;
      external"C" Rotor0318979747797308800234_fmiSetInteger2wf(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef Rotor0318979747797308800234_SetIntegerwf_C
#define Rotor0318979747797308800234_SetIntegerwf_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiSetInteger2wf(void*m, const int*refs, size_t nrefs, int*vals) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    status=a->dyFmiSetInteger(a->m, refs, nrefs, vals);
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetInteger failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetIntegerwf;

    function fmiGetBooleanScalar
      input fmiModel fmi;
      input Integer ref;
      output Boolean val;
    algorithm
        val := scalar(fmiGetBoolean(fmi, {ref}));
    end fmiGetBooleanScalar;

    function fmiGetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      output Boolean vals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef Rotor0318979747797308800234_GetBoolean_C
#define Rotor0318979747797308800234_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiGetBoolean;

    function fmiGetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Integer preAvailable;
      output Boolean vals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiGetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals);
        annotation (Header="
#ifndef Rotor0318979747797308800234_GetBoolean_C
#define Rotor0318979747797308800234_GetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiGetBoolean2(void*m, const int* refs, size_t nr, int* vals) {
  int i;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(vals));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed\");
    for(i=nr-1;i>=0;i--) vals[i]=((fmi2Boolean*)(vals))[i];
  }
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiGetBooleanwf;

    function fmiSetBoolean
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
    protected
      Boolean dummy[size(refs, 1)];
      Boolean oldVals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiSetBoolean2(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy,
        oldVals);
        annotation (Header="
#ifndef Rotor0318979747797308800234_SetBoolean_C
#define Rotor0318979747797308800234_SetBoolean_C 1
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiSetBoolean2(void*m, const int* refs, size_t nr, const int* vals, int* dummy, int* oldVals) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    if(!a->discreteInputChanged){
      status=a->dyFmiGetBoolean(a->m, refs, nr, (fmi2Boolean*)(oldVals));
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"GetBoolean failed in SetBoolean\");
      for(j=nr-1;j>=0;j--){
        oldVals[j]=((fmi2Boolean*)(oldVals))[j];
        if(oldVals[j] != dummy[j]){
          a->discreteInputChanged = 1;
          break;
        }
      }
    }
    if(a->discreteInputChanged){
      if(a->currentMode == dyfmi2ContinuousTimeMode){
        status = a->dyFmiEnterEventMode(a->m);
        if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
        a->currentMode = dyfmi2EventMode;
      }
      status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBoolean;

    function fmiSetString
      input fmiModel fmi;
      input Integer refs[:];
      input String vals[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiSetString2(
        fmi,
        refs,
        size(refs, 1),
        vals);
      annotation (Header="
#ifndef Rotor0318979747797308800234_SetString_C
#define Rotor0318979747797308800234_SetString_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiSetString2(void*m, const int*refs, size_t nrefs,const fmi2String vals[]) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  size_t i = 0;
  if(!nrefs){return;}
  if (a) {
    if(a->currentMode == dyfmi2ContinuousTimeMode){
      status = a->dyFmiEnterEventMode(a->m);
      if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiEnterEventModeFailed\");
      a->currentMode = dyfmi2EventMode;
    }
    status=a->dyFmiSetString(a->m, refs, nrefs, vals);
    a->discreteInputChanged = fmi2True;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetString failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetString;

    function fmiSetBooleanwf
      input fmiModel fmi;
      input Integer refs[:];
      input Boolean vals[size(refs, 1)];
      input Integer preAvailable;
      output Integer postAvailable=preAvailable;
    protected
      Boolean dummy[size(refs, 1)];
      external"C" Rotor0318979747797308800234_fmiSetBoolean2wf(
        fmi,
        refs,
        size(refs, 1),
        vals,
        dummy);
        annotation (Header="
#ifndef Rotor0318979747797308800234_SetBooleanwf_C
#define Rotor0318979747797308800234_SetBooleanwf_C 1
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiSetBoolean2wf(void*m, const int* refs, size_t nr, const int* vals, int* dummy) {
  size_t i;
  int j;
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if(!nr){return;}
  for(i=0;i<nr;++i) ((fmi2Boolean*)(dummy))[i]=vals[i];
  if (a) {
    status=a->dyFmiSetBoolean(a->m, refs, nr, (fmi2Boolean*)(dummy));
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"SetBoolean failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor",__Dymola_IdemPotent=true, __Dymola_VectorizedExceptFirst=true);
    end fmiSetBooleanwf;

    function GetRealVariable
      input fmiModel fmi;
      input Real Time;
      input Real realInputs[:];
      input Real realLinearDependentInputs[:];
      input Real states[:];
      input Real linearDependentStates[:];
      input Real linearOffset=0;
      input Boolean booleanInputs[:];
      input Integer integerInputs[:];
      //input String stringInputs[:];
      input Integer realInputValueReferences[:];
      input Integer realLinearDependentInputsValueReferences[:];
      input Integer statesValueRefernces[:];
      input Integer booleanInputValueReferences[:];
      input Integer integerInputValueReferences[:];
      //input Integer stringInputValueReferences[:];
      input Integer outputValueReference[:];
      output Real outputVariable;
    algorithm
      //fmi_Functions.fmiSetTime(fmi, Time);
      fmiSetReal(fmi,realInputValueReferences,realInputs);
      fmiSetReal(fmi,realLinearDependentInputsValueReferences,realLinearDependentInputs);
      fmiSetBoolean(fmi,booleanInputValueReferences,booleanInputs);
      fmiSetInteger(fmi,integerInputValueReferences,integerInputs);
      //SetString(fmi,stringInputValueReferences,stringInputs);
      outputVariable:=fmiGetRealScalar(fmi,outputValueReference[1]);
      annotation(LateInline=true);
    end GetRealVariable;

    function fmiEnterSlaveInitializationMode
      input fmiModel fmi;
      input Real relativeTolerance;
      input Real tStart;
      input Boolean forceShutDownAtTStop;
      input Real tStop;
      input Real preAvailable;
      output Real postAvailable = preAvailable;
      external"C" Rotor0318979747797308800234_fmiEnterSlaveInitializationMode2(fmi, relativeTolerance, tStart, forceShutDownAtTStop, tStop);
      annotation (Header="
#ifndef Rotor0318979747797308800234_fmiEnterSlaveInitializationMode_C
#define Rotor0318979747797308800234_fmiEnterSlaveInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiEnterSlaveInitializationMode2(void*m, double relativeTolerance, double tStart, int forceShutDownAtTStop, double tStop) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    if(a->currentMode==dyfmi2InstantiationMode){
      status=a->dyFmiSetupExperiment(a->m, fmi2True, relativeTolerance, tStart, forceShutDownAtTStop, tStop);
      status=a->dyFmiEnterInitializationMode(a->m);
      a->dyTriggered=0;
      a->dyLastTime=a->dyTime;
      a->currentMode=dyfmi2InitializationMode;
    }else{
      status=fmi2OK;
    }
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"InitializeSlave failed\");
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiEnterSlaveInitializationMode;

    function fmiExitSlaveInitializationMode
      input fmiModel fmi;
      input Real preAvailable;
      output Real postAvailable = preAvailable;
      external"C" Rotor0318979747797308800234_fmiExitSlaveInitializationMode2(fmi);
      annotation (Header="
#ifndef Rotor0318979747797308800234_fmiExitSlaveInitializationMode_C
#define Rotor0318979747797308800234_fmiExitSlaveInitializationMode_C 1
#include <stdlib.h>
#include \"FMI/fmi2Import.h\"
void Rotor0318979747797308800234_fmiExitSlaveInitializationMode2(void*m) {
  struct dy_fmi2Extended*a=m;
  fmi2Status status=fmi2Fatal;
  if (a) {
    status=a->dyFmiExitInitializationMode(a->m);
    a->dyTriggered=0;
    a->dyLastTime=a->dyTime;
    a->currentMode = dyfmi2EventMode;
  }
  if (status!=fmi2OK && status!=fmi2Warning) ModelicaError(\"fmiExitModelInitialization failed!\");
  return;
}
#endif", Library="Rotor", LibraryDirectory="modelica://DrivetrainValidation/Resources/Library/FMU/Rotor/binaries",
                                                                                                        __Dymola_CriticalRegion="Rotor");
    end fmiExitSlaveInitializationMode;
end fmi_Functions;
initial equation
equation
  when initial() then
    fmi = fmi_Functions.fmiModel(fmi_instanceName, fmi_loggingOn, fmi_resourceLocation);
  end when;
initial algorithm
    fmi_Functions.fmiSetReal(fmi, {0}, {_In1_start});
    fmi_Functions.fmiSetReal(fmi, {1}, {_In2_1__start});
    fmi_Functions.fmiSetReal(fmi, {2}, {_In2_2__start});
    fmi_Functions.fmiSetReal(fmi, {3}, {_In2_3__start});
    fmi_Functions.fmiSetReal(fmi, {4}, {_In3_1__start});
    fmi_Functions.fmiSetReal(fmi, {5}, {_In3_2__start});
    fmi_Functions.fmiSetReal(fmi, {6}, {_In3_3__start});
    fmi_Functions.fmiSetReal(fmi, {7}, {_In4_start});
    fmi_Functions.fmiSetBoolean(fmi, {0}, {_In5_start});
    fmi_Functions.fmiEnterSlaveInitializationMode(fmi, fmi_rTol, fmi_StartTime, fmi_forceShutDownAtStopTime, fmi_StopTime, 1);
  fmi_rdum := 1;
  fmi_idum := 1;
  myTimeStart :=time;
algorithm
assert(fmi_CommunicationStepSize > 0.0,"The parameter fmi_CommunicationStepSize has an invalid value, please set a positive value larger than 0.0");
  when {initial(), sample(fmi_StartTime, fmi_CommunicationStepSize)} then
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {0}, {_In1_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(
          fmi,
          {0},
          {pre(Rotor_Speed)});
      else
        fmi_Functions.fmiSetReal(
          fmi,
          {0},
          {Rotor_Speed});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {1}, {_In2_1__old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(
          fmi,
          {1},
          {pre(ForwardSpeed_X)});
      else
        fmi_Functions.fmiSetReal(
          fmi,
          {1},
          {ForwardSpeed_X});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {2}, {_In2_2__old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(
          fmi,
          {2},
          {pre(RightwardSpeed_Y)});
      else
        fmi_Functions.fmiSetReal(
          fmi,
          {2},
          {RightwardSpeed_Y});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {3}, {_In2_3__old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(
          fmi,
          {3},
          {pre(DownwardSpeed_Z)});
      else
        fmi_Functions.fmiSetReal(
          fmi,
          {3},
          {DownwardSpeed_Z});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {4}, {_In3_1__old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(
          fmi,
          {4},
          {pre(Roll)});
      else
        fmi_Functions.fmiSetReal(
          fmi,
          {4},
          {Roll});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {5}, {_In3_2__old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(
          fmi,
          {5},
          {pre(Pitch)});
      else
        fmi_Functions.fmiSetReal(
          fmi,
          {5},
          {Pitch});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {6}, {_In3_3__old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(
          fmi,
          {6},
          {pre(Yaw)});
      else
        fmi_Functions.fmiSetReal(
          fmi,
          {6},
          {Yaw});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetReal(fmi, {7}, {_In4_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetReal(
          fmi,
          {7},
          {pre(RotorRadius)});
      else
        fmi_Functions.fmiSetReal(
          fmi,
          {7},
          {RotorRadius});
      end if;
    end if;
    if fmi_InputTime then
      fmi_Functions.fmiSetBoolean(fmi, {0}, {_In5_old});
    else
      if fmi_UsePreOnInputSignals then
        fmi_Functions.fmiSetBoolean(
          fmi,
          {0},
          {pre(Direction)});
      else
        fmi_Functions.fmiSetBoolean(
          fmi,
          {0},
          {Direction});
      end if;
    end if;
      if fmi_rdum >= 0  and fmi_idum >= 0 and not fmi_exitInit and not initial() then
        fmi_Functions.fmiExitSlaveInitializationMode(fmi, 1);
        fmi_exitInit:=true;
      end if;
    if time>=fmi_CommunicationStepSize +fmi_StartTime then
      for stepSizeIndex in 1:stepSizeScaleFactor loop
        fmi_StepOK :=fmi_Functions.fmiDoStep(
          fmi,
          time + (stepSizeIndex - 1 - stepSizeScaleFactor)*
            fmi_CommunicationStepSize/stepSizeScaleFactor,
          fmi_CommunicationStepSize/stepSizeScaleFactor,
          1);
      end for;
      fmi_flip :=not pre(fmi_flip);
    end if;
    if not initial() then
      Out1_1__internal :=fmi_Functions.fmiGetRealScalar(fmi, 8);
      Out1_2__internal :=fmi_Functions.fmiGetRealScalar(fmi, 9);
      Out1_3__internal :=fmi_Functions.fmiGetRealScalar(fmi, 10);
      Out2_1__internal :=fmi_Functions.fmiGetRealScalar(fmi, 11);
      Out2_2__internal :=fmi_Functions.fmiGetRealScalar(fmi, 12);
      Out2_3__internal :=fmi_Functions.fmiGetRealScalar(fmi, 13);
    end if;
  end when;
  when {pre(fmi_flip), not pre(fmi_flip)} then
    _In1_old :=pre(Rotor_Speed);
    _In2_1__old :=pre(ForwardSpeed_X);
    _In2_2__old :=pre(RightwardSpeed_Y);
    _In2_3__old :=pre(DownwardSpeed_Z);
    _In3_1__old :=pre(Roll);
    _In3_2__old :=pre(Pitch);
    _In3_3__old :=pre(Yaw);
    _In4_old :=pre(RotorRadius);
    _In5_old :=pre(Direction);
  end when;
equation
  if initial() then
    Force_X =fmi_Functions.GetRealVariable(
      fmi,
      myTimeStart,
      {Rotor_Speed,ForwardSpeed_X,RightwardSpeed_Y,DownwardSpeed_Z,Roll,Pitch,
        Yaw,RotorRadius},
      fill(0.0, 0),
      fill(0.0, 0),
      fill(0.0, 0),
      zeroOffset,
      {Direction},
      fill(0, 0),
      {0,1,2,3,4,5,6,7},
      fill(0, 0),
      fill(0, 0),
      {0},
      fill(0, 0),
      {8});
  else
    Force_X = Out1_1__internal;
  end if;
  if initial() then
    Force_Y =fmi_Functions.GetRealVariable(
      fmi,
      myTimeStart,
      {Rotor_Speed,ForwardSpeed_X,RightwardSpeed_Y,DownwardSpeed_Z,Roll,Pitch,
        Yaw,RotorRadius},
      fill(0.0, 0),
      fill(0.0, 0),
      fill(0.0, 0),
      zeroOffset,
      {Direction},
      fill(0, 0),
      {0,1,2,3,4,5,6,7},
      fill(0, 0),
      fill(0, 0),
      {0},
      fill(0, 0),
      {9});
  else
    Force_Y = Out1_2__internal;
  end if;
  if initial() then
    Force_Z =fmi_Functions.GetRealVariable(
      fmi,
      myTimeStart,
      {Rotor_Speed,ForwardSpeed_X,RightwardSpeed_Y,DownwardSpeed_Z,Roll,Pitch,
        Yaw,RotorRadius},
      fill(0.0, 0),
      fill(0.0, 0),
      fill(0.0, 0),
      zeroOffset,
      {Direction},
      fill(0, 0),
      {0,1,2,3,4,5,6,7},
      fill(0, 0),
      fill(0, 0),
      {0},
      fill(0, 0),
      {10});
  else
    Force_Z = Out1_3__internal;
  end if;
  if initial() then
    Moment_X = fmi_Functions.GetRealVariable(
      fmi,
      myTimeStart,
      {Rotor_Speed,ForwardSpeed_X,RightwardSpeed_Y,DownwardSpeed_Z,Roll,Pitch,
        Yaw,RotorRadius},
      fill(0.0, 0),
      fill(0.0, 0),
      fill(0.0, 0),
      zeroOffset,
      {Direction},
      fill(0, 0),
      {0,1,2,3,4,5,6,7},
      fill(0, 0),
      fill(0, 0),
      {0},
      fill(0, 0),
      {11});
  else
    Moment_X = Out2_1__internal;
  end if;
  if initial() then
    Moment_Y = fmi_Functions.GetRealVariable(
      fmi,
      myTimeStart,
      {Rotor_Speed,ForwardSpeed_X,RightwardSpeed_Y,DownwardSpeed_Z,Roll,Pitch,
        Yaw,RotorRadius},
      fill(0.0, 0),
      fill(0.0, 0),
      fill(0.0, 0),
      zeroOffset,
      {Direction},
      fill(0, 0),
      {0,1,2,3,4,5,6,7},
      fill(0, 0),
      fill(0, 0),
      {0},
      fill(0, 0),
      {12});
  else
    Moment_Y = Out2_2__internal;
  end if;
  if initial() then
    Moment_Z = fmi_Functions.GetRealVariable(
      fmi,
      myTimeStart,
      {Rotor_Speed,ForwardSpeed_X,RightwardSpeed_Y,DownwardSpeed_Z,Roll,Pitch,
        Yaw,RotorRadius},
      fill(0.0, 0),
      fill(0.0, 0),
      fill(0.0, 0),
      zeroOffset,
      {Direction},
      fill(0, 0),
      {0,1,2,3,4,5,6,7},
      fill(0, 0),
      fill(0, 0),
      {0},
      fill(0, 0),
      {13});
  else
    Moment_Z = Out2_3__internal;
  end if;
  annotation (__Dymola_FMUImportVersion="Dymola 2020x", experiment(StartTime=0, StopTime=10),
    Icon(graphics={
      Text(extent={{-150,150},{150,110}},
        lineColor={0,0,255},
        textString="%name"),
      Text(extent={{-150,-110},{150,-150}},
        lineColor={95,95,95},
        textString="FMI 2.0 CS")}),
Documentation(info="<html>
<h4>ModelDescription Attributes</h4>
<ul>
<li>fmiVersion = 2.0</li>
<li>modelName = Rotor</li>
<li>generationTool = Simulink (R2019a)</li>
<li>generationDateAndTime = 2020-10-21T15:33:19Z</li>
</ul>
<p><br><b>Co-Simulation Attributes</b></p>
<ul>
<li>needsExecutionTool = false</li>
<li>canHandleVariableCommunicationStepSize = true</li>
<li>canInterpolateInputs = false</li>
<li>maxOutputDerivativeOrder = 0</li>
<li>canRunAsynchronuously = false</li>
<li>canBeInstantiatedOnlyOncePerProcess = false</li>
<li>canNotUseMemoryManagementFunctions = true</li>
<li>canGetAndSetFMUstate = false</li>
<li>canSerializeFMUstate = false</li>
<li>providesDirectionalDerivative = false</li>
</ul>
</html>"));
end Rotor_fmu;
