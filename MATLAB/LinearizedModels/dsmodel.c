#define DYNEventSpecial
/* DSblock model generated by Dymola from Modelica model DrivetrainValidation.Examples.AveragedSwitched_Drive45
 Dymola Version 2021x (64-bit), 2020-11-26 translated this at Mon Feb 22 20:34:45 2021

  Evaluate = true;
OutputCPUtime = true;
 */

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays25[3]={0.0, 0.0, 0.0};
static double DymArrays16[3]={2E-06, 2E-06, 2E-06};
static double DymArrays6[3]={1E-05, 1E-05, 0.0};
static double DymArrays15[3]={0.00775, 293.15, 0.00397};
static double DymArrays23[3]={0.0155, 293.15, 0.00397};
static double DymArrays21[3]={0.3, 5.0, 3.0};
static double DymArrays19[3]={0.3, 5.0, 60.0};
static double DymArrays8[3]={1.0, 1.0, 0.0};
static double DymArrays0[3]={1.0, 1.0, 3.0};
static double DymArrays2[3]={3.0, 3.0, 3.0};
static double DymArrays4[3]={293.15, 293.15, 293.15};
static double DymArrays22[4]={4E-06, 1E-15, 1E-15, 0.0003704676056338029};
static double DymArrays24[4]={1.0, 0.08, 2.0, 0.0};
static double DymArrays12[4]={2.0943951023931953, 3.665191429188092, 
  5.759586531581288, 7.853981633974483};
static double DymArrays1[4]={3.0, 3.0, 3.0, 3.0};
static double DymArrays20[5]={1.0, 0.08, 2.0, 0.0, 1000.0};
#endif
static double DymArrays31[6]={-1.0, -1.0, 1.0, 1.0, -1.0, -1.0};
static double DymArrays30[6]={-0.5235987755982996, 0.5235987755982983, 
  1.5707963267948966, 3.6651914291880914, 4.71238898038469, 5.759586531581288};
static double DymArrays28[6]={-0.5235987755982996, 0.5235987755982983, 
  2.617993877991493, 3.665191429188092, 5.759586531581287, 6.8067840827778845};
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays3[6]={1E-05, 1E-05, 1E-05, 1E-05, 1E-05, 1E-05};
#endif
static double DymArrays26[6]={0.5235987755982987, 1.5707963267948966, 
  2.617993877991495, 4.71238898038469, 5.759586531581288, 6.806784082777886};
static double DymArrays29[6]={1.0, -1.0, -1.0, 1.0, 1.0, -1.0};
static double DymArrays27[6]={1.0, 1.0, -1.0, -1.0, 1.0, 1.0};
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays14[6]={293.15, 293.15, 293.15, 0.00775, 293.15, 0.00397};
static double DymArrays7[7]={0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0};
static double DymArrays5[9]={1E-05, 1E-05, 1E-05, 1E-05, 1E-05, 1E-05, 0.0, 0.0,
   0.0};
static double DymArrays11[9]={0.00775, 2E-06, 1.0, 0.1342, 71.0, 2.0, 1E-15, 
  1E-15, 0.0003704676056338029};
static double DymArrays13[9]={0.00775, 0.00775, 0.00775, 293.15, 293.15, 293.15,
   0.00397, 0.00397, 0.00397};
static double DymArrays10[11]={3.141592653589793, 2.0, 3.665191429188092, 
  4.71238898038469, 5.759586531581287, 0.5235987755982988, 1.5707963267948966, 
  2.617993877991494, 3.665191429188092, 4.71238898038469, 5.759586531581287};
static double DymArrays17[12]={1.0, 0.1342, 71.0, 2.0, 0.03355, 2.0943951023931953,
   3.665191429188092, 5.759586531581288, 7.853981633974483, 1.0471975511965979, 
  1.9098593171027438, 0.052700216763968785};
static double DymArrays9[24]={4E-06, 1E-15, 1E-15, 0.0, 1.0, 0.1342, 71.0, 1E-15,
   1E-15, 9.8, 3550.0, 50.0, 177.8, 23.853, 352.3819759776551, 8405.367272995007,
   0.1342, 0.0003704676056338029, 0.00775, 2E-06, 2.0943951023931953, 
  3.665191429188092, 5.759586531581288, 7.853981633974483};
static double DymArrays18[108]={3.665191429188092, 5.759586531581288, 
  1.5707963267948966, 5.759586531581287, 1.5707963267948966, 3.6651914291880914,
   0.5235987755982983, 2.617993877991495, 4.71238898038469, 2.617993877991493, 
  4.71238898038469, 0.5235987755982983, 3.665191429188092, 5.759586531581288, 
  1.5707963267948966, 1.0, 1.0, 1.0, 5.759586531581287, 1.5707963267948966, 
  3.6651914291880914, 1.0, 1.0, 1.0, 0.5235987755982983, 2.617993877991495, 
  4.71238898038469, -1.0, -1.0, -1.0, 2.617993877991493, 4.71238898038469, 
  0.5235987755982983, -1.0, -1.0, -1.0, 0.5235987755982983, -1.0, 
  2.617993877991493, -1.0, 3.665191429188092, 1.0, 5.759586531581287, 1.0, 
  1.5707963267948966, 1.0, 2.617993877991495, -1.0, 4.71238898038469, -1.0, 
  5.759586531581288, 1.0, 0.5235987755982983, -1.0, 1.5707963267948966, 1.0, 
  3.6651914291880914, 1.0, 4.71238898038469, -1.0, -0.5235987755982996, 1.0, 
  0.5235987755982987, 1.0, -0.5235987755982996, -1.0, 6.8067840827778845, -1.0, 
  6.806784082777886, 1.0, 5.759586531581288, -1.0, -0.5235987755982996, 1.0, 
  0.5235987755982983, -1.0, 2.617993877991493, -1.0, 3.665191429188092, 1.0, 
  5.759586531581287, 1.0, 6.8067840827778845, -1.0, 0.5235987755982987, 1.0, 
  1.5707963267948966, 1.0, 2.617993877991495, -1.0, 4.71238898038469, -1.0, 
  5.759586531581288, 1.0, 6.806784082777886, 1.0, -0.5235987755982996, -1.0, 
  0.5235987755982983, -1.0, 1.5707963267948966, 1.0, 3.6651914291880914, 1.0, 
  4.71238898038469, -1.0, 5.759586531581288, -1.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct {
  RealArray    y0_0_0member;
  double   y00_0_0member;
};
DYMOLA_STATIC struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct
   Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(RealArray  
   x0_0);
DYMOLA_STATIC RealArray    Modelica_Electrical_Polyphase_Functions_symmetricOrientation
  (int  m0_0);
struct Modelica_Math_Vectors_interpolate_struct {
  double   yi0_0_0member;
  int   iNew0_0_0member;
};
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0);
DYMOLA_STATIC RealArray    cos_For_1_0(RealArray   u0_0);
DYMOLA_STATIC RealArray    sin_For_1_0(RealArray   u0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor
discrete input Real x[:] "Polyphase (voltage or current) input";
discrete output Real y[2] "Space phasor";
discrete output Real y0 "Zero sequence component (of voltage or current)";
protected 
parameter Integer m = size(x, 1) "Number of phases" annotation (Evaluate=true);
parameter Real phi[m](unit = "rad", displayUnit = "deg") = Modelica.Electrical.Polyphase.Functions.symmetricOrientation(m);
parameter Real TransformationMatrix[2, m] = 2*{cos(phi), sin(phi)}/m;
parameter Real InverseTransformation[m, 2] = array({cos(phi[k]),  -sin( -phi[k])} for k in 1:m);
public 
algorithm 
y := TransformationMatrix*x;
y0 := 1/m*sum(x);
annotation(Inline=true);
end Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor;

  */
DYMOLA_STATIC struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct
   Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(RealArray  
   x0_0) {
  PushContext("Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor")
  {
    /* Declare outputs and temporaries */
    RealArray    y0_0;
    double   y00_0;
    int   m0_0;
    RealArray    phi0_0;
    RealArray    TransformationMatrix0_0;
    RealArray    InverseTransformation0_0;
    RealArray    helperx_00;
    MarkObject retmark_ = PushMark();
    y0_0=RealTemporary( 1, 2);
    RePushMark(&retmark_);
    RealFillAssign( y0_0, 0);
    y00_0=0;
    m0_0 = DYNSizeSimple(x0_0, 1);
    phi0_0=RealTemporary( 1, m0_0);
    PushMark();
    RealAssign (phi0_0, Modelica_Electrical_Polyphase_Functions_symmetricOrientation
      (m0_0));
    Release();
    TransformationMatrix0_0=RealTemporary( 2, 2, m0_0);
    PushMark();
    RealAssign (TransformationMatrix0_0, RealScaleDiv (RealScale (RealArrayArray 
      ( 2, cos_For_1_0(phi0_0), sin_For_1_0(phi0_0)),2),m0_0));
    Release();
    helperx_00=RealTemporary( 2, IntegerBmax(0, m0_0), 2);
    PushMark();
    RealFillAssign( helperx_00, 0);
    InverseTransformation0_0=RealTemporary( 2, m0_0, 2);
    PushMark();
    {
      int end_ = m0_0;
      int k0_0_0;
      for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
        RealPutSub( RealScalarArray ( 2, cos(RealElement( phi0_0, (SizeType)(
          k0_0_0))),  -sin( -RealElement( phi0_0, (SizeType)(k0_0_0)))), 
          helperx_00 , Index, (Integer)(k0_0_0) ,Colon  , EndMark);
        Release();
      }
    }
    RealAssign (InverseTransformation0_0, helperx_00);
    Release();
    /* Start of real code */
      RealAssign (y0_0, RealMultiplyMV (TransformationMatrix0_0,x0_0));
      Release();
      y00_0 = divinvGuarded(m0_0,"m")*Realsum( x0_0);
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct out_;
      out_.y0_0_0member = y0_0;
      out_.y00_0_0member = y00_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Electrical.Polyphase.Functions.symmetricOrientation
input Integer m "Number of phases";
discrete output Real orientation[m](unit = "rad", displayUnit = "deg") "Orientation of the resulting fundamental wave field phasors";

algorithm 
if (mod(m, 2) == 0) then 
if (m == 2) then 
orientation[1] := 0;
orientation[2] := 1.5707963267948966;
else
orientation[1:integer(m/2)] := Modelica.Electrical.Polyphase.Functions.symmetricOrientation(integer(m/2));
orientation[integer(m/2)+1:m] := Modelica.Electrical.Polyphase.Functions.symmetricOrientation(integer(m/2))-fill(3.141592653589793/m, integer(m/2));
end if;
else
orientation := array((k-1)*2*3.141592653589793/m for k in 1:m);
end if;
end Modelica.Electrical.Polyphase.Functions.symmetricOrientation;

  */
DYMOLA_STATIC RealArray    Modelica_Electrical_Polyphase_Functions_symmetricOrientation
  (int  m0_0) {
  PushContext("Modelica.Electrical.Polyphase.Functions.symmetricOrientation")
  {
    /* Declare outputs and temporaries */
    RealArray    orientation0_0;
    RealArray    helperx_00;
    MarkObject retmark_ = PushMark();
    orientation0_0=RealTemporary( 1, m0_0);
    RePushMark(&retmark_);
    RealFillAssign( orientation0_0, 0);
    helperx_00=RealTemporary( 1, IntegerBmax(0, m0_0));
    PushMark();
    RealFillAssign( helperx_00, 0);
    /* Start of real code */
      if (real2integer(modulusDymola(m0_0, 2)) == 0) {
        if (m0_0 == 2) {
          SetRealElement(0, orientation0_0, (SizeType)(1));
          SetRealElement(1.5707963267948966, orientation0_0, (SizeType)(2));
        }
        else{
          RealPutSub( Modelica_Electrical_Polyphase_Functions_symmetricOrientation
            (real2integer(m0_0/(double)(2))), orientation0_0 ,Range , (Integer)(1),
             (Integer)(real2integer(m0_0/(double)(2))) , EndMark);
          Release();
          RealPutSub( RealSubtract (Modelica_Electrical_Polyphase_Functions_symmetricOrientation
            (real2integer(m0_0/(double)(2))),RealFill( divGuarded(
            3.141592653589793,"3.141592653589793",m0_0,"m"), 1, (SizeType)(
            real2integer(m0_0/(double)(2))))), orientation0_0 ,Range , (Integer)
            (real2integer(m0_0/(double)(2))+1), (Integer)(m0_0) , EndMark);
          Release();
        }
      }
      else{
        {
          int end_ = m0_0;
          int k0_0_0;
          for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
            SetRealElement(divGuarded((k0_0_0-1)*2*3.141592653589793,
              "(k-1)*2*3.141592653589793",m0_0,"m"), helperx_00, (SizeType)(
              k0_0_0));
          }
        }
        RealAssign (orientation0_0, helperx_00);
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return orientation0_0;
  }}

/* Flattened Modelica model:

function Modelica.Math.Vectors.interpolate
discrete input Real x[:] "Abscissa table vector (strict monotonically increasing values required)";
discrete input Real y[size(x, 1)] "Ordinate table vector";
discrete input Real xi "Desired abscissa value";
input Integer iLast(start = 1) "Index used in last search";
discrete output Real yi "Ordinate value corresponding to xi";
output Integer iNew(start = 1) "xi is in the interval x[iNew] <= xi < x[iNew+1]";
protected 
Integer i;
Integer nx(start = size(x, 1));
discrete Real x1;
discrete Real x2;
discrete Real y1;
discrete Real y2;
public 
algorithm 
assert(nx > 0, "The table vectors must have at least 1 entry.");
if (nx == 1) then 
yi := y[1];
else
i := min(max(iLast, 1), nx-1);
if (xi >= x[i]) then 
while i < nx and xi >= x[i] loop
i := i+1;
end while;
i := i-1;
else
while i > 1 and xi < x[i] loop
i := i-1;
end while;
end if;
x1 := x[i];
x2 := x[i+1];
y1 := y[i];
y2 := y[i+1];
assert(x2 > x1, "Abscissa table vector values must be increasing");
yi := y1+(y2-y1)*(xi-x1)/(x2-x1);
iNew := i;
end if;
annotation(smoothOrder=100);
end Modelica.Math.Vectors.interpolate;

  */
DYMOLA_STATIC struct Modelica_Math_Vectors_interpolate_struct Modelica_Math_Vectors_interpolate
  (RealArray   x0_0, RealArray   y0_0, double  xi0_0, int  iLast0_0) {
  PushContext("Modelica.Math.Vectors.interpolate")
  AssertModelica(DYNSizeSimple(y0_0,1)==DYNSizeSimple(x0_0, 1),"size(y, 1) == size(x, 1)","Dimension check of input to function failed");
  {
    /* Declare outputs and temporaries */
    double   yi0_0;
    int   iNew0_0;
    int   i0_0;
    int   nx0_0;
    double   x10_0;
    double   x20_0;
    double   y10_0;
    double   y20_0;
    yi0_0=0;
    iNew0_0 = 1;
    i0_0=0;
    nx0_0 = DYNSizeSimple(x0_0, 1);
    x10_0=0;
    x20_0=0;
    y10_0=0;
    y20_0=0;
    /* Start of real code */
      AssertModelica(nx0_0 > 0,"nx > 0", "The table vectors must have at least 1 entry.");
      if (nx0_0 == 1) {
        yi0_0 = RealElement( y0_0, (SizeType)(1));
      }
      else{
        i0_0 = IntegerBmin(IntegerBmax(iLast0_0, 1), nx0_0-1);
        if (xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
          while (i0_0 < nx0_0 AND xi0_0 >= RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0+1;
          }
          i0_0 = i0_0-1;
        }
        else{
          while (i0_0 > 1 AND xi0_0 < RealElement( x0_0, (SizeType)(i0_0))) {
            i0_0 = i0_0-1;
          }
        }
        x10_0 = RealElement( x0_0, (SizeType)(i0_0));
        x20_0 = RealElement( x0_0, (SizeType)(i0_0+1));
        y10_0 = RealElement( y0_0, (SizeType)(i0_0));
        y20_0 = RealElement( y0_0, (SizeType)(i0_0+1));
        AssertModelica(x20_0 > x10_0,"x2 > x1", "Abscissa table vector values must be increasing");
        yi0_0 = y10_0+divGuarded((y20_0-y10_0)*(xi0_0-x10_0),"(y2-y1)*(xi-x1)",
          x20_0-x10_0,"x2-x1");
        iNew0_0 = i0_0;
      }
    /* Output section */
    PopContext()
    {
      struct Modelica_Math_Vectors_interpolate_struct out_;
      out_.yi0_0_0member = yi0_0;
      out_.iNew0_0_0member = iNew0_0;
      return out_;
    }
  }}
DYMOLA_STATIC RealArray    cos_For_1_0(RealArray   u0_0) {
  PushContext("Vectorized ""cos")
   {
    RealArray   y0_0 = RealTemporary(  1, RealSize( u0_0, 1));
    int i_ ;
    int max_size_ = RealNrElements( y0_0);
    for(i_ = 0 ; i_ < max_size_; i_++) {
      y0_0.data[i_]=cos(u0_0.data[i_]);
    }
    PopContext()
    return y0_0;
  }
}
DYMOLA_STATIC RealArray    sin_For_1_0(RealArray   u0_0) {
  PushContext("Vectorized ""sin")
   {
    RealArray   y0_0 = RealTemporary(  1, RealSize( u0_0, 1));
    int i_ ;
    int max_size_ = RealNrElements( y0_0);
    for(i_ = 0 ; i_ < max_size_; i_++) {
      y0_0.data[i_]=sin(u0_0.data[i_]);
    }
    PopContext()
    return y0_0;
  }
}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(3)
#define NX_    9
#define NX2_   0
#define NU_    0
#define NY_    2
#define NW_    1100
#define NP_    0
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ 360078889
#define NHash2_ -1852740800
#define NHash3_ 0
#define NI_    0
#define NRelF_ 18
#define NRel_  18
#define NTim_  3
#define NSamp_ 0
#define NCons_ 0
#define NA_    975
#define SizePre_ 11
#define SizeEq_ 14
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 259
#define NGlobalHelpI_ 36
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="DrivetrainValidation.Examples.AveragedSwitched_Drive45";
#endif
DYMOLA_STATIC const char*usedLibraries[]={"BrushlessDCDrivesLib",0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/meagh/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[17]={5 , 3 , 1 , 6 , 7 , 2 , 2 , 8 , 2 , 3 , 9 , 1
   , 4 , 1 , 5 , 0 , 0};
static int QJacobianGrp0[10]={1, 1, 0, 1, 0, 7, 7, 7, 0, 0};
static int QJacobianGrp1[10]={2, 2, 0, 2, 0, 0, 8, 8, 0, 0};
static int QJacobianGrp2[10]={3, 3, 0, 3, 0, 0, 0, 9, 9, 0};
static int QJacobianGrp3[8]={1, 4 , 4 , 1 , 2 , 3 , 4 , 0};
static int QJacobianGrp4[7]={1, 5 , 3 , 1 , 2 , 5 , 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[6]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{0, QJacobianGrp2},{1, QJacobianGrp3},{1, 
  QJacobianGrp4},{0,0}};
DYMOLA_STATIC double QJacobianCD_[10]={0  , 44 , 50 , 54 , 56 , 56 , 99 , 110 , 110
   , 108};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
DYNX(Y_,0) = CurrentClockTime;
if (DYNEvent) DYNX(Y_,1) += 1;

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,3) = true;
DYNX(W_,5) = 3;
DYNX(W_,87) = 3;
DYNX(W_,88) = 3;
DYNX(W_,173) = 3;
DYNX(W_,177) = 3;
DYNX(W_,178) = 3;
DYNX(W_,184) = 3;
DYNX(W_,185) = 3;
DYNX(W_,194) = 3;
DYNX(W_,201) = 3;
DYNX(W_,202) = 3;
DYNX(W_,209) = 3;
DYNX(W_,210) = false;
DYNX(W_,217) = false;
DYNX(W_,223) = 1;
DYNX(W_,224) = 1;
DYNX(W_,228) = false;
DYNX(W_,234) = 1;
DYNX(W_,235) = 1;
DYNX(W_,239) = false;
memcpy(&DYNX(W_,245), &DymArrays0, sizeof(double)*3);
DYNX(W_,251) = 3;
DYNX(W_,252) = 3;
DYNX(W_,262) = 3;
DYNX(W_,263) = false;
DYNX(W_,270) = false;
DYNX(W_,276) = 1;
DYNX(W_,277) = 1;
DYNX(W_,281) = false;
DYNX(W_,287) = 1;
DYNX(W_,288) = 1;
DYNX(W_,292) = false;
memcpy(&DYNX(W_,298), &DymArrays0, sizeof(double)*3);
DYNX(W_,307) = 3;
DYNX(W_,308) = 3;
DYNX(W_,318) = 3;
DYNX(W_,319) = false;
DYNX(W_,327) = false;
DYNX(W_,333) = 1;
DYNX(W_,334) = 1;
DYNX(W_,339) = false;
DYNX(W_,345) = 1;
DYNX(W_,346) = 1;
DYNX(W_,351) = false;
memcpy(&DYNX(W_,357), &DymArrays0, sizeof(double)*3);
DYNX(W_,363) = 3;
DYNX(W_,367) = 3;
DYNX(W_,377) = 3;
DYNX(W_,378) = false;
DYNX(W_,386) = false;
DYNX(W_,392) = 1;
DYNX(W_,393) = 1;
DYNX(W_,398) = false;
DYNX(W_,404) = 1;
DYNX(W_,405) = 1;
DYNX(W_,410) = false;
DYNX(W_,416) = 1;
DYNX(W_,417) = 1;
DYNX(W_,425) = 3;
DYNX(W_,426) = 3;
DYNX(W_,450) = 3;
memcpy(&DYNX(W_,456), &DymArrays1, sizeof(double)*4);
DYNX(W_,467) = 3;
DYNX(W_,496) = false;
DYNX(W_,497) = false;
DYNX(W_,498) = 3;
DYNX(W_,511) = 3;
DYNX(W_,531) = 3;
DYNX(W_,536) = 3;
DYNX(W_,537) = 3;
DYNX(W_,547) = false;
DYNX(W_,548) = false;
DYNX(W_,556) = 3;
DYNX(W_,557) = 3;
DYNX(W_,559) = 3;
DYNX(W_,563) = 3;
DYNX(W_,564) = 3;
DYNX(W_,577) = 3;
DYNX(W_,578) = false;
DYNX(W_,586) = false;
DYNX(W_,595) = false;
DYNX(W_,604) = false;
DYNX(W_,609) = 3;
DYNX(W_,613) = 3;
DYNX(W_,614) = 3;
DYNX(W_,629) = 3;
DYNX(W_,761) = 3;
DYNX(W_,762) = 3;
DYNX(W_,767) = 3;
DYNX(W_,770) = 0.0001;
DYNX(W_,771) = 4;
DYNX(W_,773) = false;
DYNX(W_,779) = 3;
DYNX(W_,792) = 3;
DYNX(W_,793) = 1;
DYNX(W_,794) = false;
memcpy(&DYNX(W_,795), &DymArrays2, sizeof(double)*3);
DYNX(W_,799) = 3;
DYNX(W_,800) = 3;
DYNX(W_,807) = 3;
memcpy(&DYNX(W_,809), &DymArrays2, sizeof(double)*3);
DYNX(W_,822) = 3;
DYNX(W_,823) = 3;
DYNX(W_,843) = false;
DYNX(W_,849) = 3;
DYNX(W_,881) = true;
DYNX(W_,929) = 3;
DYNX(W_,932) = true;
DYNX(W_,958) = false;
DYNX(W_,959) = false;
DYNX(W_,969) = true;
DYNX(W_,974) = false;
DYNX(W_,975) = false;
DYNX(W_,983) = false;
DYNX(W_,987) = true;
DYNX(W_,996) = 3;
DYNX(W_,999) = 0.0001;
DYNX(W_,1000) = 4;
DYNX(W_,1002) = false;
DYNX(W_,1008) = 3;
DYNX(W_,1043) = false;
DYNX(W_,1049) = 3;
DYNX(W_,0) = 10000;
DYNX(W_,1) = true;
DYNX(W_,2) = 3;
DYNX(W_,4) = false;
DYNX(W_,89) = true;
DYNX(W_,6) = true;
DYNX(W_,90) = false;
DYNX(W_,7) = false;
DYNX(W_,91) = false;
DYNX(W_,8) = false;
DYNX(W_,92) = true;
DYNX(W_,9) = true;
DYNX(W_,93) = true;
DYNX(W_,10) = true;
DYNX(W_,94) = false;
DYNX(W_,11) = false;
DYNX(W_,95) = true;
DYNX(W_,12) = true;
DYNX(W_,96) = true;
DYNX(W_,13) = true;
DYNX(W_,97) = true;
DYNX(W_,14) = true;
DYNX(W_,98) = false;
DYNX(W_,15) = false;
DYNX(W_,99) = true;
DYNX(W_,16) = true;
DYNX(W_,100) = true;
DYNX(W_,17) = true;
DYNX(W_,101) = false;
DYNX(W_,18) = false;
DYNX(W_,102) = false;
DYNX(W_,19) = false;
DYNX(W_,103) = true;
DYNX(W_,20) = true;
DYNX(W_,104) = false;
DYNX(W_,21) = false;
DYNX(W_,105) = false;
DYNX(W_,22) = false;
DYNX(W_,106) = false;
DYNX(W_,23) = false;
DYNX(W_,107) = true;
DYNX(W_,24) = true;
DYNX(W_,108) = false;
DYNX(W_,25) = false;
DYNX(W_,109) = true;
DYNX(W_,26) = true;
DYNX(W_,110) = false;
DYNX(W_,27) = false;
DYNX(W_,111) = true;
DYNX(W_,28) = true;
DYNX(W_,112) = false;
DYNX(W_,29) = false;
DYNX(W_,113) = 1;
DYNX(W_,30) = 1;
DYNX(W_,114) = 2;
DYNX(W_,31) = 2;
DYNX(W_,115) = 4;
DYNX(W_,32) = 4;
DYNX(W_,116) = 1;
DYNX(W_,33) = 1;
DYNX(W_,117) = 4;
DYNX(W_,34) = 4;
DYNX(W_,118) = 2;
DYNX(W_,35) = 2;
DYNX(W_,119) = 4;
DYNX(W_,36) = 4;
DYNX(W_,120) = 1;
DYNX(W_,37) = 1;
DYNX(W_,121) = 2;
DYNX(W_,38) = 2;
DYNX(W_,122) = 2;
DYNX(W_,39) = 2;
DYNX(W_,123) = 1;
DYNX(W_,40) = 1;
DYNX(W_,124) = 4;
DYNX(W_,41) = 4;
DYNX(W_,125) = 2;
DYNX(W_,42) = 2;
DYNX(W_,126) = 4;
DYNX(W_,43) = 4;
DYNX(W_,127) = 1;
DYNX(W_,44) = 1;
DYNX(W_,128) = 4;
DYNX(W_,45) = 4;
DYNX(W_,129) = 2;
DYNX(W_,46) = 2;
DYNX(W_,130) = 1;
DYNX(W_,47) = 1;
DYNX(W_,131) = 4;
DYNX(W_,48) = 4;
DYNX(W_,132) = 4;
DYNX(W_,49) = 4;
DYNX(W_,133) = 4;
DYNX(W_,50) = 4;
DYNX(W_,134) = 4;
DYNX(W_,51) = 4;
DYNX(W_,135) = 4;
DYNX(W_,52) = 4;
DYNX(W_,136) = 4;
DYNX(W_,53) = 4;
DYNX(W_,137) = 2;
DYNX(W_,54) = 2;
DYNX(W_,138) = 1;
DYNX(W_,55) = 1;
DYNX(W_,139) = 4;
DYNX(W_,56) = 4;
DYNX(W_,140) = 2;
DYNX(W_,57) = 2;
DYNX(W_,141) = 4;
DYNX(W_,58) = 4;
DYNX(W_,142) = 1;
DYNX(W_,59) = 1;
DYNX(W_,143) = 4;
DYNX(W_,60) = 4;
DYNX(W_,144) = 2;
DYNX(W_,61) = 2;
DYNX(W_,145) = 1;
DYNX(W_,62) = 1;
DYNX(W_,146) = 1;
DYNX(W_,63) = 1;
DYNX(W_,147) = 2;
DYNX(W_,64) = 2;
DYNX(W_,148) = 4;
DYNX(W_,65) = 4;
DYNX(W_,149) = 1;
DYNX(W_,66) = 1;
DYNX(W_,150) = 4;
#endif
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,67) = 4;
DYNX(W_,151) = 2;
DYNX(W_,68) = 2;
DYNX(W_,152) = 4;
DYNX(W_,69) = 4;
DYNX(W_,153) = 1;
DYNX(W_,70) = 1;
DYNX(W_,154) = 2;
DYNX(W_,71) = 2;
DYNX(W_,155) = 4;
DYNX(W_,72) = 4;
DYNX(W_,156) = 4;
DYNX(W_,73) = 4;
DYNX(W_,157) = 4;
DYNX(W_,74) = 4;
DYNX(W_,158) = 4;
DYNX(W_,75) = 4;
DYNX(W_,159) = 4;
DYNX(W_,76) = 4;
DYNX(W_,160) = 4;
DYNX(W_,77) = 4;
DYNX(W_,161) = 3;
DYNX(W_,162) = 3;
DYNX(W_,169) = 3;
DYNX(W_,447) = false;
DYNX(W_,174) = false;
DYNX(W_,448) = 1E-05;
DYNX(W_,175) = 1E-05;
DYNX(W_,449) = 1E-05;
DYNX(W_,176) = 1E-05;
memcpy(&DYNX(W_,203), &DymArrays3, sizeof(double)*6);
memcpy(&DYNX(W_,211), &DymArrays4, sizeof(double)*3);
DYNX(W_,215) = 1E-05;
DYNX(W_,216) = 1E-05;
DYNX(W_,218) = 293.15;
DYNX(W_,226) = 1E-05;
DYNX(W_,227) = 1E-05;
DYNX(W_,229) = 293.15;
DYNX(W_,237) = 1E-05;
DYNX(W_,238) = 1E-05;
DYNX(W_,240) = 293.15;
memcpy(&DYNX(W_,256), &DymArrays3, sizeof(double)*6);
memcpy(&DYNX(W_,264), &DymArrays4, sizeof(double)*3);
DYNX(W_,268) = 1E-05;
DYNX(W_,269) = 1E-05;
DYNX(W_,271) = 293.15;
DYNX(W_,279) = 1E-05;
DYNX(W_,280) = 1E-05;
DYNX(W_,282) = 293.15;
DYNX(W_,290) = 1E-05;
DYNX(W_,291) = 1E-05;
DYNX(W_,293) = 293.15;
memcpy(&DYNX(W_,309), &DymArrays5, sizeof(double)*9);
memcpy(&DYNX(W_,320), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,324), &DymArrays6, sizeof(double)*3);
DYNX(W_,328) = 293.15;
memcpy(&DYNX(W_,336), &DymArrays6, sizeof(double)*3);
DYNX(W_,340) = 293.15;
memcpy(&DYNX(W_,348), &DymArrays6, sizeof(double)*3);
DYNX(W_,352) = 293.15;
memcpy(&DYNX(W_,368), &DymArrays5, sizeof(double)*9);
memcpy(&DYNX(W_,379), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,383), &DymArrays6, sizeof(double)*3);
DYNX(W_,387) = 293.15;
memcpy(&DYNX(W_,395), &DymArrays6, sizeof(double)*3);
DYNX(W_,399) = 293.15;
memcpy(&DYNX(W_,407), &DymArrays6, sizeof(double)*3);
DYNX(W_,411) = 293.15;
DYNX(W_,427) = false;
memcpy(&DYNX(W_,429), &DymArrays7, sizeof(double)*7);
memcpy(&DYNX(W_,437), &DymArrays8, sizeof(double)*3);
DYNX(W_,441) = 1.0;
DYNX(W_,442) = 0.0;
DYNX(W_,443) = false;
DYNX(W_,444) = 2;
DYNX(W_,445) = false;
DYNX(W_,446) = 3;
DYNX(W_,468) = 0.0155;
DYNX(W_,469) = 2;
DYNX(W_,470) = true;
DYNX(W_,471) = true;
memcpy(&DYNX(W_,472), &DymArrays9, sizeof(double)*24);
DYNX(W_,506) = 3;
DYNX(W_,507) = 2;
DYNX(W_,532) = 0.5235987755982988;
DYNX(W_,512) = 0.5235987755982988;
DYNX(W_,533) = 1.5707963267948966;
DYNX(W_,513) = 1.5707963267948966;
DYNX(W_,534) = 2.617993877991494;
DYNX(W_,514) = 2.617993877991494;
DYNX(W_,535) = 3.141592653589793;
memcpy(&DYNX(W_,515), &DymArrays10, sizeof(double)*11);
memcpy(&DYNX(W_,538), &DymArrays11, sizeof(double)*9);
memcpy(&DYNX(W_,549), &DymArrays12, sizeof(double)*4);
memcpy(&DYNX(W_,568), &DymArrays13, sizeof(double)*9);
memcpy(&DYNX(W_,579), &DymArrays14, sizeof(double)*6);
DYNX(W_,587) = 293.15;
memcpy(&DYNX(W_,591), &DymArrays15, sizeof(double)*3);
DYNX(W_,596) = 293.15;
memcpy(&DYNX(W_,600), &DymArrays15, sizeof(double)*3);
DYNX(W_,605) = 293.15;
memcpy(&DYNX(W_,618), &DymArrays16, sizeof(double)*3);
DYNX(W_,624) = 2E-06;
DYNX(W_,626) = 2E-06;
DYNX(W_,628) = 2E-06;
memcpy(&DYNX(W_,630), &DymArrays17, sizeof(double)*12);
memcpy(&DYNX(W_,653), &DymArrays18, sizeof(double)*108);
DYNX(W_,766) = 1E-15;
DYNX(W_,772) = 0.0003704676056338029;
DYNX(W_,778) = 1E-15;
DYNX(W_,785) = 0;
DYNX(W_,802) = 0;
DYNX(W_,834) = -1;
DYNX(W_,848) = 0.0629;
DYNX(W_,859) = 0.5;
memcpy(&DYNX(W_,861), &DymArrays19, sizeof(double)*3);
DYNX(W_,867) = -5.139;
memcpy(&DYNX(W_,869), &DymArrays20, sizeof(double)*5);
DYNX(W_,874) = true;
DYNX(W_,876) = 0.5;
memcpy(&DYNX(W_,878), &DymArrays21, sizeof(double)*3);
DYNX(W_,882) = false;
DYNX(W_,883) = 3;
DYNX(W_,886) = false;
DYNX(W_,889) = false;
memcpy(&DYNX(W_,891), &DymArrays7, sizeof(double)*7);
memcpy(&DYNX(W_,899), &DymArrays8, sizeof(double)*3);
DYNX(W_,903) = 1.0;
DYNX(W_,904) = 0.0;
DYNX(W_,905) = false;
DYNX(W_,906) = 2;
DYNX(W_,930) = 0.0155;
DYNX(W_,931) = 2;
DYNX(W_,933) = true;
memcpy(&DYNX(W_,934), &DymArrays9, sizeof(double)*24);
DYNX(W_,968) = 0.0155;
memcpy(&DYNX(W_,970), &DymArrays22, sizeof(double)*4);
DYNX(W_,976) = 0.1342;
memcpy(&DYNX(W_,978), &DymArrays23, sizeof(double)*3);
DYNX(W_,984) = 293.15;
DYNX(W_,988) = 0.1342;
DYNX(W_,995) = 1E-15;
DYNX(W_,1001) = 0.0003704676056338029;
DYNX(W_,1007) = 1E-15;
DYNX(W_,1014) = 0;
DYNX(W_,1020) = 4E-06;
DYNX(W_,1023) = -1;
DYNX(W_,1036) = 0;
DYNX(W_,1048) = 0.0629;
DYNX(W_,1060) = 60;
DYNX(W_,1064) = -5.139;
memcpy(&DYNX(W_,1066), &DymArrays24, sizeof(double)*4);
DYNX(W_,764) = 0.0;
DYNX(W_,763) = 0;
DYNX(W_,864) = 60;
DYNX(W_,856) = 0;
DYNX(W_,854) = 60.0;
DYNX(W_,418) = 60.0;
DYNX(W_,608) = 0.00775;
DYNX(W_,599) = 0.00775;
DYNX(W_,590) = 0.00775;
DYNX(W_,839) = 0;
DYNX(W_,836) = 0;
DYNX(W_,508) = 0;
DYNX(W_,805) = 0;
DYNX(W_,781) = 0.0;
DYNX(W_,780) = 0.0;
DYNX(W_,783) = 0.0;
DYNX(W_,782) = 0.0;
DYNX(W_,1010) = 0.0;
DYNX(W_,1009) = 0;
DYNX(W_,986) = 0.0155;
DYNX(W_,1061) = 60;
DYNX(W_,1057) = 0;
DYNX(W_,1055) = 60.0;
DYNX(W_,907) = 60.0;
DYNX(W_,888) = 0;
DYNX(W_,1031) = 0;
DYNX(W_,1034) = 0;
DYNX(W_,1012) = 0.0;
DYNX(W_,1011) = 0.0;
DYNX(W_,1039) = 0;
DYNX(W_,463) = 0;
DYNX(W_,461) = 0;
DYNX(W_,464) = 60.0;
DYNX(W_,812) = 0;
DYNX(W_,501) = 0.0;
DYNX(W_,510) = 0;
DYNX(W_,775) = 0.0;
DYNX(W_,804) = 0.0;
DYNX(W_,831) = 0.0;
DYNX(W_,845) = 0;
DYNX(W_,1024) = 0;
DYNX(W_,925) = 0;
DYNX(W_,1026) = 0;
DYNX(W_,923) = 0;
DYNX(W_,926) = 60.0;
DYNX(W_,963) = 0.0;
DYNX(W_,1004) = 0.0;
DYNX(W_,1038) = 0.0;
DYNX(W_,1045) = 0;
DYNX(W_,1065) = -5.139;
DYNX(W_,866) = 0.0;
DYNX(W_,865) = 60.0;
DYNX(W_,1063) = 0.0;
DYNX(W_,1062) = 60.0;
DYNX(W_,1072) = 60.0;
DYNX(W_,1073) = 60.0;
DYNX(W_,841) = 0.0;
DYNX(W_,847) = -5.139;
DYNX(W_,1074) = 60.0;
DYNX(W_,420) = 0.0;
DYNX(W_,421) = 0.0;
DYNX(W_,419) = 60.0;
DYNX(W_,389) = 293.15;
DYNX(W_,382) = 0.0;
DYNX(W_,401) = 293.15;
DYNX(W_,394) = 0.0;
DYNX(W_,413) = 293.15;
DYNX(W_,406) = 0.0;
memcpy(&DYNX(W_,364), &DymArrays25, sizeof(double)*3);
DYNX(W_,273) = 293.15;
DYNX(W_,267) = 0.0;
DYNX(W_,284) = 293.15;
DYNX(W_,278) = 0.0;
DYNX(W_,295) = 293.15;
DYNX(W_,289) = 0.0;
memcpy(&DYNX(W_,253), &DymArrays25, sizeof(double)*3);
DYNX(W_,424) = 0.0;
DYNX(W_,423) = 60.0;
DYNX(W_,192) = 0.0;
DYNX(W_,186) = 0.0;
DYNX(W_,188) = 0.0;
DYNX(W_,190) = 0.0;
DYNX(W_,436) = 0.0;
DYNX(W_,440) = 0.0;
DYNX(W_,330) = 293.15;
DYNX(W_,342) = 293.15;
DYNX(W_,354) = 293.15;
DYNX(W_,220) = 293.15;
DYNX(W_,231) = 293.15;
DYNX(W_,242) = 293.15;
DYNX(W_,1075) = 60.0;
DYNX(W_,1076) = 60.0;
DYNX(W_,455) = 60.0;
DYNX(W_,454) = 60.0;
DYNX(W_,171) = 0.0;
DYNX(W_,170) = 60.0;
DYNX(W_,1070) = 60.0;
DYNX(W_,465) = 60.0;
#endif
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,462) = 0.0;
DYNX(W_,460) = 60.0;
DYNX(W_,1077) = 60.0;
DYNX(W_,1078) = 60.0;
memcpy(&DYNX(W_,528), &DymArrays25, sizeof(double)*3);
DYNX(W_,1079) = 60.0;
DYNX(W_,509) = 0.0;
DYNX(W_,838) = 0.0;
DYNX(W_,840) = 0.0;
DYNX(W_,1080) = 60.0;
DYNX(W_,769) = 0.0;
DYNX(W_,786) = 0.0;
DYNX(W_,784) = 0.0;
DYNX(W_,774) = 0.0;
DYNX(W_,776) = 0.0;
DYNX(W_,777) = 0.0;
DYNX(W_,788) = 0.0;
DYNX(W_,789) = 0.0;
DYNX(W_,589) = 293.15;
DYNX(W_,598) = 293.15;
DYNX(W_,607) = 293.15;
DYNX(W_,1081) = 60.0;
DYNX(W_,813) = 0.0;
DYNX(W_,815) = 0.0;
DYNX(W_,814) = 0.0;
DYNX(W_,817) = 0.0;
DYNX(W_,816) = 0.0;
DYNX(W_,803) = 0.0;
DYNX(W_,833) = 0.0;
DYNX(W_,832) = 0.0;
DYNX(W_,1082) = 60.0;
DYNX(W_,1083) = 60.0;
DYNX(W_,806) = 0.0;
DYNX(W_,1084) = 60.0;
DYNX(W_,1085) = 60.0;
DYNX(W_,835) = 0.0;
DYNX(W_,837) = 0.0;
DYNX(W_,830) = 0.0;
DYNX(W_,825) = 0.0;
DYNX(W_,824) = 0.0;
DYNX(W_,827) = 0.0;
DYNX(W_,826) = 0.0;
DYNX(W_,829) = 0.0;
DYNX(W_,828) = 0.0;
DYNX(W_,801) = 0.0;
DYNX(W_,798) = 0.0;
DYNX(W_,1086) = 60.0;
DYNX(W_,1087) = 60.0;
DYNX(W_,850) = 5.139;
DYNX(W_,851) = -5.139;
DYNX(W_,853) = 5.139;
DYNX(W_,844) = 5.139;
DYNX(W_,846) = -5.139;
DYNX(W_,857) = -5.139;
DYNX(W_,1088) = 60.0;
DYNX(W_,1041) = 0.0;
DYNX(W_,1047) = -5.139;
DYNX(W_,1089) = 60.0;
DYNX(W_,909) = 0.0;
DYNX(W_,910) = 0.0;
DYNX(W_,908) = 60.0;
DYNX(W_,914) = 0.0;
DYNX(W_,913) = 0.0;
DYNX(W_,912) = 60.0;
DYNX(W_,898) = 0.0;
DYNX(W_,902) = 0.0;
DYNX(W_,1090) = 60.0;
DYNX(W_,1091) = 60.0;
DYNX(W_,919) = 60.0;
DYNX(W_,918) = 60.0;
DYNX(W_,916) = 0.0;
DYNX(W_,885) = 0.0;
DYNX(W_,884) = 60.0;
DYNX(W_,1071) = 60.0;
DYNX(W_,927) = 60.0;
DYNX(W_,924) = 0.0;
DYNX(W_,922) = 60.0;
DYNX(W_,1092) = 60.0;
DYNX(W_,1030) = 0.0;
DYNX(W_,1032) = 0.0;
DYNX(W_,1093) = 60.0;
DYNX(W_,993) = 0.0;
DYNX(W_,992) = 0.0;
DYNX(W_,990) = 0.0;
DYNX(W_,991) = 0.0;
DYNX(W_,998) = 0.0;
DYNX(W_,1015) = 0.0;
DYNX(W_,1013) = 0.0;
DYNX(W_,1003) = 0.0;
DYNX(W_,1005) = 0.0;
DYNX(W_,1006) = 0.0;
DYNX(W_,1021) = 0.0;
DYNX(W_,1022) = 0.0;
DYNX(W_,977) = 0.0;
DYNX(W_,985) = 293.15;
DYNX(W_,1094) = 60.0;
DYNX(W_,1037) = 0.0;
DYNX(W_,1095) = 60.0;
DYNX(W_,1096) = 60.0;
DYNX(W_,1040) = 0.0;
DYNX(W_,1097) = 60.0;
DYNX(W_,1098) = 60.0;
DYNX(W_,960) = 0.0;
DYNX(W_,1025) = 0.0;
DYNX(W_,1029) = 0.0;
DYNX(W_,1028) = 0.0;
DYNX(W_,1027) = 0.0;
DYNX(W_,1033) = 0.0;
DYNX(W_,1035) = 0.0;
DYNX(W_,1099) = 60.0;
DYNX(W_,1051) = 5.139;
DYNX(W_,1052) = -5.139;
DYNX(W_,1054) = 5.139;
DYNX(W_,1044) = 5.139;
DYNX(W_,1046) = -5.139;
DYNX(W_,1058) = -5.139;
DYNX(W_,868) = -5.139;
DYNX(W_,917) = 0.0;
DYNX(W_,1042) = 0.0;
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,331) = true;
DYNX(W_,332) = 0;
DYNX(W_,343) = true;
DYNX(W_,344) = 0;
DYNX(W_,355) = true;
DYNX(W_,356) = 0;
DYNX(W_,390) = true;
DYNX(W_,391) = 0;
DYNX(W_,402) = true;
DYNX(W_,403) = 0;
DYNX(W_,414) = true;
DYNX(W_,415) = 0;
DYNX(W_,622) = 0;
DYNX(W_,1050) = 0;
DYNX(F_,3) = 0;
DYNX(F_,6) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(F_,4) = 0;
DYNX(F_,8) = 0;
DYNX(W_,917) = 0.0;
DYNX(W_,1042) = 0.0;
DYNX(W_,860) = 0.3+(IF LessTime(5, 0) THEN 0 ELSE 0.5);
DYNX(X_,4) = DYNX(W_,860);
DYNX(W_,877) = 0.3+(IF LessTime(5, 0) THEN 0 ELSE 0.5);
DYNX(X_,8) = DYNX(W_,877);
DYNX(X_,5) =  -DYNX(W_,1050);
DYNX(W_,428) = homotopy(IF GreaterS(DYNX(X_,4),"firstOrder.y", 1.0,"1.0", 0)
   THEN 1.0 ELSE IF LessS(DYNX(X_,4),"firstOrder.y", 0.0,"0.0", 1) THEN 0.0
   ELSE DYNX(X_,4), DYNX(X_,4));
DYNX(W_,890) = homotopy(IF GreaterS(DYNX(X_,8),"firstOrder1.y", 1.0,"1.0", 2)
   THEN 1.0 ELSE IF LessS(DYNX(X_,8),"firstOrder1.y", 0.0,"0.0", 3) THEN 0.0
   ELSE DYNX(X_,8), DYNX(X_,8));
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection

DynamicsSection
DYNX(W_,860) = 0.3+(IF LessTime(5, 0) THEN 0 ELSE 0.5);
DYNX(F_,4) = 12.5*(DYNX(W_,860)-DYNX(X_,4));
DYNX(W_,643) = (-2)*DYNX(X_,3);
DYNX(W_,642) = modulusDymolaEvent((-2)*DYNX(X_,2),"(-2)*drive.machine.coreElement.damper.phi_rel",
   6.283185307179586,"6.283185307179586", 4);
DYNX(W_,648) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({0.5235987755982987, 1.5707963267948966, 2.617993877991495, 4.71238898038469, 5.759586531581288, 6.806784082777886}, {1.0, 1.0, -1.0, -1.0, 1.0, 1.0}, drive.machine.coreElement.trapezoidalEMF.theta, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays26, 1, 6), 
  RealTemporaryDense( DymArrays27, 1, 6), DYNX(W_,642), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,651) = 0.03355*DYNX(W_,648);
DYNX(W_,645) = DYNX(W_,643)*DYNX(W_,651);
DYNX(W_,594) = 0.00775*DYNX(X_,0);
DYNX(W_,526) = (-2)*DYNX(X_,2);
DYNX(W_,527) = modulusDymolaEvent(DYNX(W_,526),"drive.machine.angleSensor.coreElement.electricAngle",
   6.283185307179586,"6.283185307179586", 5);
DYNX(W_,81) = GreaterEqual(DYNX(W_,527),"drive.machine.angleSensor.coreElement.electricAngleLim",
   0.5235987755982988,"0.5235987755982988", 6) AND LessEqual(DYNX(W_,527),
  "drive.machine.angleSensor.coreElement.electricAngleLim", 3.665191429188092,
  "3.665191429188092", 7);
DYNX(W_,82) = GreaterEqual(DYNX(W_,527),"drive.machine.angleSensor.coreElement.electricAngleLim",
   1.5707963267948966,"1.5707963267948966", 8) AND LessEqual(DYNX(W_,527),
  "drive.machine.angleSensor.coreElement.electricAngleLim", 4.71238898038469,
  "4.71238898038469", 9);
DYNX(W_,83) = GreaterEqual(DYNX(W_,527),"drive.machine.angleSensor.coreElement.electricAngleLim",
   2.617993877991494,"2.617993877991494", 10) AND LessEqual(DYNX(W_,527),
  "drive.machine.angleSensor.coreElement.electricAngleLim", 5.759586531581287,
  "5.759586531581287", 11);
DYNX(W_,80) = IF GreaterEqualTime(10000, 1) THEN false ELSE true;
DYNX(W_,79) = PRE(DYNX(W_,79), 7);
DYNX(W_,84) = PRE(DYNX(W_,84), 8);
DYNX(W_,85) = PRE(DYNX(W_,85), 9);
DYNX(W_,86) = PRE(DYNX(W_,86), 10);
  DYNX(W_,78) = 0;
  {
    int i_0_;
    int end_ = DYNSizeSimple(IntegerTemporaryDense( &DYNX(W_,30), 2, 8, 3), 1);
    int row0_0_0;
    for(i_0_ = 0, row0_0_0 = 1;row0_0_0 <= end_;row0_0_0 += 1 , ++i_0_) {
      DYNX(W_,79) = true;
      PopAllMarks();
      {
        int i_1_;
        int end_ = DYNSizeSimple(IntegerTemporaryDense( &DYNX(W_,30), 2, 8, 3), 2);
        int col0_0_0;
        for(i_1_ = 0, col0_0_0 = 1;col0_0_0 <= end_;col0_0_0 += 1 , ++i_1_) {
          DYNX(W_,79) = DYNX(W_,79) AND (Integer)(PushModelContext(2,
            "drive.controller.coreElement.inputTable[row, col]")RealElement( 
            RealTemporaryDense( &DYNX(W_,6), 2, 8, 3), (SizeType)(row0_0_0), 
            (SizeType)(col0_0_0))) == (Integer)(PushModelContext(2,
            "drive.controller.coreElement.u[col]")RealElement( RealTemporaryDense( 
            &DYNX(W_,81), 1, 3), (SizeType)(col0_0_0)));
          PopAllMarks();
        }
      }
      if (DYNX(W_,79)) {
        DYNX(W_,78) = row0_0_0;
      }
    }
  }
  AssertModelica(DYNX(W_,78) > 0,"drive.controller.coreElement.activeRow > 0", 
    "### SixStep controller did not find suitable combinations of inputs in the inputTable ###\n");
  if (DYNX(W_,80)) {
    RealPutSub( RealConvertInteger (IntegerConvertReal((PushModelContext(2,
      "drive.controller.coreElement.outputTableCW[drive.controller.coreElement.activeRow, :]")
      RealGetSub( RealTemporaryDense( &DYNX(W_,30), 2, 8, 3) , Index, (Integer)(
      DYNX(W_,78)) ,Colon  , EndMark)))), RealTemporaryDense( &DYNX(W_,84), 1, 3)
       ,Colon  , EndMark);
    PopAllMarks();
  }
  else{
    RealPutSub( RealConvertInteger (IntegerConvertReal((PushModelContext(2,
      "drive.controller.coreElement.outputTableCCW[drive.controller.coreElement.activeRow, :]")
      RealGetSub( RealTemporaryDense( &DYNX(W_,54), 2, 8, 3) , Index, (Integer)(
      DYNX(W_,78)) ,Colon  , EndMark)))), RealTemporaryDense( &DYNX(W_,84), 1, 3)
       ,Colon  , EndMark);
    PopAllMarks();
  }
DYNX(W_,166) = DYNX(W_,85) == 2 OR DYNX(W_,85) == 3;
DYNX(W_,285) =  NOT DYNX(W_,166);
DYNX(W_,428) = IF GreaterS(DYNX(X_,4),"firstOrder.y", 1.0,"1.0", 0) THEN 1.0
   ELSE IF LessS(DYNX(X_,4),"firstOrder.y", 0.0,"0.0", 1) THEN 0.0 ELSE 
  DYNX(X_,4);
DYNX(W_,422) = IF DYNX(W_,428) >= 0 THEN DYNX(W_,428) ELSE  -DYNX(W_,428);
DYNX(W_,179) = 60.0*DYNX(W_,422);
DYNX(W_,165) = DYNX(W_,85) == 1 OR DYNX(W_,85) == 3;
DYNX(W_,232) =  NOT DYNX(W_,165);

MixedSystemOfEquations(11, DYNX(DYNhelp,0))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[1] */
  /* Introducing 8 common subexpressions used in 9 expressions */
  /* Of the common subexpressions 8 are reals, 0 are integers, and 0
     are booleans. */
  /* Automatic tearing of linear system of 11 simultaneous equations
  gave a linear system of 4 equations for numerical solution.*/
  {
    const char*const varnames_[]={"drive.inverter.coreElement.upperDiode.idealDiode[2].s",
       "drive.inverter.coreElement.lowerDiode.idealDiode[2].s", "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].s",
       "drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].s"};
    const double nominal_[]={1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,11), 64, 
      DYNX(did_->helpvari_vec,0), 12);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,75) = IF DYNX(W_,402) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,76) =  -DYNX(DYNhelp,75);
      DYNX(DYNhelp,77) = IF DYNX(W_,343) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,78) = IF DYNX(W_,402) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,79) = IF DYNX(W_,285) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,80) = IF DYNX(W_,232) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,81) = IF DYNX(W_,232) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,82) = IF DYNX(W_,343) THEN 1 ELSE 1E-05;
      SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,76));
      SetMatrixLeading(J, 1, 3, 4,  -(IF DYNX(W_,285) THEN 1 ELSE 1E-05));
      SetMatrixLeading(J, 2, 1, 4, (-1.0)*DYNX(DYNhelp,77));
      SetMatrixLeading(J, 2, 2, 4, DYNX(DYNhelp,78));
      SetMatrixLeading(J, 2, 3, 4, (-1.0)*DYNX(DYNhelp,79));
      SetMatrixLeading(J, 2, 4, 4, DYNX(DYNhelp,80));
      SetMatrixLeading(J, 3, 2, 4, DYNX(DYNhelp,76));
      SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,81));
      SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,82));
      SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,75));
    }
    SetVector(b, 2, DYNX(X_,0));
    SetVector(b, 3, DYNX(W_,179));
    SetVector(b, 4,  -DYNX(W_,179));
    SetVector(y, 1, RememberSimple_(DYNX(W_,344), 0));
    SetVector(y, 2, RememberSimple_(DYNX(W_,403), 1));
    SetVector(y, 3, RememberSimple_(DYNX(W_,286), 2));
    SetVector(y, 4, RememberSimple_(DYNX(W_,233), 3));
    SolveLinearSystemOfEquationsMixed(J, b, y, 1, "simulation.linear[1]");
    DYNX(W_,344) = GetVector(y, 1);
    DYNX(W_,403) = GetVector(y, 2);
    DYNX(W_,286) = GetVector(y, 3);
    DYNX(W_,233) = GetVector(y, 4);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,305) = DYNX(W_,344)*DYNX(DYNhelp,77);
  DYNX(W_,361) = DYNX(W_,403)*DYNX(DYNhelp,78);
  DYNX(W_,249) = DYNX(W_,286)*DYNX(DYNhelp,79);
  DYNX(W_,199) = DYNX(W_,233)*DYNX(DYNhelp,80);
  DYNX(W_,225) = DYNX(W_,233)*DYNX(DYNhelp,81);
  DYNX(W_,452) =  -DYNX(W_,403)*DYNX(DYNhelp,75);
  DYNX(W_,335) = DYNX(W_,344)*DYNX(DYNhelp,82);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,343),"drive.inverter.coreElement.upperDiode.idealDiode[2].off",
     Less(DYNX(W_,344),"drive.inverter.coreElement.upperDiode.idealDiode[2].s", 0,
    "0", 12));
  UpdateVariableNamed(DYNX(W_,402),"drive.inverter.coreElement.lowerDiode.idealDiode[2].off",
     Less(DYNX(W_,403),"drive.inverter.coreElement.lowerDiode.idealDiode[2].s", 0,
    "0", 13));
  MixedModeInit(2, DYNX(DYNhelp,83))
  ThetaMixedCross(0,12)
  ThetaMixedCross(1,13)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,335), 1)
  UpdateReal(DYNX(W_,344), 2)
  UpdateReal(DYNX(W_,305), 3)
  UpdateReal(DYNX(W_,403), 4)
  UpdateReal(DYNX(W_,361), 5)
  UpdateReal(DYNX(W_,286), 6)
  UpdateReal(DYNX(W_,249), 7)
  UpdateReal(DYNX(W_,199), 8)
  UpdateReal(DYNX(W_,233), 9)
  UpdateReal(DYNX(W_,225), 10)
  UpdateReal(DYNX(W_,452), 11)
EndMixedSystemOfEquations

DYNX(W_,566) = DYNX(W_,452)-DYNX(W_,594);
DYNX(W_,647) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({-0.5235987755982996, 0.5235987755982983, 2.617993877991493, 3.665191429188092, 5.759586531581287, 6.8067840827778845}, {1.0, -1.0, -1.0, 1.0, 1.0, -1.0}, drive.machine.coreElement.trapezoidalEMF.theta, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays28, 1, 6), 
  RealTemporaryDense( DymArrays29, 1, 6), DYNX(W_,642), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,650) = 0.03355*DYNX(W_,647);
DYNX(W_,644) = DYNX(W_,643)*DYNX(W_,650);
DYNX(W_,622) =  -(DYNX(X_,0)+DYNX(X_,1));
DYNX(W_,585) = 0.00775*DYNX(W_,622);
DYNX(W_,164) = DYNX(W_,84) == 2 OR DYNX(W_,84) == 3;
DYNX(W_,274) =  NOT DYNX(W_,164);
DYNX(W_,163) = DYNX(W_,84) == 1 OR DYNX(W_,84) == 3;
DYNX(W_,221) =  NOT DYNX(W_,163);

MixedSystemOfEquations(11, DYNX(DYNhelp,85))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[2] */
  /* Introducing 8 common subexpressions used in 9 expressions */
  /* Of the common subexpressions 8 are reals, 0 are integers, and 0
     are booleans. */
  /* Automatic tearing of linear system of 11 simultaneous equations
  gave a linear system of 4 equations for numerical solution.*/
  {
    const char*const varnames_[]={"drive.inverter.coreElement.upperDiode.idealDiode[1].s",
       "drive.inverter.coreElement.lowerDiode.idealDiode[1].s", "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].s",
       "drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].s"};
    const double nominal_[]={1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,96), 64, 
      DYNX(did_->helpvari_vec,12), 12);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,160) = IF DYNX(W_,390) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,161) =  -DYNX(DYNhelp,160);
      DYNX(DYNhelp,162) = IF DYNX(W_,331) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,163) = IF DYNX(W_,390) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,164) = IF DYNX(W_,274) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,165) = IF DYNX(W_,221) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,166) = IF DYNX(W_,221) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,167) = IF DYNX(W_,331) THEN 1 ELSE 1E-05;
      SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,161));
      SetMatrixLeading(J, 1, 3, 4,  -(IF DYNX(W_,274) THEN 1 ELSE 1E-05));
      SetMatrixLeading(J, 2, 1, 4, (-1.0)*DYNX(DYNhelp,162));
      SetMatrixLeading(J, 2, 2, 4, DYNX(DYNhelp,163));
      SetMatrixLeading(J, 2, 3, 4, (-1.0)*DYNX(DYNhelp,164));
      SetMatrixLeading(J, 2, 4, 4, DYNX(DYNhelp,165));
      SetMatrixLeading(J, 3, 2, 4, DYNX(DYNhelp,161));
      SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,166));
      SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,167));
      SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,160));
    }
    SetVector(b, 2, DYNX(W_,622));
    SetVector(b, 3, DYNX(W_,179));
    SetVector(b, 4,  -DYNX(W_,179));
    SetVector(y, 1, RememberSimple_(DYNX(W_,332), 4));
    SetVector(y, 2, RememberSimple_(DYNX(W_,391), 5));
    SetVector(y, 3, RememberSimple_(DYNX(W_,275), 6));
    SetVector(y, 4, RememberSimple_(DYNX(W_,222), 7));
    SolveLinearSystemOfEquationsMixed(J, b, y, 2, "simulation.linear[2]");
    DYNX(W_,332) = GetVector(y, 1);
    DYNX(W_,391) = GetVector(y, 2);
    DYNX(W_,275) = GetVector(y, 3);
    DYNX(W_,222) = GetVector(y, 4);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,304) = DYNX(W_,332)*DYNX(DYNhelp,162);
  DYNX(W_,360) = DYNX(W_,391)*DYNX(DYNhelp,163);
  DYNX(W_,248) = DYNX(W_,275)*DYNX(DYNhelp,164);
  DYNX(W_,198) = DYNX(W_,222)*DYNX(DYNhelp,165);
  DYNX(W_,214) = DYNX(W_,222)*DYNX(DYNhelp,166);
  DYNX(W_,451) =  -DYNX(W_,391)*DYNX(DYNhelp,160);
  DYNX(W_,323) = DYNX(W_,332)*DYNX(DYNhelp,167);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,331),"drive.inverter.coreElement.upperDiode.idealDiode[1].off",
     Less(DYNX(W_,332),"drive.inverter.coreElement.upperDiode.idealDiode[1].s", 0,
    "0", 14));
  UpdateVariableNamed(DYNX(W_,390),"drive.inverter.coreElement.lowerDiode.idealDiode[1].off",
     Less(DYNX(W_,391),"drive.inverter.coreElement.lowerDiode.idealDiode[1].s", 0,
    "0", 15));
  MixedModeInit(2, DYNX(DYNhelp,168))
  ThetaMixedCross(0,14)
  ThetaMixedCross(1,15)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,323), 1)
  UpdateReal(DYNX(W_,332), 2)
  UpdateReal(DYNX(W_,304), 3)
  UpdateReal(DYNX(W_,391), 4)
  UpdateReal(DYNX(W_,360), 5)
  UpdateReal(DYNX(W_,275), 6)
  UpdateReal(DYNX(W_,248), 7)
  UpdateReal(DYNX(W_,198), 8)
  UpdateReal(DYNX(W_,222), 9)
  UpdateReal(DYNX(W_,214), 10)
  UpdateReal(DYNX(W_,451), 11)
EndMixedSystemOfEquations

DYNX(W_,565) = DYNX(W_,451)-DYNX(W_,585);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
DYNX(W_,603) = 0.00775*DYNX(X_,1);
DYNX(W_,168) = DYNX(W_,86) == 2 OR DYNX(W_,86) == 3;
DYNX(W_,296) =  NOT DYNX(W_,168);
DYNX(W_,167) = DYNX(W_,86) == 1 OR DYNX(W_,86) == 3;
DYNX(W_,243) =  NOT DYNX(W_,167);

MixedSystemOfEquations(11, DYNX(DYNhelp,170))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[3] */
  /* Introducing 8 common subexpressions used in 9 expressions */
  /* Of the common subexpressions 8 are reals, 0 are integers, and 0
     are booleans. */
  /* Automatic tearing of linear system of 11 simultaneous equations
  gave a linear system of 4 equations for numerical solution.*/
  {
    const char*const varnames_[]={"drive.inverter.coreElement.upperDiode.idealDiode[3].s",
       "drive.inverter.coreElement.lowerDiode.idealDiode[3].s", "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].s",
       "drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].s"};
    const double nominal_[]={1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,181), 64, 
      DYNX(did_->helpvari_vec,24), 12);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,245) = IF DYNX(W_,414) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,246) =  -DYNX(DYNhelp,245);
      DYNX(DYNhelp,247) = IF DYNX(W_,355) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,248) = IF DYNX(W_,414) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,249) = IF DYNX(W_,296) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,250) = IF DYNX(W_,243) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,251) = IF DYNX(W_,243) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,252) = IF DYNX(W_,355) THEN 1 ELSE 1E-05;
      SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,246));
      SetMatrixLeading(J, 1, 3, 4,  -(IF DYNX(W_,296) THEN 1 ELSE 1E-05));
      SetMatrixLeading(J, 2, 1, 4, (-1.0)*DYNX(DYNhelp,247));
      SetMatrixLeading(J, 2, 2, 4, DYNX(DYNhelp,248));
      SetMatrixLeading(J, 2, 3, 4, (-1.0)*DYNX(DYNhelp,249));
      SetMatrixLeading(J, 2, 4, 4, DYNX(DYNhelp,250));
      SetMatrixLeading(J, 3, 2, 4, DYNX(DYNhelp,246));
      SetMatrixLeading(J, 3, 4, 4, DYNX(DYNhelp,251));
      SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,252));
      SetMatrixLeading(J, 4, 2, 4, DYNX(DYNhelp,245));
    }
    SetVector(b, 2, DYNX(X_,1));
    SetVector(b, 3, DYNX(W_,179));
    SetVector(b, 4,  -DYNX(W_,179));
    SetVector(y, 1, RememberSimple_(DYNX(W_,356), 8));
    SetVector(y, 2, RememberSimple_(DYNX(W_,415), 9));
    SetVector(y, 3, RememberSimple_(DYNX(W_,297), 10));
    SetVector(y, 4, RememberSimple_(DYNX(W_,244), 11));
    SolveLinearSystemOfEquationsMixed(J, b, y, 3, "simulation.linear[3]");
    DYNX(W_,356) = GetVector(y, 1);
    DYNX(W_,415) = GetVector(y, 2);
    DYNX(W_,297) = GetVector(y, 3);
    DYNX(W_,244) = GetVector(y, 4);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,306) = DYNX(W_,356)*DYNX(DYNhelp,247);
  DYNX(W_,362) = DYNX(W_,415)*DYNX(DYNhelp,248);
  DYNX(W_,250) = DYNX(W_,297)*DYNX(DYNhelp,249);
  DYNX(W_,200) = DYNX(W_,244)*DYNX(DYNhelp,250);
  DYNX(W_,236) = DYNX(W_,244)*DYNX(DYNhelp,251);
  DYNX(W_,453) =  -DYNX(W_,415)*DYNX(DYNhelp,245);
  DYNX(W_,347) = DYNX(W_,356)*DYNX(DYNhelp,252);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,355),"drive.inverter.coreElement.upperDiode.idealDiode[3].off",
     Less(DYNX(W_,356),"drive.inverter.coreElement.upperDiode.idealDiode[3].s", 0,
    "0", 16));
  UpdateVariableNamed(DYNX(W_,414),"drive.inverter.coreElement.lowerDiode.idealDiode[3].off",
     Less(DYNX(W_,415),"drive.inverter.coreElement.lowerDiode.idealDiode[3].s", 0,
    "0", 17));
  MixedModeInit(2, DYNX(DYNhelp,253))
  ThetaMixedCross(0,16)
  ThetaMixedCross(1,17)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,347), 1)
  UpdateReal(DYNX(W_,356), 2)
  UpdateReal(DYNX(W_,306), 3)
  UpdateReal(DYNX(W_,415), 4)
  UpdateReal(DYNX(W_,362), 5)
  UpdateReal(DYNX(W_,297), 6)
  UpdateReal(DYNX(W_,250), 7)
  UpdateReal(DYNX(W_,200), 8)
  UpdateReal(DYNX(W_,244), 9)
  UpdateReal(DYNX(W_,236), 10)
  UpdateReal(DYNX(W_,453), 11)
EndMixedSystemOfEquations

DYNX(W_,567) = DYNX(W_,453)-DYNX(W_,603);
DYNX(W_,649) = (PushModelContext(1,"Modelica.Math.Vectors.interpolate({-0.5235987755982996, 0.5235987755982983, 1.5707963267948966, 3.6651914291880914, 4.71238898038469, 5.759586531581288}, {-1.0, -1.0, 1.0, 1.0, -1.0, -1.0}, drive.machine.coreElement.trapezoidalEMF.theta, 1)")
  Modelica_Math_Vectors_interpolate(RealTemporaryDense( DymArrays30, 1, 6), 
  RealTemporaryDense( DymArrays31, 1, 6), DYNX(W_,642), 1).yi0_0_0member);
PopAllMarks();
DYNX(W_,652) = 0.03355*DYNX(W_,649);
DYNX(W_,646) = DYNX(W_,643)*DYNX(W_,652);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[4] */
/* Automatic tearing of linear system of 6 simultaneous equations
gave a linear system of 2 equations for numerical solution.*/
{
const char*const varnames_[]={"drive.machine.coreElement.overallInductance.inductor[2].der(i)",
   "drive.machine.coreElement.overallInductance.inductor[3].der(i)"};
const double nominal_[]={1, 1};
DYNX(F_,0)=RememberSimple_(DYNX(F_,0), 12);
DYNX(F_,1)=RememberSimple_(DYNX(F_,1), 13);
SolveLinear2by2(-2E-06, -4E-06, 
2E-06, -2E-06, 
DYNX(W_,565)-DYNX(W_,567)+DYNX(W_,646)-DYNX(W_,644), DYNX(W_,566)-DYNX(W_,567)+
  DYNX(W_,646)-DYNX(W_,645), &DYNX(F_,0), &DYNX(F_,1), 
varnames_, (DSE_STRUCT QiErr), "simulation.linear[4]");
if (*(DSE_STRUCT QiErr)!=0) {goto leave;}
}
DYNX(W_,623) =  -(DYNX(F_,0)+DYNX(F_,1));
DYNX(W_,621) = 2E-06*DYNX(W_,623);
DYNX(W_,625) = 2E-06*DYNX(F_,0);
DYNX(W_,627) = 2E-06*DYNX(F_,1);
 /* End of Equation Block */ 

DYNX(F_,2) = DYNX(X_,3);
DYNX(W_,768) = 0.0003704676056338029*DYNX(X_,3);
DYNX(W_,790) = 2*(DYNX(W_,650)*DYNX(W_,622)+DYNX(W_,651)*DYNX(X_,0)+DYNX(W_,652)
  *DYNX(X_,1));

DYNX(F_,3) = (-15.898251192368587)*(DYNX(W_,768)+DYNX(W_,790)-5.139);
DYNX(W_,765) =  -(DYNX(W_,790)+1E-15*DYNX(F_,3));
DYNX(W_,858) = 0.0629*DYNX(F_,3)-5.139;

DYNX(W_,877) = 0.3+(IF LessTime(5, 0) THEN 0 ELSE 0.5);
DYNX(F_,8) = 12.5*(DYNX(W_,877)-DYNX(X_,8));
DYNX(W_,981) = 0.0155*DYNX(X_,7);
DYNX(W_,890) = IF GreaterS(DYNX(X_,8),"firstOrder1.y", 1.0,"1.0", 2) THEN 1.0
   ELSE IF LessS(DYNX(X_,8),"firstOrder1.y", 0.0,"0.0", 3) THEN 0.0 ELSE 
  DYNX(X_,8);
DYNX(W_,875) = IF GreaterEqualTime(1000, 2) THEN false ELSE true;
DYNX(W_,915) = IF DYNX(W_,875) THEN -1 ELSE 1;
DYNX(W_,911) = DYNX(W_,890)*DYNX(W_,915);
DYNX(W_,887) = 60.0*DYNX(W_,911);
DYNX(W_,982) = DYNX(W_,887)-DYNX(W_,981);
DYNX(W_,989) = (-0.1342)*DYNX(X_,6);
DYNX(W_,1019) = DYNX(W_,982)-DYNX(W_,989);
DYNX(F_,7) = 250000.0*DYNX(W_,1019);
DYNX(W_,997) = 0.0003704676056338029*DYNX(X_,6);
DYNX(W_,1018) = 0.1342*DYNX(X_,7);

DYNX(F_,6) = (-15.898251192368587)*(DYNX(W_,997)+DYNX(W_,1018)-5.139);
DYNX(W_,994) =  -(DYNX(W_,1018)+1E-15*DYNX(F_,6));
DYNX(W_,1059) = 0.0629*DYNX(F_,6)-5.139;

DYNX(F_,5) = DYNX(X_,6);

AcceptedSection1

AcceptedSection2
DYNX(W_,1050) =  -DYNX(X_,5);
DYNX(W_,617) = DYNX(W_,567)-DYNX(W_,627);
DYNX(W_,616) = DYNX(W_,566)-DYNX(W_,625);
DYNX(W_,558) = DYNX(W_,617)-DYNX(W_,646);
DYNX(W_,615) = DYNX(W_,565)-DYNX(W_,621);
DYNX(W_,180) = DYNX(W_,304)-DYNX(W_,198);
DYNX(W_,181) = DYNX(W_,305)-DYNX(W_,199);
DYNX(W_,182) = DYNX(W_,306)-DYNX(W_,200);
DYNX(W_,183) =  -(DYNX(W_,180)+DYNX(W_,181)+DYNX(W_,182));
DYNX(W_,187) = DYNX(W_,248)-DYNX(W_,360);
DYNX(W_,189) = DYNX(W_,249)-DYNX(W_,361);
DYNX(W_,191) = DYNX(W_,250)-DYNX(W_,362);
DYNX(W_,193) =  -(DYNX(W_,187)+DYNX(W_,189)+DYNX(W_,191));
DYNX(W_,855) = DYNX(W_,422)*DYNX(W_,183);
DYNX(W_,172) = DYNX(W_,193)-DYNX(W_,855)+DYNX(W_,183);
DYNX(W_,195) = DYNX(W_,179)-DYNX(W_,451);
DYNX(W_,196) = DYNX(W_,179)-DYNX(W_,452);
DYNX(W_,197) = DYNX(W_,179)-DYNX(W_,453);
DYNX(W_,219) = DYNX(W_,214)*DYNX(W_,198);
DYNX(W_,230) = DYNX(W_,225)*DYNX(W_,199);
DYNX(W_,241) = DYNX(W_,236)*DYNX(W_,200);
DYNX(W_,272) = DYNX(W_,451)*DYNX(W_,248);
DYNX(W_,283) = DYNX(W_,452)*DYNX(W_,249);
DYNX(W_,294) = DYNX(W_,453)*DYNX(W_,250);
DYNX(W_,301) = DYNX(W_,451)-DYNX(W_,179);
DYNX(W_,302) = DYNX(W_,452)-DYNX(W_,179);
DYNX(W_,303) = DYNX(W_,453)-DYNX(W_,179);
DYNX(W_,329) = DYNX(W_,323)*DYNX(W_,304);
DYNX(W_,341) = DYNX(W_,335)*DYNX(W_,305);
DYNX(W_,353) = DYNX(W_,347)*DYNX(W_,306);
DYNX(W_,388) =  -DYNX(W_,451)*DYNX(W_,360);
DYNX(W_,400) =  -DYNX(W_,452)*DYNX(W_,361);
DYNX(W_,412) =  -DYNX(W_,453)*DYNX(W_,362);
DYNX(W_,466) =  -DYNX(W_,858)*DYNX(X_,3);
{
  RealAssign(RealTemporaryDense(&(DYNX(DYNhelp,255)), 1, 2), (PushModelContext(1,
    "Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({drive.inverter.plug.pin[1].v, drive.inverter.plug.pin[2].v, drive.inverter.plug.pin[3].v})")
    Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(
    RealTemporaryDense( &DYNX(W_,451), 1, 3)).y0_0_0member));
}
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,818), 1, 2), RealTemporaryDense(&(
  DYNX(DYNhelp,255)), 1, 2));
PopAllMarks();
{
  RealAssign(RealTemporaryDense(&(DYNX(DYNhelp,257)), 1, 2), (PushModelContext(1,
    "Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({drive.machine.coreElement.overallInductance.inductor[1].i, drive.machine.coreElement.overallInductance.inductor[2].i, drive.machine.coreElement.overallInductance.inductor[3].i})")
    Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(
    RealScalarArray ( 3, DYNX(W_,622), DYNX(X_,0), DYNX(X_,1))).y0_0_0member));
}
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,820), 1, 2), RealTemporaryDense(&(
  DYNX(DYNhelp,257)), 1, 2));
PopAllMarks();
DYNX(W_,499) = 1.5*(DYNX(W_,818)*DYNX(W_,820)+DYNX(W_,819)*DYNX(W_,821));
DYNX(W_,791) = DYNX(W_,790)+DYNX(W_,765)-DYNX(W_,858);
DYNX(W_,500) = DYNX(X_,3)*DYNX(W_,791);
DYNX(W_,502) = 1E-15*DYNX(F_,3)*DYNX(X_,3);
DYNX(W_,588) = DYNX(W_,585)*DYNX(W_,622);
DYNX(W_,597) = DYNX(W_,594)*DYNX(X_,0);
DYNX(W_,606) = DYNX(W_,603)*DYNX(X_,1);
DYNX(W_,505) = DYNX(W_,768)*DYNX(X_,3);
DYNX(W_,503) = DYNX(W_,588)+DYNX(W_,597)+DYNX(W_,606)+DYNX(W_,505);
DYNX(W_,504) = DYNX(W_,588)+DYNX(W_,597)+DYNX(W_,606);
DYNX(W_,553) = DYNX(W_,451)-DYNX(W_,558);
DYNX(W_,554) = DYNX(W_,452)-DYNX(W_,558);
DYNX(W_,555) = DYNX(W_,453)-DYNX(W_,558);
DYNX(W_,560) = DYNX(W_,451)-DYNX(W_,565);
DYNX(W_,561) = DYNX(W_,452)-DYNX(W_,566);
DYNX(W_,562) = DYNX(W_,453)-DYNX(W_,567);
DYNX(W_,610) = DYNX(W_,565)-DYNX(W_,615);
DYNX(W_,611) = DYNX(W_,566)-DYNX(W_,616);
DYNX(W_,612) = DYNX(W_,567)-DYNX(W_,617);
DYNX(W_,787) =  -(DYNX(W_,768)+DYNX(W_,790));
DYNX(W_,808) = 1.5*(DYNX(W_,819)*DYNX(W_,820)-DYNX(W_,818)*DYNX(W_,821));
DYNX(W_,842) =  -(DYNX(W_,855)+DYNX(W_,172));
DYNX(W_,852) = (-5.139)*DYNX(X_,3);
DYNX(W_,921) = IF DYNX(W_,875) THEN -1 ELSE 1;
DYNX(W_,920) = DYNX(X_,7)*DYNX(W_,921);
DYNX(W_,928) =  -DYNX(W_,1059)*DYNX(X_,6);
DYNX(W_,961) = DYNX(W_,887)*DYNX(X_,7);
DYNX(W_,1017) = DYNX(W_,1018)+DYNX(W_,994)-DYNX(W_,1059);
DYNX(W_,962) = DYNX(X_,6)*DYNX(W_,1017);
DYNX(W_,964) = 1E-15*DYNX(F_,6)*DYNX(X_,6);
DYNX(W_,966) = DYNX(W_,981)*DYNX(X_,7);
DYNX(W_,967) = DYNX(W_,997)*DYNX(X_,6);
DYNX(W_,965) = DYNX(W_,966)+DYNX(W_,967);
DYNX(W_,1016) =  -(DYNX(W_,1018)+DYNX(W_,997));
DYNX(W_,1056) = DYNX(W_,911)*DYNX(X_,7);
DYNX(W_,1053) = (-5.139)*DYNX(X_,6);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("rotateCW.startTime", "Time instant of step start [s]", 10000, \
0.0,0.0,0.0,0,513)
DeclareVariable("rotateCW.startValue", "Output before startTime [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareAlias2("rotateCW.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.rotateCW", 1, 5, 80, 65)
DeclareVariable("drive.controller.m", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("drive.controller.useDirectionInput", "[:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.rotateCW", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,515)
DeclareAlias2("drive.controller.rotateCW_In", "[:#(type=Boolean)]", \
"drive.controller.coreElement.rotateCW", 1, 5, 80, 65)
DeclareAlias2("drive.controller.dutyCycleOut", "Connector of Real output signal [1]",\
 "firstOrder.y", 1, 1, 4, 0)
DeclareVariable("drive.controller.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.inputTable[1, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[1, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[1, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[2, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[2, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[2, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[3, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[3, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[3, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[4, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[4, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[4, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[5, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[5, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[5, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[6, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[6, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[6, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[7, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[7, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[7, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[8, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[8, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[8, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.outputTableCW[1, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[1, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[1, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[2, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[2, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[2, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[3, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[3, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[3, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[4, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[4, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[4, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[5, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[5, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[5, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[6, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[6, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[6, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[7, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[7, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[7, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[8, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[8, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[8, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[1, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[1, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[1, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[2, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[2, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[2, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[3, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[3, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[3, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[4, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[4, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[4, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[5, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[5, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[5, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[6, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[6, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[6, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[7, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[7, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[7, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[8, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[8, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[8, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.activeRow", "Row in 'inputTable' which was provided by the sensor, 'outputTable' is chosen accordingly [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,644)
DeclareVariable("drive.controller.coreElement.same", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.controller.coreElement.rotateCW", "[:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,642)
DeclareVariable("drive.controller.coreElement.u[1]", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,642)
DeclareVariable("drive.controller.coreElement.u[2]", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,642)
DeclareVariable("drive.controller.coreElement.u[3]", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,642)
DeclareVariable("drive.controller.coreElement.halfBridgeOutput[1]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]", 1, 1.0,4.0,\
0.0,0,644)
DeclareVariable("drive.controller.coreElement.halfBridgeOutput[2]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]", 1, 1.0,4.0,\
0.0,0,644)
DeclareVariable("drive.controller.coreElement.halfBridgeOutput[3]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]", 1, 1.0,4.0,\
0.0,0,644)
DeclareAlias2("drive.controller.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 0)
DeclareVariable("drive.controller.hallSensorOutput.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.controller.hallSensorOutput.u[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 81, 65)
DeclareAlias2("drive.controller.hallSensorOutput.u[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 82, 65)
DeclareAlias2("drive.controller.hallSensorOutput.u[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 83, 65)
DeclareVariable("drive.controller.data.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.controller.data.inputTable[1, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[1, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[1, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[2, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[2, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[2, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[3, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[3, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[3, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[4, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[4, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[4, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[5, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[5, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[5, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[6, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[6, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[6, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[7, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[7, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[7, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[8, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[8, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[8, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.outputTableCW[1, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[1, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[1, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[2, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[2, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[2, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[3, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[3, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[3, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[4, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[4, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[4, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[5, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[5, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[5, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[6, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[6, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[6, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[7, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[7, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[7, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[8, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[8, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[8, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[1, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[1, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[1, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[2, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[2, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[2, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[3, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[3, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[3, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[4, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[4, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[4, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[5, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[5, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[5, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[6, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[6, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[6, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[7, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[7, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[7, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[8, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[8, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[8, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareAlias2("drive.controller.halfBridgeOutput[1]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]",\
 "drive.controller.coreElement.halfBridgeOutput[1]", 1, 5, 84, 66)
DeclareAlias2("drive.controller.halfBridgeOutput[2]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]",\
 "drive.controller.coreElement.halfBridgeOutput[2]", 1, 5, 85, 66)
DeclareAlias2("drive.controller.halfBridgeOutput[3]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]",\
 "drive.controller.coreElement.halfBridgeOutput[3]", 1, 5, 86, 66)
DeclareVariable("drive.modulation.m", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareAlias2("drive.modulation.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 0)
DeclareVariable("drive.modulation.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.modulation.coreElement.halfBridgeInput[1]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]", \
"drive.controller.coreElement.halfBridgeOutput[1]", 1, 5, 84, 66)
DeclareAlias2("drive.modulation.coreElement.halfBridgeInput[2]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]", \
"drive.controller.coreElement.halfBridgeOutput[2]", 1, 5, 85, 66)
DeclareAlias2("drive.modulation.coreElement.halfBridgeInput[3]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]", \
"drive.controller.coreElement.halfBridgeOutput[3]", 1, 5, 86, 66)
DeclareAlias2("drive.modulation.coreElement.y[1, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[1, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.modulation.coreElement.y[1, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[1, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.modulation.coreElement.y[2, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[2, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.modulation.coreElement.y[2, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[2, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.modulation.coreElement.y[3, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[3, 1]", 1, 5, 167, 65)
DeclareAlias2("drive.modulation.coreElement.y[3, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[3, 2]", 1, 5, 168, 65)
DeclareAlias2("drive.modulation.coreElement.dutyCycleOut", "Connector of Real output signal [1]",\
 "firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.modulation.coreElement.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.modulation.dutyCycleOut", "Connector of Real output signal [1]",\
 "firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.modulation.halfBridgeInput[1]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]",\
 "drive.controller.coreElement.halfBridgeOutput[1]", 1, 5, 84, 66)
DeclareAlias2("drive.modulation.halfBridgeInput[2]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]",\
 "drive.controller.coreElement.halfBridgeOutput[2]", 1, 5, 85, 66)
DeclareAlias2("drive.modulation.halfBridgeInput[3]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]",\
 "drive.controller.coreElement.halfBridgeOutput[3]", 1, 5, 86, 66)
DeclareVariable("drive.modulation.y[1, 1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[1, 2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[2, 1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[2, 2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[3, 1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[3, 2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareAlias2("drive.modulation.dutyCycle.u", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 0)
DeclareVariable("drive.inverter.m", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("drive.inverter.pin_p.v", "Potential at the pin [V]", 60.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.pin_p.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", 1, 5, 855, 132)
DeclareVariable("drive.inverter.pin_n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.pin_n.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.bidirectional", "Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.inverter.coreElement.Ron", "Closed switch resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.Goff", "Opened switch conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.star_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.pin[1].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.star_p.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.pin[2].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.star_p.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.pin[3].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.star_p.pin_n.v", "Potential at the pin [V]",\
 "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1, 5, 179, 4)
DeclareVariable("drive.inverter.coreElement.star_p.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.star_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[1].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[2].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[3].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.star_n.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.star_n.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.upperSwitch.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.upperSwitch.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[1]", 1,\
 5, 198, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[2]", 1,\
 5, 199, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[3]", 1,\
 5, 200, 132)
DeclareVariable("drive.inverter.coreElement.upperSwitch.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[1]", -1,\
 5, 198, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[2]", -1,\
 5, 199, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[3]", -1,\
 5, 200, 132)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Ron[1]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Ron[2]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Ron[3]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Goff[1]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Goff[2]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Goff[3]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.upperSwitch.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperSwitch.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.control[1]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[1, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.control[2]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[2, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.control[3]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[3, 1]", 1, 5, 167, 65)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].v",\
 "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].p.v",\
 "Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[1]", 1,\
 5, 198, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].n.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].n.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[1]", -1,\
 5, 198, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperSwitch.i[1]", 1,\
 5, 198, 0)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[1, 1]", 1, 5, 163, 65)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].v",\
 "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].p.v",\
 "Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[2]", 1,\
 5, 199, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].n.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].n.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[2]", -1,\
 5, 199, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperSwitch.i[2]", 1,\
 5, 199, 0)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[2, 1]", 1, 5, 165, 65)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].v",\
 "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].p.v",\
 "Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[3]", 1,\
 5, 200, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].n.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].n.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[3]", -1,\
 5, 200, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperSwitch.i[3]", 1,\
 5, 200, 0)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[3, 1]", 1, 5, 167, 65)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 451, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 452, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 453, 0)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[1]", 1,\
 5, 248, 132)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[2]", 1,\
 5, 249, 132)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[3]", 1,\
 5, 250, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_n.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[1]", -1,\
 5, 248, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_n.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[2]", -1,\
 5, 249, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_n.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[3]", -1,\
 5, 250, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Ron[1]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Ron[2]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Ron[3]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Goff[1]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Goff[2]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Goff[3]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.control[1]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[1, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.control[2]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[2, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.control[3]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[3, 2]", 1, 5, 168, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[1].v", 1,\
 5, 451, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].p.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[1]", 1,\
 5, 248, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].n.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[1]", -1,\
 5, 248, 132)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerSwitch.i[1]", 1,\
 5, 248, 0)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[1, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[2].v", 1,\
 5, 452, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].p.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[2]", 1,\
 5, 249, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].n.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[2]", -1,\
 5, 249, 132)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerSwitch.i[2]", 1,\
 5, 249, 0)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[2, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[3].v", 1,\
 5, 453, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].p.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[3]", 1,\
 5, 250, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].n.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[3]", -1,\
 5, 250, 132)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerSwitch.i[3]", 1,\
 5, 250, 0)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[3, 2]", 1, 5, 168, 65)
DeclareVariable("drive.inverter.coreElement.upperDiode.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.upperDiode.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[1]", 1,\
 5, 304, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[2]", 1,\
 5, 305, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[3]", 1,\
 5, 306, 132)
DeclareVariable("drive.inverter.coreElement.upperDiode.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[1]", -1,\
 5, 304, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[2]", -1,\
 5, 305, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[3]", -1,\
 5, 306, 132)
DeclareVariable("drive.inverter.coreElement.upperDiode.Ron[1]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Ron[2]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Ron[3]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Goff[1]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Goff[2]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Goff[3]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Vknee[1]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Vknee[2]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Vknee[3]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.upperDiode.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperDiode.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[1]", 1,\
 5, 304, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].n.v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].n.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[1]", -1,\
 5, 304, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperDiode.i[1]", 1,\
 5, 304, 0)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[2]", 1,\
 5, 305, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].n.v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].n.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[2]", -1,\
 5, 305, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperDiode.i[2]", 1,\
 5, 305, 0)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[3]", 1,\
 5, 306, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].n.v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].n.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[3]", -1,\
 5, 306, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperDiode.i[3]", 1,\
 5, 306, 0)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[1].v", -1, 5, 451, 0)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[2].v", -1, 5, 452, 0)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[3].v", -1, 5, 453, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_p.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[1]", 1,\
 5, 360, 132)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_p.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[2]", 1,\
 5, 361, 132)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_p.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[3]", 1,\
 5, 362, 132)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[1]", -1,\
 5, 360, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[2]", -1,\
 5, 361, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[3]", -1,\
 5, 362, 132)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Ron[1]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Ron[2]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Ron[3]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Goff[1]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Goff[2]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Goff[3]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Vknee[1]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Vknee[2]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Vknee[3]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.lowerDiode.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerDiode.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[1].v", -1,\
 5, 451, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].p.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[1].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[1]", 1,\
 5, 360, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[1].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[1].n.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[1]", -1,\
 5, 360, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[1].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerDiode.i[1]", 1,\
 5, 360, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[2].v", -1,\
 5, 452, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].p.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[2].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[2]", 1,\
 5, 361, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[2].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[2].n.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[2]", -1,\
 5, 361, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[2].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerDiode.i[2]", 1,\
 5, 361, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[3].v", -1,\
 5, 453, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].p.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[3].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[3]", 1,\
 5, 362, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[3].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[3].n.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[3]", -1,\
 5, 362, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[3].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerDiode.i[3]", 1,\
 5, 362, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.v1", \
"Voltage drop of port 1 (= p1.v - n1.v) [V]", 60.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.v2", \
"Voltage drop of port 2 (= p2.v - n2.v) [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 0)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.i1", \
"Current flowing from pos. to neg. pin of port 1 [A]", "drive.pin_p.i", 1, 5, 855,\
 0)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.i2", \
"Current flowing from pos. to neg. pin of port 2 [A]", "drive.inverter.coreElement.star_p.pin_n.i", -1,\
 5, 183, 0)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.p1.v", \
"Potential at the pin [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.p1.i", \
"Current flowing into the pin [A]", "drive.pin_p.i", 1, 5, 855, 132)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.n1.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.n1.i", \
"Current flowing into the pin [A]", "drive.pin_p.i", -1, 5, 855, 132)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.p2.v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 179, 4)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.p2.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.star_p.pin_n.i", -1,\
 5, 183, 132)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.n2.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.n2.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.star_p.pin_n.i", 1,\
 5, 183, 132)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.dutyCycle", "[1]",\
 0.0, 0.0,1.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.dutyCycle", "[1]", "firstOrder.y", 1, 1,\
 4, 0)
DeclareVariable("drive.inverter.coreElement.pin_p.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.pin_p.i", "Current flowing into the pin [A]",\
 "drive.pin_p.i", 1, 5, 855, 132)
DeclareAlias2("drive.inverter.coreElement.u[1, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[1, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.inverter.coreElement.u[1, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[1, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.u[2, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[2, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.inverter.coreElement.u[2, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[2, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.inverter.coreElement.u[3, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[3, 1]", 1, 5, 167, 65)
DeclareAlias2("drive.inverter.coreElement.u[3, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[3, 2]", 1, 5, 168, 65)
DeclareVariable("drive.inverter.coreElement.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.pin_n.i", "Current flowing into the pin [A]",\
 "drive.inverter.pin_n.i", 1, 5, 172, 132)
DeclareVariable("drive.inverter.coreElement.plug.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.plug.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.coreElement.plug.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", -1, 5, 622, 132)
DeclareAlias2("drive.inverter.coreElement.plug.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.coreElement.plug.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", -1, 1, 0, 132)
DeclareAlias2("drive.inverter.coreElement.plug.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.coreElement.plug.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", -1, 1, 1, 132)
DeclareVariable("drive.inverter.coreElement.rotationSwitch.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.rotationSwitch.bidirectional", \
"Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[1, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[1, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[1, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[1, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[2, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[2, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[2, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[2, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[3, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[3, 1]", 1, 5, 167, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[3, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[3, 2]", 1, 5, 168, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[1, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[1, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[1, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[1, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[2, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[2, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[2, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[2, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[3, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[3, 1]", 1, 5, 167, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[3, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[3, 2]", 1, 5, 168, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.dutyCycle", "[1]", \
"firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.u", \
"Connector of Real input signal [1]", "firstOrder.y", 1, 1, 4, 0)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.y", \
"Connector of Real output signal [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.u1", \
"Lower boundary of input u, switching from constant value y1 to linear interpolation",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.u2", \
"Upper boundary of input u, switching from linear interpolation to constant value y2",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.y1", \
"Minimum value for y", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.y2", \
"Maximum value for y", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.k", \
"Slope of the resulting line equation [1]", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.y0", \
"Offset of the resulting line equation", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.gradient.k", \
"Gain value multiplied with input signal [1]", 1.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.gradient.u", \
"Input signal connector [1]", "firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.gradient.y", \
"Output signal connector [1]", "firstOrder.y", 1, 1, 4, 0)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.add.u1", \
"Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.add.u2", \
"Connector of Real input signal 2 [1]", "firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.add.y", \
"Connector of Real output signal", "firstOrder.y", 1, 1, 4, 0)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.add.k1", \
"Gain of input signal 1", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.add.k2", \
"Gain of input signal 2", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.offset.k", \
"Constant output value", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.offset.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.limiter.uMax", \
"Upper limits of input signals", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.limiter.uMin", \
"Lower limits of input signals", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.limiter.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.limiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.limiter.u", \
"Connector of Real input signal", "firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.limiter.y", \
"Connector of Real output signal [1]", "drive.inverter.coreElement.uniOrBidirectional.y", 1,\
 5, 428, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.limiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization", "firstOrder.y", 1, 1,\
 4, 1024)
DeclareAlias2("drive.inverter.coreElement.abs.u", "Connector of Real input signal [1]",\
 "drive.inverter.coreElement.uniOrBidirectional.y", 1, 5, 428, 0)
DeclareAlias2("drive.inverter.coreElement.abs.y", "Connector of Real output signal [1]",\
 "drive.inverter.coreElement.idealBuckConverter.dutyCycle", 1, 5, 422, 0)
DeclareVariable("drive.inverter.coreElement.abs.generateEvent", "Choose whether events shall be generated [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.inverter.data.m", "Number of phases [:#(type=Integer)]", 3,\
 0.0,0.0,0.0,0,517)
DeclareVariable("drive.inverter.data.bidirectional", "Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.inverter.data.Ron", "Closed switch resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.data.Goff", "Opened switch conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareAlias2("drive.inverter.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.inverter.u[1, 1]", "[:#(type=Boolean)]", "drive.modulation.y[1, 1]", 1,\
 5, 163, 65)
DeclareAlias2("drive.inverter.u[1, 2]", "[:#(type=Boolean)]", "drive.modulation.y[1, 2]", 1,\
 5, 164, 65)
DeclareAlias2("drive.inverter.u[2, 1]", "[:#(type=Boolean)]", "drive.modulation.y[2, 1]", 1,\
 5, 165, 65)
DeclareAlias2("drive.inverter.u[2, 2]", "[:#(type=Boolean)]", "drive.modulation.y[2, 2]", 1,\
 5, 166, 65)
DeclareAlias2("drive.inverter.u[3, 1]", "[:#(type=Boolean)]", "drive.modulation.y[3, 1]", 1,\
 5, 167, 65)
DeclareAlias2("drive.inverter.u[3, 2]", "[:#(type=Boolean)]", "drive.modulation.y[3, 2]", 1,\
 5, 168, 65)
DeclareVariable("drive.inverter.plug.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.plug.pin[1].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.inverter.plug.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", -1, 5, 622, 132)
DeclareVariable("drive.inverter.plug.pin[2].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.inverter.plug.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", -1, 1, 0, 132)
DeclareVariable("drive.inverter.plug.pin[3].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.inverter.plug.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", -1, 1, 1, 132)
DeclareVariable("drive.inverter.currentSensorDC.p.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.currentSensorDC.p.i", "Current flowing into the pin [A]",\
 "drive.pin_p.i", 1, 5, 855, 132)
DeclareVariable("drive.inverter.currentSensorDC.n.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.currentSensorDC.n.i", "Current flowing into the pin [A]",\
 "drive.pin_p.i", -1, 5, 855, 132)
DeclareAlias2("drive.inverter.currentSensorDC.i", "Current in the branch from p to n as output signal [A]",\
 "drive.pin_p.i", 1, 5, 855, 0)
DeclareAlias2("drive.inverter.currentDC.u", "DC current of the inverter [A]", \
"drive.pin_p.i", 1, 5, 855, 0)
DeclareVariable("drive.inverter.currentSensorAC.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.currentSensorAC.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 132)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 132)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 132)
DeclareVariable("drive.inverter.currentSensorAC.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", -1, 5, 622, 132)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", -1, 1, 0, 132)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", -1, 1, 1, 132)
DeclareAlias2("drive.inverter.currentSensorAC.i[1]", "Current in the branch from p to n as output signal [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 0)
DeclareAlias2("drive.inverter.currentSensorAC.i[2]", "Current in the branch from p to n as output signal [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 0)
DeclareAlias2("drive.inverter.currentSensorAC.i[3]", "Current in the branch from p to n as output signal [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 0)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", -1,\
 5, 622, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].i", \
"Current in the branch from p to n as output signal [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 0)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", -1,\
 1, 0, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].i", \
"Current in the branch from p to n as output signal [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 0)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", -1,\
 1, 1, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].i", \
"Current in the branch from p to n as output signal [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 0)
DeclareVariable("drive.inverter.currentAC.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.inverter.currentAC.u[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 0)
DeclareAlias2("drive.inverter.currentAC.u[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 0)
DeclareAlias2("drive.inverter.currentAC.u[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 0)
DeclareVariable("drive.inverter.voltageSensorDC.p.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.voltageSensorDC.p.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.inverter.voltageSensorDC.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.voltageSensorDC.n.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.inverter.voltageSensorDC.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 60.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.voltageDC.u", "DC current of the inverter [V]", \
60.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.multiSensorMotor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.multiSensorMotor.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareAlias2("drive.multiSensorMotor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "drive.tau1", 1, 5, 858, 132)
DeclareAlias2("drive.multiSensorMotor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.multiSensorMotor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "drive.tau1", -1, 5, 858, 132)
DeclareVariable("drive.multiSensorMotor.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.multiSensorMotor.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareAlias2("drive.multiSensorMotor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.tau1", 1, 5, 858, 0)
DeclareVariable("drive.machine.data.m", "Number of phases [:#(type=Integer)]", 3,\
 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.data.Rt", "Terminal resistances [Ohm]", 0.0155, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.data.useL", "Internal inductance shall be used [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.data.useLt", "if true Lt is used in the main diagonal otherwise L on the main d. and M for the other elements [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.data.Lt", "Terminal inductance = 2*(L-M) [H]", \
4E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.L", "Stator self inductance [H]", 1E-15, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.M", "Stator mututal inductance [H]", 1E-15, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Ls_sigma", "Leakage inductance at the terminals [H]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.fluxSource", "Selection which variable shall be used to compute the Back-EMF [:#(type=BrushlessDCDrives.Common.Types.FluxSource)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("drive.machine.data.k_tau", "Torque constant [N.m/A]", 0.1342, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.k_speed", "Speed constant in rpm/V [rev.min-1/V]",\
 71, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Jr", "Rotor's moment of inertia [kg.m2]", \
1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Js", "Stator's moment of inertia (only has effect if stator not fixed (useSupport = false)) [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.I_0", "No load current, used to compute a linear friction element [A]",\
 9.8, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.data.w_0", "No load speed to compute a linear friction element [rad/s]",\
 3550, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.data.u_s_nom", "Nominal voltage [V]", 50, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.i_s_nom", "Nominal current [A]", 177.8, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.tau_nom", "Nominal torque [N.m]", 23.853, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.w_nom", "Nominal mechanical speed [rad/s]", \
352.3819759776551, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.P_nom", "Nominal mechanical power [W]", \
8405.367272995007, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.kDC", "Torque constant for BLDC Model [N.m/A]",\
 0.1342, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.b", "Damping coefficient from no-load current [N.m.s/rad]",\
 0.0003704676056338029, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Rs", "Resistance of a single stator winding [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Ls", "Overall stator winding inductance [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.maxEMF_constant", "Angle over which the Back-EMF is constant [rad|deg]",\
 2.0943951023931953, 1E-60,3.141592653589793,0.0,0,513)
DeclareVariable("drive.machine.data.maxEMF_start[1]", "Angle at which the respective phases (frist element = first phase etc.) have reached their postive maximum EMF [rad|deg]",\
 3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.maxEMF_start[2]", "Angle at which the respective phases (frist element = first phase etc.) have reached their postive maximum EMF [rad|deg]",\
 5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.maxEMF_start[3]", "Angle at which the respective phases (frist element = first phase etc.) have reached their postive maximum EMF [rad|deg]",\
 7.853981633974483, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.useSupport", "True: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.useThermalPort", "True: thermal connector is provided, false: temperature is fixed to 20degC internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive.machine.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.machine.flange.tau", "Cut torque in the flange [N.m]", \
"drive.tau1", 1, 5, 858, 132)
DeclareVariable("drive.machine.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.plug_p.pin[1].v", "Potential at the pin [V]", \
"drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.machine.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 132)
DeclareAlias2("drive.machine.plug_p.pin[2].v", "Potential at the pin [V]", \
"drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.machine.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 132)
DeclareAlias2("drive.machine.plug_p.pin[3].v", "Potential at the pin [V]", \
"drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.machine.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 132)
DeclareVariable("drive.machine.powerBalance.electricMachinePower", \
"Electrical power (stator) [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.innerMachinePower", "Mechanical power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.statorInertiaPower", \
"Stator inertia power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.powerBalance.rotorInertiaPower", "Rotor inertia power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.totalLossPower", "Total loss power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.statorWindingLossPower", \
"Stator copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.frictionLossPower", "Friction losses [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.angleSensor.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.angleSensor.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.machine.angleSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareVariable("drive.machine.angleSensor.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.angleSensor.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.angleSensor.support.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.angleSensor.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStart[1]", \
"Starting angles of the pulses [rad|deg]", 0.5235987755982988, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStart[2]", \
"Starting angles of the pulses [rad|deg]", 1.5707963267948966, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStart[3]", \
"Starting angles of the pulses [rad|deg]", 2.617993877991494, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseWidth", \
"Width of the TRUE pulse output by the Hall sensors [rad|deg]", 3.141592653589793,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEnd[1]", \
"Ending angle of the pulses [rad|deg]", 3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEnd[2]", \
"Ending angle of the pulses [rad|deg]", 4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEnd[3]", \
"Ending angle of the pulses [rad|deg]", 5.759586531581287, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStartLim[1]", \
"Start angle < 2*pi [rad|deg]", 0.5235987755982988, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStartLim[2]", \
"Start angle < 2*pi [rad|deg]", 1.5707963267948966, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStartLim[3]", \
"Start angle < 2*pi [rad|deg]", 2.617993877991494, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEndLim[1]", \
"End angle < 2*pi [rad|deg]", 3.665191429188092, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEndLim[2]", \
"End angle < 2*pi [rad|deg]", 4.71238898038469, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEndLim[3]", \
"End angle < 2*pi [rad|deg]", 5.759586531581287, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.electricAngle", \
"[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.angleSensor.coreElement.electricAngleLim", \
"[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.angleSensor.coreElement.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareVariable("drive.machine.angleSensor.coreElement.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.angleSensor.coreElement.y[1]", "[:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 81, 65)
DeclareAlias2("drive.machine.angleSensor.coreElement.y[2]", "[:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 82, 65)
DeclareAlias2("drive.machine.angleSensor.coreElement.y[3]", "[:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 83, 65)
DeclareVariable("drive.machine.angleSensor.coreElement.support.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.angleSensor.coreElement.support.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.m", \
"Number of phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.pulseStart[1]", \
"Starting angles of the pulses [rad|deg]", 0.5235987755982988, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.pulseStart[2]", \
"Starting angles of the pulses [rad|deg]", 1.5707963267948966, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.pulseStart[3]", \
"Starting angles of the pulses [rad|deg]", 2.617993877991494, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.pulseWidth", \
"Width of the TRUE pulse output by the Hall sensors [rad|deg]", 3.141592653589793,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.hallSensorOutput.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.u[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 65)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.u[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 65)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.u[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 65)
DeclareVariable("drive.machine.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.Rs", "Phase Resistances R_ref at 20degC [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Ls", "Overall inductance of the machine (self + leakage) [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.fluxSource", "Selection which variable shall be used to compute the Back-EMF [:#(type=BrushlessDCDrives.Common.Types.FluxSource)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.k_tau", "Torque constant [N.m/A]", \
0.1342, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.k_speed", "Speed constant in rpm/V [rev.min-1/V]",\
 71.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.Jr", "Rotor's moment of inertia [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Js", "Stator's moment of inertia (only has effect if stator not fixed (useSupport = false)) [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.b", "Damping coefficient [N.m.s/rad]",\
 0.0003704676056338029, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.useSupport", "False: Stator is fixed internally, false: it can rotate [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.coreElement.useThermalPort", "True: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.coreElement.maxEMF_constant", "Angle over which the Back-EMF is constant [rad|deg]",\
 2.0943951023931953, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.maxEMF_start[1]", "Angle at which the respective phases (frist element = first phase etc.) have reach their postive maximum EMF [rad|deg]",\
 3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.maxEMF_start[2]", "Angle at which the respective phases (frist element = first phase etc.) have reach their postive maximum EMF [rad|deg]",\
 5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.maxEMF_start[3]", "Angle at which the respective phases (frist element = first phase etc.) have reach their postive maximum EMF [rad|deg]",\
 7.853981633974483, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.w", "Rotors angular velocity [rad/s]", \
"drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareVariable("drive.machine.coreElement.v[1]", "Voltage at the motor [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.v[2]", "Voltage at the motor [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.v[3]", "Voltage at the motor [V]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.machine.coreElement.flange.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareAlias2("drive.machine.coreElement.flange.tau", "Cut torque in the flange [N.m]",\
 "drive.tau1", 1, 5, 858, 132)
DeclareVariable("drive.machine.coreElement.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 132)
DeclareVariable("drive.machine.coreElement.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.coreElement.plug_sn.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", -1, 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", -1, 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", -1, 1, 1, 132)
DeclareVariable("drive.machine.coreElement.resistor.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.resistor.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.resistor.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.resistor.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.resistor.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 0)
DeclareAlias2("drive.machine.coreElement.resistor.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 0)
DeclareAlias2("drive.machine.coreElement.resistor.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 0)
DeclareVariable("drive.machine.coreElement.resistor.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.resistor.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.machine.coreElement.resistor.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.resistor.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.machine.coreElement.resistor.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.resistor.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.machine.coreElement.resistor.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 132)
DeclareVariable("drive.machine.coreElement.resistor.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.coreElement.resistor.plug_n.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.resistor.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", -1,\
 5, 622, 132)
DeclareVariable("drive.machine.coreElement.resistor.plug_n.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.resistor.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", -1,\
 1, 0, 132)
DeclareVariable("drive.machine.coreElement.resistor.plug_n.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.resistor.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", -1,\
 1, 1, 132)
DeclareVariable("drive.machine.coreElement.resistor.R[1]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.R[2]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.R[3]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.T_ref[1]", "Reference temperatures [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.T_ref[2]", "Reference temperatures [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.T_ref[3]", "Reference temperatures [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.alpha[1]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.00397, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.alpha[2]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.00397, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.alpha[3]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.00397, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.resistor.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.resistor.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].R", \
"Resistance at temperature T_ref [Ohm]", 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].T_ref", \
"Reference temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.00397, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[1].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[1].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[1].n.v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[1].v", 1,\
 5, 565, 4)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[1].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", -1,\
 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[1].i", \
"Current flowing from pin p to pin n [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 0)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[1].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.00775, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].R", \
"Resistance at temperature T_ref [Ohm]", 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].T_ref", \
"Reference temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.00397, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[2].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[2].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[2].n.v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[2].v", 1,\
 5, 566, 4)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[2].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", -1,\
 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[2].i", \
"Current flowing from pin p to pin n [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 0)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[2].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.00775, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].R", \
"Resistance at temperature T_ref [Ohm]", 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].T_ref", \
"Reference temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.00397, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[3].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[3].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 132)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[3].n.v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[3].v", 1,\
 5, 567, 4)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[3].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", -1,\
 1, 1, 132)
DeclareAlias2("drive.machine.coreElement.resistor.resistor[3].i", \
"Current flowing from pin p to pin n [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 0)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.resistor.resistor[3].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.00775, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.overallInductance.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.overallInductance.v[1]", \
"Voltage drops of the two polyphase plugs [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.overallInductance.v[2]", \
"Voltage drops of the two polyphase plugs [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.overallInductance.v[3]", \
"Voltage drops of the two polyphase plugs [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.overallInductance.i[1]", \
"Currents flowing into positive polyphase plugs [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 0)
DeclareAlias2("drive.machine.coreElement.overallInductance.i[2]", \
"Currents flowing into positive polyphase plugs [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 0)
DeclareAlias2("drive.machine.coreElement.overallInductance.i[3]", \
"Currents flowing into positive polyphase plugs [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 0)
DeclareVariable("drive.machine.coreElement.overallInductance.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[1].v", 1,\
 5, 565, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[2].v", 1,\
 5, 566, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[3].v", 1,\
 5, 567, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 132)
DeclareVariable("drive.machine.coreElement.overallInductance.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.coreElement.overallInductance.plug_n.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", -1,\
 5, 622, 132)
DeclareVariable("drive.machine.coreElement.overallInductance.plug_n.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", -1,\
 1, 0, 132)
DeclareVariable("drive.machine.coreElement.overallInductance.plug_n.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.overallInductance.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", -1,\
 1, 1, 132)
DeclareVariable("drive.machine.coreElement.overallInductance.L[1]", \
"Inductance [H]", 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.overallInductance.L[2]", \
"Inductance [H]", 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.overallInductance.L[3]", \
"Inductance [H]", 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.overallInductance.inductor[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[1].p.v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[1].v", 1,\
 5, 565, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[1].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[1].n.v", \
"Potential at the pin [V]", "drive.machine.coreElement.overallInductance.plug_n.pin[1].v", 1,\
 5, 615, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[1].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", -1,\
 5, 622, 132)
DeclareVariable("drive.machine.coreElement.overallInductance.inductor[1].i", \
"Current flowing from pin p to pin n [A]", 0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.overallInductance.inductor[1].der(i)",\
 "der(Current flowing from pin p to pin n) [A/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.overallInductance.inductor[1].L", \
"Inductance [H]", 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.overallInductance.inductor[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[2].p.v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[2].v", 1,\
 5, 566, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[2].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[2].n.v", \
"Potential at the pin [V]", "drive.machine.coreElement.overallInductance.plug_n.pin[2].v", 1,\
 5, 616, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[2].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", -1,\
 1, 0, 132)
DeclareState("drive.machine.coreElement.overallInductance.inductor[2].i", \
"Current flowing from pin p to pin n [A]", 0, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.machine.coreElement.overallInductance.inductor[2].der(i)",\
 "der(Current flowing from pin p to pin n) [A/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.overallInductance.inductor[2].L", \
"Inductance [H]", 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.overallInductance.inductor[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[3].p.v", \
"Potential at the pin [V]", "drive.machine.coreElement.resistor.plug_n.pin[3].v", 1,\
 5, 567, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[3].p.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 132)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[3].n.v", \
"Potential at the pin [V]", "drive.machine.coreElement.overallInductance.plug_n.pin[3].v", 1,\
 5, 617, 4)
DeclareAlias2("drive.machine.coreElement.overallInductance.inductor[3].n.i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", -1,\
 1, 1, 132)
DeclareState("drive.machine.coreElement.overallInductance.inductor[3].i", \
"Current flowing from pin p to pin n [A]", 1, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.machine.coreElement.overallInductance.inductor[3].der(i)",\
 "der(Current flowing from pin p to pin n) [A/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.overallInductance.inductor[3].L", \
"Inductance [H]", 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.fluxSource", \
"Selection which variable shall be used to compute the Back-EMF [:#(type=BrushlessDCDrives.Common.Types.FluxSource)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.k_tau", \
"Torque constant [N.m/A]", 0.1342, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.k_speed", \
"Speed constant in rpm/V [rev.min-1/V]", 71.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.V_backEMF_max", \
"Maximum induced voltage (back-EMF) at 1 rad/s (electrical) in a single phase [V]",\
 0.03355, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.maxEMF_constant", \
"Angle over which the back-EMF is constant [rad|deg]", 2.0943951023931953, 1E-60,\
3.141592653589793,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.maxEMF_start[1]", \
"Angle at which the respective phases (frist element = first phase etc.) have reach their postive maximum EMF [rad|deg]",\
 3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.maxEMF_start[2]", \
"Angle at which the respective phases (frist element = first phase etc.) have reach their postive maximum EMF [rad|deg]",\
 5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.maxEMF_start[3]", \
"Angle at which the respective phases (frist element = first phase etc.) have reach their postive maximum EMF [rad|deg]",\
 7.853981633974483, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.changingEMF", \
"[rad|deg]", 1.0471975511965979, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.slopeEMF", "[rad/s]", \
1.9098593171027438, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.psi_max", \
"Absolute value of area/integral of backEMF from 0 to pi/2 [Wb]", \
0.052700216763968785, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.phi_rel", \
"relative angle between flange and support [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 0)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta", \
"Rotor Angle limited to 2*pi [rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.w_el", \
"Rotors electric angular velocity [rad/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.v[1]", \
"Voltage at the motor [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.v[2]", \
"Voltage at the motor [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.v[3]", \
"Voltage at the motor [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.i[1]", "Current in the motor [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 0)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.i[2]", "Current in the motor [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 0)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.i[3]", "Current in the motor [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 0)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.f[1]", \
"Function for the description of the back-EMF wave-form", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.f[2]", \
"Function for the description of the back-EMF wave-form", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.f[3]", \
"Function for the description of the back-EMF wave-form", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.backEMF[1]", \
"Derivative of the Back-EMF wrt. the angle (at 1 rad/s) [Wb]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.backEMF[2]", \
"Derivative of the Back-EMF wrt. the angle (at 1 rad/s) [Wb]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.backEMF[3]", \
"Derivative of the Back-EMF wrt. the angle (at 1 rad/s) [Wb]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.tau", "Electric torque generated in the machine [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 0)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta1[1]", \
"[rad|deg]", 3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta1[2]", \
"[rad|deg]", 5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta1[3]", \
"[rad|deg]", 1.5707963267948966, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta2[1]", \
"[rad|deg]", 5.759586531581287, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta2[2]", \
"[rad|deg]", 1.5707963267948966, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta2[3]", \
"[rad|deg]", 3.6651914291880914, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta3[1]", \
"[rad|deg]", 0.5235987755982983, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta3[2]", \
"[rad|deg]", 2.617993877991495, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta3[3]", \
"[rad|deg]", 4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta4[1]", \
"[rad|deg]", 2.617993877991493, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta4[2]", \
"[rad|deg]", 4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.theta4[3]", \
"[rad|deg]", 0.5235987755982983, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[1, 1, 1]", "[rad]",\
 3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[1, 1, 2]", "[rad]",\
 5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[1, 1, 3]", "[rad]",\
 1.5707963267948966, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[1, 2, 1]", "[rad]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[1, 2, 2]", "[rad]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[1, 2, 3]", "[rad]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[2, 1, 1]", "[rad]",\
 5.759586531581287, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[2, 1, 2]", "[rad]",\
 1.5707963267948966, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[2, 1, 3]", "[rad]",\
 3.6651914291880914, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[2, 2, 1]", "[rad]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[2, 2, 2]", "[rad]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[2, 2, 3]", "[rad]",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[3, 1, 1]", "[rad]",\
 0.5235987755982983, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[3, 1, 2]", "[rad]",\
 2.617993877991495, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[3, 1, 3]", "[rad]",\
 4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[3, 2, 1]", "[rad]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[3, 2, 2]", "[rad]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[3, 2, 3]", "[rad]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[4, 1, 1]", "[rad]",\
 2.617993877991493, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[4, 1, 2]", "[rad]",\
 4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[4, 1, 3]", "[rad]",\
 0.5235987755982983, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[4, 2, 1]", "[rad]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[4, 2, 2]", "[rad]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TM[4, 2, 3]", "[rad]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[1, 1, 1]", "", \
0.5235987755982983, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[1, 1, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[1, 2, 1]", "", \
2.617993877991493, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[1, 2, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[1, 3, 1]", "", \
3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[1, 3, 2]", "", 1.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[1, 4, 1]", "", \
5.759586531581287, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[1, 4, 2]", "", 1.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[2, 1, 1]", "", \
1.5707963267948966, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[2, 1, 2]", "", 1.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[2, 2, 1]", "", \
2.617993877991495, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[2, 2, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[2, 3, 1]", "", \
4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[2, 3, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[2, 4, 1]", "", \
5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[2, 4, 2]", "", 1.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[3, 1, 1]", "", \
0.5235987755982983, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[3, 1, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[3, 2, 1]", "", \
1.5707963267948966, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[3, 2, 2]", "", 1.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[3, 3, 1]", "", \
3.6651914291880914, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[3, 3, 2]", "", 1.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[3, 4, 1]", "", \
4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMS[3, 4, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE1[1, 1, 1]", "", \
-0.5235987755982996, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE1[1, 1, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE1[2, 1, 1]", "", \
0.5235987755982987, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE1[2, 1, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE1[3, 1, 1]", "", \
-0.5235987755982996, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE1[3, 1, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE6[1, 1, 1]", "", \
6.8067840827778845, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE6[1, 1, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE6[2, 1, 1]", "", \
6.806784082777886, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE6[2, 1, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE6[3, 1, 1]", "", \
5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE6[3, 1, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 1, 1]", "", \
-0.5235987755982996, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 1, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 2, 1]", "", \
0.5235987755982983, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 2, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 3, 1]", "", \
2.617993877991493, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 3, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 4, 1]", "", \
3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 4, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 5, 1]", "", \
5.759586531581287, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 5, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 6, 1]", "", \
6.8067840827778845, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[1, 6, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 1, 1]", "", \
0.5235987755982987, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 1, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 2, 1]", "", \
1.5707963267948966, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 2, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 3, 1]", "", \
2.617993877991495, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 3, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 4, 1]", "", \
4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 4, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 5, 1]", "", \
5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 5, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 6, 1]", "", \
6.806784082777886, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[2, 6, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 1, 1]", "", \
-0.5235987755982996, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 1, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 2, 1]", "", \
0.5235987755982983, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 2, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 3, 1]", "", \
1.5707963267948966, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 3, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 4, 1]", "", \
3.6651914291880914, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 4, 2]", "", \
1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 5, 1]", "", \
4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 5, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 6, 1]", "", \
5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.TMSE[3, 6, 2]", "", \
-1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.plug_sp.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sp.pin[1].v", \
"Potential at the pin [V]", "drive.machine.coreElement.overallInductance.plug_n.pin[1].v", 1,\
 5, 615, 4)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sp.pin[1].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sp.pin[2].v", \
"Potential at the pin [V]", "drive.machine.coreElement.overallInductance.plug_n.pin[2].v", 1,\
 5, 616, 4)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sp.pin[2].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sp.pin[3].v", \
"Potential at the pin [V]", "drive.machine.coreElement.overallInductance.plug_n.pin[3].v", 1,\
 5, 617, 4)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sp.pin[3].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 132)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.plug_sn.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sn.pin[1].v", \
"Potential at the pin [V]", "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558,\
 4)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sn.pin[1].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", -1,\
 5, 622, 132)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sn.pin[2].v", \
"Potential at the pin [V]", "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558,\
 4)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sn.pin[2].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", -1,\
 1, 0, 132)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sn.pin[3].v", \
"Potential at the pin [V]", "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558,\
 4)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.plug_sn.pin[3].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", -1,\
 1, 1, 132)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.flange.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.flange.tau", \
"Cut torque in the flange [N.m]", "drive.machine.coreElement.airgapTorque", -1, 5,\
 790, 132)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.support.phi", \
"Absolute rotation angle of flange [rad|deg]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.trapezoidalEMF.support.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.coreElement.trapezoidalEMF.support.tau", \
"Cut torque in the flange [N.m]", "drive.machine.coreElement.airgapTorque", 1, 5,\
 790, 132)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.flange_a.tau", \
"Cut torque in the flange [N.m]", "drive.machine.coreElement.airgapTorque", 1, 5,\
 790, 132)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareVariable("drive.machine.coreElement.inertiaRotor.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.inertiaRotor.J", "Moment of inertia [kg.m2]",\
 1E-15, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaRotor.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.phi", "Absolute rotation angle of component [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 0)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.der(phi)", \
"der(Absolute rotation angle of component) [rad/s]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 0)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "drive.machine.coreElement.damper.der(w_rel)", -1, 6, 3, 0)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "drive.machine.coreElement.damper.der(w_rel)", -1, 6, 3, 0)
DeclareState("drive.machine.coreElement.damper.phi_rel", "Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]",\
 2, 0, 0.0,0.0,0.0001,0,560)
DeclareDerivative("drive.machine.coreElement.damper.der(phi_rel)", \
"der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareState("drive.machine.coreElement.damper.w_rel", "Relative angular velocity (= der(phi_rel)) [rad/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.machine.coreElement.damper.der(w_rel)", \
"der(Relative angular velocity (= der(phi_rel))) [rad/s2]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.damper.a_rel", "Relative angular acceleration (= der(w_rel)) [rad/s2]",\
 "drive.machine.coreElement.damper.der(w_rel)", 1, 6, 3, 0)
DeclareVariable("drive.machine.coreElement.damper.tau", "Torque between flanges (= flange_b.tau) [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.damper.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.machine.coreElement.damper.flange_a.tau", "Cut torque in the flange [N.m]",\
 "drive.machine.coreElement.damper.tau", -1, 5, 768, 132)
DeclareVariable("drive.machine.coreElement.damper.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.coreElement.damper.flange_b.tau", "Cut torque in the flange [N.m]",\
 "drive.machine.coreElement.damper.tau", 1, 5, 768, 132)
DeclareVariable("drive.machine.coreElement.damper.phi_nominal", "Nominal value of phi_rel (used for scaling) [rad|rad]",\
 0.0001, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.damper.stateSelect", "Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]",\
 4, 1.0,5.0,0.0,0,1541)
DeclareVariable("drive.machine.coreElement.damper.d", "Damping constant [N.m.s/rad]",\
 0.0003704676056338029, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.damper.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("drive.machine.coreElement.damper.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 "drive.machine.powerBalance.frictionLossPower", 1, 5, 505, 0)
DeclareVariable("drive.machine.coreElement.inertiaStator.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.inertiaStator.flange_a.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.inertiaStator.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.inertiaStator.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.inertiaStator.J", "Moment of inertia [kg.m2]",\
 1E-15, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("drive.machine.coreElement.inertiaStator.phi", "Absolute rotation angle of component [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.der(phi)", \
"der(Absolute rotation angle of component) [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.der(w)", \
"der(Absolute angular velocity of component (= der(phi))) [rad/s2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.internalSupport.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalSupport.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,2825)
DeclareAlias2("drive.machine.coreElement.airGapSensor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.coreElement.airGapSensor.flange_a.tau", \
"Cut torque in the flange [N.m]", "drive.machine.coreElement.airgapTorque", 1, 5,\
 790, 132)
DeclareAlias2("drive.machine.coreElement.airGapSensor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.coreElement.airGapSensor.flange_b.tau", \
"Cut torque in the flange [N.m]", "drive.machine.coreElement.airgapTorque", -1, 5,\
 790, 132)
DeclareAlias2("drive.machine.coreElement.airGapSensor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 0)
DeclareVariable("drive.machine.coreElement.airgapTorque", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.innerTorque", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.innerTorqueComp.y", "Value of Real output [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 0)
DeclareVariable("drive.machine.terminalBox.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.terminalBox.terminalConnection", "Choose Y=star/D=delta [:#(type=BrushlessDCDrives.Common.Types.Terminal)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("drive.machine.terminalBox.isDelta", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.terminalBox.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", -1, 5, 622, 132)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", -1, 1, 0, 132)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", -1, 1, 1, 132)
DeclareVariable("drive.machine.terminalBox.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[1].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 132)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 132)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 132)
DeclareVariable("drive.machine.terminalBox.plugSupply.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 132)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 132)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 132)
DeclareAlias2("drive.machine.terminalBox.starpoint.v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareVariable("drive.machine.terminalBox.starpoint.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.terminalBox.star.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.terminalBox.star.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[1].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 132)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[2].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 132)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[3].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 132)
DeclareAlias2("drive.machine.terminalBox.star.pin_n.v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 558, 4)
DeclareVariable("drive.machine.terminalBox.star.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2569)
DeclareVariable("drive.machine.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.electricPowerSensor.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("drive.machine.electricPowerSensor.P", "[W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 0)
DeclareVariable("drive.machine.electricPowerSensor.Q", "[var]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("drive.machine.electricPowerSensor.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 132)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 132)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 132)
DeclareVariable("drive.machine.electricPowerSensor.plug_ni.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 451, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[1].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", -1,\
 5, 622, 132)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 452, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[2].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", -1,\
 1, 0, 132)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 453, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[3].i", \
"Current flowing into the pin [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", -1,\
 1, 1, 132)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[1].v", \
"Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[1].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[2].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[3].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.electricPowerSensor.v_[1]", "[V]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("drive.machine.electricPowerSensor.v_[2]", "[V]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("drive.machine.electricPowerSensor.i_[1]", "[A]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("drive.machine.electricPowerSensor.i_[2]", "[A]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("drive.machine.star.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.star.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.star.plug_p.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.star.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.star.plug_p.pin[2].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.star.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.star.plug_p.pin[3].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.star.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.star.pin_n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.star.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.ground.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.electricMachinePower.u", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 499, 0)
DeclareAlias2("drive.machine.innerTorque.u", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 0)
DeclareAlias2("drive.machine.airGapTorque.u", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 0)
DeclareAlias2("drive.machine.machineAngle.u", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 0)
DeclareAlias2("drive.machine.machineSpeed.u", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareAlias2("drive.machine.innerMachinePower.u", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 500, 0)
DeclareAlias2("drive.machine.innerPower.u1", "Connector of Real input signal 1 [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareAlias2("drive.machine.innerPower.u2", "Connector of Real input signal 2 [J/rad]",\
 "drive.machine.coreElement.innerTorque", -1, 5, 791, 0)
DeclareAlias2("drive.machine.innerPower.y", "Connector of Real output signal [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 500, 0)
DeclareVariable("drive.machine.signChange.k", "Gain value multiplied with input signal [1]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.signChange.u", "Input signal connector [N.m]", \
"drive.machine.coreElement.innerTorque", 1, 5, 791, 0)
DeclareAlias2("drive.machine.signChange.y", "Output signal connector [J]", \
"drive.machine.coreElement.innerTorque", -1, 5, 791, 0)
DeclareVariable("drive.machine.speedSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.speedSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.speedSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareVariable("drive.machine.speedSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.speedSensor.phi_rel", "Relative angle between two flanges (flange_b.phi - flange_a.phi) [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 0)
DeclareAlias2("drive.machine.speedSensor.der(phi_rel)", "der(Relative angle between two flanges (flange_b.phi - flange_a.phi)) [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareAlias2("drive.machine.speedSensor.w_rel", "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi)) as output signal [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareVariable("drive.machine.angleSensorIdeal.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.angleSensorIdeal.flange_a.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.angleSensorIdeal.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareVariable("drive.machine.angleSensorIdeal.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.angleSensorIdeal.phi_rel", "Relative angle between two flanges (= flange_b.phi - flange_a.phi) as output signal [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 0)
DeclareAlias2("drive.machine.torqueSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.machine.torqueSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "drive.tau1", -1, 5, 858, 132)
DeclareAlias2("drive.machine.torqueSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.machine.torqueSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "drive.tau1", 1, 5, 858, 132)
DeclareAlias2("drive.machine.torqueSensor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.tau1", -1, 5, 858, 0)
DeclareVariable("drive.ground.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("drive.ground.p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("drive.speedDependentTorque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("drive.speedDependentTorque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareVariable("drive.speedDependentTorque.flange.tau", "Cut torque in the flange [N.m]",\
 5.139, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.speedDependentTorque.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.speedDependentTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 -5.139, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
"drive.tau1", -1, 5, 858, 132)
DeclareAlias2("drive.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareVariable("drive.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
-5.139, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.inertia.J", "Moment of inertia [kg.m2]", 0.0629, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("drive.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 0)
DeclareAlias2("drive.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareAlias2("drive.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareAlias2("drive.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "drive.machine.coreElement.damper.der(w_rel)", -1, 6, 3, 0)
DeclareAlias2("drive.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "drive.machine.coreElement.damper.der(w_rel)", -1, 6, 3, 0)
DeclareAlias2("drive.multiSensorLoad.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.multiSensorLoad.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.multiSensorLoad.flange_a.tau", "Cut torque in the flange [N.m]",\
 5.139, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.multiSensorLoad.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareVariable("drive.multiSensorLoad.flange_b.tau", "Cut torque in the flange [N.m]",\
 -5.139, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.multiSensorLoad.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.multiSensorLoad.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareVariable("drive.multiSensorLoad.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 5.139, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.dutyCycleIn", "Ratio of on-time to period duration [1]", \
"firstOrder.y", 1, 1, 4, 0)
DeclareAlias2("drive.rotateCW_In", "[:#(type=Boolean)]", "drive.controller.coreElement.rotateCW", 1,\
 5, 80, 65)
DeclareVariable("drive.pin_p.v", "Potential at the pin [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.pin_p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("drive.pin_n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.pin_n.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", -1, 5, 855, 132)
DeclareVariable("drive.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 -5.139, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.w1", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 0)
DeclareVariable("drive.tau1", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("dutyCycle.height", "Height of step", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("dutyCycle.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,640)
DeclareVariable("dutyCycle.offset", "Offset of output signal y", 0.3, 0.0,0.0,\
0.0,0,513)
DeclareVariable("dutyCycle.startTime", "Output y = offset for time < startTime [s]",\
 5, 0.0,0.0,0.0,0,513)
DeclareVariable("constantVoltage.V", "Value of constant voltage [V]", 60, \
0.0,0.0,0.0,0,513)
DeclareVariable("constantVoltage.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 60, 0.0,0.0,0.0,0,513)
DeclareVariable("constantVoltage.p.v", "Potential at the pin [V]", 60.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("constantVoltage.p.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", -1, 5, 855, 132)
DeclareVariable("constantVoltage.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("constantVoltage.n.i", "Current flowing into the pin [A]", \
"drive.pin_p.i", 1, 5, 855, 132)
DeclareAlias2("constantVoltage.i", "Current flowing from pin p to pin n [A]", \
"drive.pin_p.i", -1, 5, 855, 0)
DeclareVariable("dutyCycle1.k", "Constant output value [N.m]", -5.139, 0.0,0.0,\
0.0,0,513)
DeclareVariable("dutyCycle1.y", "Connector of Real output signal [N.m]", -5.139,\
 0.0,0.0,0.0,0,513)
DeclareVariable("firstOrder.k", "Gain [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("firstOrder.T", "Time Constant [s]", 0.08, 0.0,0.0,0.0,0,513)
DeclareVariable("firstOrder.initType", "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("firstOrder.y_start", "Initial or guess value of output (= state) [1]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("firstOrder.u", "Connector of Real input signal", "dutyCycle.y", 1,\
 5, 860, 0)
DeclareState("firstOrder.y", "Connector of Real output signal [1]", 4, 0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("firstOrder.der(y)", "der(Connector of Real output signal) [s-1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("rotateCW1.startTime", "Time instant of step start [s]", 1000, \
0.0,0.0,0.0,0,513)
DeclareVariable("rotateCW1.startValue", "Output before startTime [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("rotateCW1.y", "Connector of Boolean output signal [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,642)
DeclareVariable("dutyCycle2.height", "Height of step", 0.5, 0.0,0.0,0.0,0,513)
DeclareVariable("dutyCycle2.y", "Connector of Real output signal", 0.0, 0.0,0.0,\
0.0,0,640)
DeclareVariable("dutyCycle2.offset", "Offset of output signal y", 0.3, 0.0,0.0,\
0.0,0,513)
DeclareVariable("dutyCycle2.startTime", "Output y = offset for time < startTime [s]",\
 5, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.controller.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive_45_Outputs.controller.useDirectionInput", \
"[:#(type=Boolean)]", true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive_45_Outputs.controller.rotateCW", "[:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive_45_Outputs.controller.rotateCW_In", "[:#(type=Boolean)]", \
"rotateCW1.y", 1, 5, 875, 65)
DeclareAlias2("drive_45_Outputs.controller.dutyCycleOut", "Connector of Real output signal [1]",\
 "firstOrder1.y", 1, 1, 8, 0)
DeclareAlias2("drive_45_Outputs.controller.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "firstOrder1.y", 1, 1, 8, 0)
DeclareAlias2("drive_45_Outputs.controller.rotateCW_Out", "[:#(type=Boolean)]", \
"rotateCW1.y", 1, 5, 875, 65)
DeclareVariable("drive_45_Outputs.modulation.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive_45_Outputs.modulation.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "firstOrder1.y", 1, 1, 8, 0)
DeclareAlias2("drive_45_Outputs.modulation.dutyCycleOut", "Connector of Real output signal [1]",\
 "firstOrder1.y", 1, 1, 8, 0)
DeclareAlias2("drive_45_Outputs.modulation.rotateCW_In", "[:#(type=Boolean)]", \
"rotateCW1.y", 1, 5, 875, 65)
DeclareAlias2("drive_45_Outputs.modulation.rotateCW", "[:#(type=Boolean)]", \
"rotateCW1.y", 1, 5, 875, 65)
DeclareVariable("drive_45_Outputs.inverter.pin_p.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.pin_p.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.pin_p.i", 1, 5, 1056, 132)
DeclareVariable("drive_45_Outputs.inverter.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.pin_n.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.pin_p.i", -1, 5, 1056, 132)
DeclareVariable("drive_45_Outputs.inverter.data.bidirectional", "Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive_45_Outputs.inverter.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "firstOrder1.y", 1, 1, 8, 0)
DeclareVariable("drive_45_Outputs.inverter.pin_p_Out.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive_45_Outputs.inverter.pin_p_Out.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", -1, 1, 7, 132)
DeclareVariable("drive_45_Outputs.inverter.pin_n_Out.v", "Potential at the pin [V]",\
 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.pin_n_Out.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 132)
DeclareVariable("drive_45_Outputs.inverter.coreElement.bidirectional", \
"Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.u", \
"Connector of Real input signal [1]", "firstOrder1.y", 1, 1, 8, 0)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.u1", \
"Lower boundary of input u, switching from constant value y1 to linear interpolation",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.u2", \
"Upper boundary of input u, switching from linear interpolation to constant value y2",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.y1", \
"Minimum value for y", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.y2", \
"Maximum value for y", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.k", \
"Slope of the resulting line equation [1]", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.y0", \
"Offset of the resulting line equation", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.gradient.k",\
 "Gain value multiplied with input signal [1]", 1.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.gradient.u",\
 "Input signal connector [1]", "firstOrder1.y", 1, 1, 8, 0)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.gradient.y",\
 "Output signal connector [1]", "firstOrder1.y", 1, 1, 8, 0)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.add.u1",\
 "Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.add.u2",\
 "Connector of Real input signal 2 [1]", "firstOrder1.y", 1, 1, 8, 0)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.add.y", \
"Connector of Real output signal", "firstOrder1.y", 1, 1, 8, 0)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.add.k1",\
 "Gain of input signal 1", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.add.k2",\
 "Gain of input signal 2", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.offset.k",\
 "Constant output value", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.offset.y",\
 "Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.limiter.uMax",\
 "Upper limits of input signals", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.limiter.uMin",\
 "Lower limits of input signals", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.limiter.strict",\
 "= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.limiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.limiter.u",\
 "Connector of Real input signal", "firstOrder1.y", 1, 1, 8, 0)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.limiter.y",\
 "Connector of Real output signal", "drive_45_Outputs.inverter.coreElement.uniOrBidirectional.y", 1,\
 5, 890, 0)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.uniOrBidirectional.limiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization", "firstOrder1.y", 1, 1,\
 8, 1024)
DeclareVariable("drive_45_Outputs.inverter.coreElement.idealBuckConverter.v1", \
"Voltage drop of port 1 (= p1.v - n1.v) [V]", 60.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.idealBuckConverter.v2", \
"Voltage drop of port 2 (= p2.v - n2.v) [V]", "drive_45_Outputs.inverter.pin_p_Out.v", 1,\
 5, 887, 0)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.idealBuckConverter.i1", \
"Current flowing from pos. to neg. pin of port 1 [A]", "drive_45_Outputs.pin_p.i", 1,\
 5, 1056, 0)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.idealBuckConverter.i2", \
"Current flowing from pos. to neg. pin of port 2 [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", -1,\
 1, 7, 0)
DeclareVariable("drive_45_Outputs.inverter.coreElement.idealBuckConverter.p1.v",\
 "Potential at the pin [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.idealBuckConverter.p1.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 132)
DeclareVariable("drive_45_Outputs.inverter.coreElement.idealBuckConverter.n1.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.idealBuckConverter.n1.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.pin_p.i", -1, 5, 1056, 132)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.idealBuckConverter.p2.v", \
"Potential at the pin [V]", "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.idealBuckConverter.p2.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", -1,\
 1, 7, 132)
DeclareVariable("drive_45_Outputs.inverter.coreElement.idealBuckConverter.n2.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.idealBuckConverter.n2.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", 1,\
 1, 7, 132)
DeclareVariable("drive_45_Outputs.inverter.coreElement.idealBuckConverter.dutyCycle",\
 "[1]", 0.0, 0.0,1.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.dutyCycle", "[1]", \
"firstOrder1.y", 1, 1, 8, 0)
DeclareVariable("drive_45_Outputs.inverter.coreElement.pin_p_supply.v", \
"Potential at the pin [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.pin_p_supply.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 132)
DeclareVariable("drive_45_Outputs.inverter.coreElement.pin_n_supply.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.pin_n_supply.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.pin_p.i", -1, 5, 1056, 132)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.pin_p.v", "Potential at the pin [V]",\
 "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.pin_p.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", -1, 1, 7, 132)
DeclareVariable("drive_45_Outputs.inverter.coreElement.pin_n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.pin_n.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 132)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.rotateCW", "[:#(type=Boolean)]",\
 "rotateCW1.y", 1, 5, 875, 65)
DeclareVariable("drive_45_Outputs.inverter.coreElement.signChanger.y", \
"Value of Real output", 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.product.u1", \
"Connector of Real input signal 1", "drive_45_Outputs.inverter.coreElement.uniOrBidirectional.y", 1,\
 5, 890, 0)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.product.u2", \
"Connector of Real input signal 2", "drive_45_Outputs.inverter.coreElement.signChanger.y", 1,\
 5, 915, 0)
DeclareAlias2("drive_45_Outputs.inverter.coreElement.product.y", \
"Connector of Real output signal [1]", "drive_45_Outputs.inverter.coreElement.idealBuckConverter.dutyCycle", 1,\
 5, 911, 0)
DeclareAlias2("drive_45_Outputs.inverter.rotateCW", "[:#(type=Boolean)]", \
"rotateCW1.y", 1, 5, 875, 65)
DeclareVariable("drive_45_Outputs.inverter.ground.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.inverter.ground.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.inverter.currentSensorDC.p.v", \
"Potential at the pin [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.currentSensorDC.p.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.pin_p.i", 1, 5, 1056, 132)
DeclareVariable("drive_45_Outputs.inverter.currentSensorDC.n.v", \
"Potential at the pin [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.currentSensorDC.n.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.pin_p.i", -1, 5, 1056, 132)
DeclareAlias2("drive_45_Outputs.inverter.currentSensorDC.i", "Current in the branch from p to n as output signal [A]",\
 "drive_45_Outputs.pin_p.i", 1, 5, 1056, 0)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.u", "DC current of the inverter [A]",\
 "drive_45_Outputs.pin_p.i", 1, 5, 1056, 0)
DeclareAlias2("drive_45_Outputs.inverter.currentSensorAC.p.v", "Potential at the pin [V]",\
 "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentSensorAC.p.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 132)
DeclareAlias2("drive_45_Outputs.inverter.currentSensorAC.n.v", "Potential at the pin [V]",\
 "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentSensorAC.n.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", -1, 1, 7, 132)
DeclareAlias2("drive_45_Outputs.inverter.currentSensorAC.i", "Current in the branch from p to n as output signal [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 0)
DeclareVariable("drive_45_Outputs.inverter.currentAC_Averaged.u", \
"DC current of the inverter [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.inverter.voltageChanger.y", "Value of Real output [1]",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("drive_45_Outputs.inverter.product.u1", "Connector of Real input signal 1 [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 0)
DeclareAlias2("drive_45_Outputs.inverter.product.u2", "Connector of Real input signal 2 [1]",\
 "drive_45_Outputs.inverter.voltageChanger.y", 1, 5, 921, 0)
DeclareAlias2("drive_45_Outputs.inverter.product.y", "Connector of Real output signal [A]",\
 "drive_45_Outputs.inverter.currentAC_Averaged.u", 1, 5, 920, 0)
DeclareVariable("drive_45_Outputs.inverter.voltageSensorDC.p.v", \
"Potential at the pin [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.inverter.voltageSensorDC.p.i", \
"Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.inverter.voltageSensorDC.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.inverter.voltageSensorDC.n.i", \
"Current flowing into the pin [A]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.inverter.voltageSensorDC.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 60.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.inverter.voltageDC.u", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.multiSensorMotor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.multiSensorMotor.flange_a.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareAlias2("drive_45_Outputs.multiSensorMotor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "drive_45_Outputs.tau1", 1, 5, 1059, 132)
DeclareAlias2("drive_45_Outputs.multiSensorMotor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.multiSensorMotor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "drive_45_Outputs.tau1", -1, 5, 1059, 132)
DeclareVariable("drive_45_Outputs.multiSensorMotor.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.multiSensorMotor.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareAlias2("drive_45_Outputs.multiSensorMotor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive_45_Outputs.tau1", 1, 5, 1059, 0)
DeclareVariable("drive_45_Outputs.machine.data.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive_45_Outputs.machine.data.Rt", "Terminal resistances [Ohm]",\
 0.0155, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("drive_45_Outputs.machine.data.useL", "Internal inductance shall be used [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive_45_Outputs.machine.data.useLt", "if true Lt is used in the main diagonal otherwise L on the main d. and M for the other elements [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive_45_Outputs.machine.data.Lt", "Terminal inductance = 2*(L-M) [H]",\
 4E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.L", "Stator self inductance [H]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.M", "Stator mututal inductance [H]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.Ls_sigma", "Leakage inductance at the terminals [H]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.fluxSource", "Selection which variable shall be used to compute the Back-EMF [:#(type=BrushlessDCDrives.Common.Types.FluxSource)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("drive_45_Outputs.machine.data.k_tau", "Torque constant [N.m/A]",\
 0.1342, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.k_speed", "Speed constant in rpm/V [rev.min-1/V]",\
 71, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.Jr", "Rotor's moment of inertia [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.Js", "Stator's moment of inertia (only has effect if stator not fixed (useSupport = false)) [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.I_0", "No load current, used to compute a linear friction element [A]",\
 9.8, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.w_0", "No load speed to compute a linear friction element [rad/s]",\
 3550, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.u_s_nom", "Nominal voltage [V]", 50,\
 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.i_s_nom", "Nominal current [A]", \
177.8, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.tau_nom", "Nominal torque [N.m]",\
 23.853, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.w_nom", "Nominal mechanical speed [rad/s]",\
 352.3819759776551, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.P_nom", "Nominal mechanical power [W]",\
 8405.367272995007, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.kDC", "Torque constant for BLDC Model [N.m/A]",\
 0.1342, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.b", "Damping coefficient from no-load current [N.m.s/rad]",\
 0.0003704676056338029, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.Rs", "Resistance of a single stator winding [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.Ls", "Overall stator winding inductance [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.maxEMF_constant", \
"Angle over which the Back-EMF is constant [rad|deg]", 2.0943951023931953, 1E-60,\
3.141592653589793,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.maxEMF_start[1]", \
"Angle at which the respective phases (frist element = first phase etc.) have reached their postive maximum EMF [rad|deg]",\
 3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.maxEMF_start[2]", \
"Angle at which the respective phases (frist element = first phase etc.) have reached their postive maximum EMF [rad|deg]",\
 5.759586531581288, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.data.maxEMF_start[3]", \
"Angle at which the respective phases (frist element = first phase etc.) have reached their postive maximum EMF [rad|deg]",\
 7.853981633974483, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.useSupport", "True: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive_45_Outputs.machine.useThermalPort", "True: thermal connector is provided, false: temperature is fixed to 20degC internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive_45_Outputs.machine.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.flange.tau", "Cut torque in the flange [N.m]",\
 "drive_45_Outputs.tau1", 1, 5, 1059, 132)
DeclareAlias2("drive_45_Outputs.machine.pin_p.v", "Potential at the pin [V]", \
"drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.machine.pin_p.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 132)
DeclareVariable("drive_45_Outputs.machine.pin_n.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.pin_n.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", -1, 1, 7, 132)
DeclareVariable("drive_45_Outputs.machine.powerBalance.electricMachinePower", \
"Electrical power (stator) [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.machine.powerBalance.innerMachinePower", \
"Mechanical power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.machine.powerBalance.statorInertiaPower", \
"Stator inertia power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.powerBalance.rotorInertiaPower", \
"Rotor inertia power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.machine.powerBalance.totalLossPower", \
"Total loss power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.machine.powerBalance.statorWindingLossPower", \
"Stator copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.machine.powerBalance.frictionLossPower", \
"Friction losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.machine.coreElement.R", "Phase Resistances R_ref at 20degC [Ohm]",\
 0.0155, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.useL", "Activate the internal inductance (electric dynamics) [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive_45_Outputs.machine.coreElement.L", "Self inductance [H]",\
 4E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.Jr", "Rotor's moment of inertia [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.Js", "Stator's moment of inertia (only has effect if stator not fixed (useSupport = false)) [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.b", "Damping coefficient [N.m.s/rad]",\
 0.0003704676056338029, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.useSupport", \
"False: Stator is fixed internally, false: it can rotate [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive_45_Outputs.machine.coreElement.useThermalPort", \
"True: thermal connector is provided, false: temperature is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive_45_Outputs.machine.coreElement.k", "Transformation coefficient [N.m/A]",\
 0.1342, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.machine.coreElement.w", "Rotors angular velocity [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.v", "Voltage at the motor [V]",\
 "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.flange.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.flange.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.tau1", 1, 5, 1059, 132)
DeclareAlias2("drive_45_Outputs.machine.coreElement.pin_p.v", "Potential at the pin [V]",\
 "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.pin_p.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 132)
DeclareVariable("drive_45_Outputs.machine.coreElement.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.coreElement.pin_n.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", -1, 1, 7, 132)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.R", \
"Resistance at temperature T_ref [Ohm]", 0.0155, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.T_ref", \
"Reference temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.00397, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.machine.coreElement.resistor.p.v", \
"Potential at the pin [V]", "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.resistor.p.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", 1,\
 1, 7, 132)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive_45_Outputs.machine.coreElement.resistor.n.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", -1,\
 1, 7, 132)
DeclareAlias2("drive_45_Outputs.machine.coreElement.resistor.i", \
"Current flowing from pin p to pin n [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", 1,\
 1, 7, 0)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareAlias2("drive_45_Outputs.machine.coreElement.resistor.LossPower", \
"Loss power leaving component via heatPort [W]", "drive_45_Outputs.machine.powerBalance.statorWindingLossPower", 1,\
 5, 966, 0)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.T_heatPort", \
"Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.resistor.R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.0155, 0.0,0.0,\
0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.backEMF.useSupport", \
"= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive_45_Outputs.machine.coreElement.backEMF.k", \
"Transformation coefficient [N.m/A]", 0.1342, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.backEMF.v", \
"Voltage drop between the two pins [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.i", "Current flowing from positive to negative pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.phi", \
"Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.der(phi)", \
"der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.w", "Angular velocity of flange relative to support [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.tau", \
"Torque of flange [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", -1,\
 5, 1018, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.tauElectrical", \
"Electrical torque [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.p.v", \
"Potential at the pin [V]", "drive_45_Outputs.machine.coreElement.backEMF.v", 1,\
 5, 989, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.p.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", 1,\
 1, 7, 132)
DeclareVariable("drive_45_Outputs.machine.coreElement.backEMF.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.n.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", -1,\
 1, 7, 132)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.flange.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", -1,\
 5, 1018, 132)
DeclareVariable("drive_45_Outputs.machine.coreElement.backEMF.support.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.support.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 132)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.internalSupport.tau",\
 "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "drive_45_Outputs.machine.coreElement.airgapTorque", 1, 5, 1018, 1024)
DeclareVariable("drive_45_Outputs.machine.coreElement.backEMF.internalSupport.phi",\
 "External support angle (= flange.phi) [rad|deg]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive_45_Outputs.machine.coreElement.backEMF.internalSupport.flange.phi",\
 "Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,2569)
DeclareAlias2("drive_45_Outputs.machine.coreElement.backEMF.internalSupport.flange.tau",\
 "Cut torque in the flange [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 1156)
DeclareAlias2("drive_45_Outputs.machine.coreElement.inertiaRotor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.inertiaRotor.flange_a.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 132)
DeclareAlias2("drive_45_Outputs.machine.coreElement.inertiaRotor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaRotor.flange_b.tau",\
 "Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaRotor.J", \
"Moment of inertia [kg.m2]", 1E-15, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaRotor.stateSelect",\
 "Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("drive_45_Outputs.machine.coreElement.inertiaRotor.phi", \
"Absolute rotation angle of component [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.inertiaRotor.der(phi)", \
"der(Absolute rotation angle of component) [rad/s]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.inertiaRotor.w", \
"Absolute angular velocity of component (= der(phi)) [rad/s]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.inertiaRotor.der(w)", \
"der(Absolute angular velocity of component (= der(phi))) [rad/s2]", \
"drive_45_Outputs.machine.coreElement.damper.der(w_rel)", -1, 6, 6, 0)
DeclareAlias2("drive_45_Outputs.machine.coreElement.inertiaRotor.a", \
"Absolute angular acceleration of component (= der(w)) [rad/s2]", \
"drive_45_Outputs.machine.coreElement.damper.der(w_rel)", -1, 6, 6, 0)
DeclareState("drive_45_Outputs.machine.coreElement.damper.phi_rel", \
"Relative rotation angle (= flange_b.phi - flange_a.phi) [rad|deg]", 5, 0, \
0.0,0.0,0.0001,0,544)
DeclareDerivative("drive_45_Outputs.machine.coreElement.damper.der(phi_rel)", \
"der(Relative rotation angle (= flange_b.phi - flange_a.phi)) [rad/s]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareState("drive_45_Outputs.machine.coreElement.damper.w_rel", \
"Relative angular velocity (= der(phi_rel)) [rad/s]", 6, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive_45_Outputs.machine.coreElement.damper.der(w_rel)", \
"der(Relative angular velocity (= der(phi_rel))) [rad/s2]", 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.machine.coreElement.damper.a_rel", \
"Relative angular acceleration (= der(w_rel)) [rad/s2]", "drive_45_Outputs.machine.coreElement.damper.der(w_rel)", 1,\
 6, 6, 0)
DeclareVariable("drive_45_Outputs.machine.coreElement.damper.tau", \
"Torque between flanges (= flange_b.tau) [N.m]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.machine.coreElement.damper.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.damper.flange_a.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.machine.coreElement.damper.tau", -1,\
 5, 997, 132)
DeclareVariable("drive_45_Outputs.machine.coreElement.damper.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.coreElement.damper.flange_b.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.machine.coreElement.damper.tau", 1,\
 5, 997, 132)
DeclareVariable("drive_45_Outputs.machine.coreElement.damper.phi_nominal", \
"Nominal value of phi_rel (used for scaling) [rad|rad]", 0.0001, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.damper.stateSelect", \
"Priority to use phi_rel and w_rel as states [:#(type=StateSelect)]", 4, 1.0,5.0,\
0.0,0,1541)
DeclareVariable("drive_45_Outputs.machine.coreElement.damper.d", \
"Damping constant [N.m.s/rad]", 0.0003704676056338029, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.damper.useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("drive_45_Outputs.machine.coreElement.damper.lossPower", \
"Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 "drive_45_Outputs.machine.powerBalance.frictionLossPower", 1, 5, 967, 0)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.flange_a.phi",\
 "Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.flange_a.tau",\
 "Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.flange_b.phi",\
 "Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.flange_b.tau",\
 "Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.J", \
"Moment of inertia [kg.m2]", 1E-15, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.stateSelect",\
 "Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.phi", \
"Absolute rotation angle of component [rad|deg]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.der(phi)", \
"der(Absolute rotation angle of component) [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.w", \
"Absolute angular velocity of component (= der(phi)) [rad/s]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.der(w)", \
"der(Absolute angular velocity of component (= der(phi))) [rad/s2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.inertiaStator.a", \
"Absolute angular acceleration of component (= der(w)) [rad/s2]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.fixed.phi0", \
"Fixed offset angle of housing [rad|deg]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.fixed.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.machine.coreElement.fixed.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive_45_Outputs.machine.coreElement.innerTorque", \
"Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.machine.coreElement.airGapSensor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.airGapSensor.flange_a.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 132)
DeclareAlias2("drive_45_Outputs.machine.coreElement.airGapSensor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.airGapSensor.flange_b.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", -1,\
 5, 1018, 132)
DeclareAlias2("drive_45_Outputs.machine.coreElement.airGapSensor.tau", \
"Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive_45_Outputs.machine.coreElement.airgapTorque", 1, 5, 1018, 0)
DeclareVariable("drive_45_Outputs.machine.coreElement.airgapTorque", \
"Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.machine.coreElement.innerTorqueComp.y", \
"Value of Real output [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 0)
DeclareVariable("drive_45_Outputs.machine.coreElement.overallInductance.v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.machine.coreElement.overallInductance.p.v", \
"Potential at the pin [V]", "drive_45_Outputs.machine.coreElement.resistor.n.v", 1,\
 5, 982, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.overallInductance.p.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", 1,\
 1, 7, 132)
DeclareAlias2("drive_45_Outputs.machine.coreElement.overallInductance.n.v", \
"Potential at the pin [V]", "drive_45_Outputs.machine.coreElement.backEMF.v", 1,\
 5, 989, 4)
DeclareAlias2("drive_45_Outputs.machine.coreElement.overallInductance.n.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", -1,\
 1, 7, 132)
DeclareState("drive_45_Outputs.machine.coreElement.overallInductance.i", \
"Current flowing from pin p to pin n [A]", 7, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive_45_Outputs.machine.coreElement.overallInductance.der(i)",\
 "der(Current flowing from pin p to pin n) [A/s]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive_45_Outputs.machine.coreElement.overallInductance.L", \
"Inductance [H]", 4E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.coreElement.internalSupport.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,2569)
DeclareVariable("drive_45_Outputs.machine.coreElement.internalSupport.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,2825)
DeclareAlias2("drive_45_Outputs.machine.torqueSensor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.torqueSensor.flange_a.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.tau1", -1, 5, 1059, 132)
DeclareAlias2("drive_45_Outputs.machine.torqueSensor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.torqueSensor.flange_b.tau", \
"Cut torque in the flange [N.m]", "drive_45_Outputs.tau1", 1, 5, 1059, 132)
DeclareAlias2("drive_45_Outputs.machine.torqueSensor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive_45_Outputs.tau1", -1, 5, 1059, 0)
DeclareVariable("drive_45_Outputs.machine.signChange.k", "Gain value multiplied with input signal [1]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.machine.signChange.u", "Input signal connector [N.m]",\
 "drive_45_Outputs.machine.coreElement.innerTorque", 1, 5, 1017, 0)
DeclareAlias2("drive_45_Outputs.machine.signChange.y", "Output signal connector [J]",\
 "drive_45_Outputs.machine.coreElement.innerTorque", -1, 5, 1017, 0)
DeclareAlias2("drive_45_Outputs.machine.innerPower.u1", "Connector of Real input signal 1 [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareAlias2("drive_45_Outputs.machine.innerPower.u2", "Connector of Real input signal 2 [J/rad]",\
 "drive_45_Outputs.machine.coreElement.innerTorque", -1, 5, 1017, 0)
DeclareAlias2("drive_45_Outputs.machine.innerPower.y", "Connector of Real output signal [W]",\
 "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1, 5, 962, 0)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.u", "Ratio of on-time to period duration [W]",\
 "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1, 5, 962, 0)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.u", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 0)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.pc.v", "Potential at the pin [V]",\
 "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.pc.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 132)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.nc.v", "Potential at the pin [V]",\
 "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.nc.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", -1, 1, 7, 132)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.pv.v", "Potential at the pin [V]",\
 "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareVariable("drive_45_Outputs.machine.powerSensor.pv.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.machine.powerSensor.nv.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.machine.powerSensor.nv.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.power", "Instantaneous power as output signal [W]",\
 "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1, 5, 961, 0)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.voltageSensor.p.v", \
"Potential at the pin [V]", "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareVariable("drive_45_Outputs.machine.powerSensor.voltageSensor.p.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.machine.powerSensor.voltageSensor.n.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.machine.powerSensor.voltageSensor.n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.voltageSensor.v", \
"Voltage between pin p and n (= p.v - n.v) as output signal [V]", \
"drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 0)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.currentSensor.p.v", \
"Potential at the pin [V]", "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.currentSensor.p.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", 1,\
 1, 7, 132)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.currentSensor.n.v", \
"Potential at the pin [V]", "drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.currentSensor.n.i", \
"Current flowing into the pin [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", -1,\
 1, 7, 132)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.currentSensor.i", \
"Current in the branch from p to n as output signal [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", 1,\
 1, 7, 0)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.product.u1", \
"Connector of Real input signal 1 [V]", "drive_45_Outputs.inverter.pin_p_Out.v", 1,\
 5, 887, 0)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.product.u2", \
"Connector of Real input signal 2 [A]", "drive_45_Outputs.machine.coreElement.overallInductance.i", 1,\
 1, 7, 0)
DeclareAlias2("drive_45_Outputs.machine.powerSensor.product.y", "Connector of Real output signal [W]",\
 "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1, 5, 961, 0)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.u", "Ratio of on-time to period duration [N.m]",\
 "drive_45_Outputs.machine.coreElement.innerTorque", 1, 5, 1017, 0)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.u", "Ratio of on-time to period duration [N.m]",\
 "drive_45_Outputs.machine.coreElement.airgapTorque", 1, 5, 1018, 0)
DeclareVariable("drive_45_Outputs.machine.angleSensorIdeal.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.machine.angleSensorIdeal.flange_a.tau", \
"Cut torque in the flange [N.m]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive_45_Outputs.machine.angleSensorIdeal.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareVariable("drive_45_Outputs.machine.angleSensorIdeal.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive_45_Outputs.machine.angleSensorIdeal.phi_rel", \
"Relative angle between two flanges (= flange_b.phi - flange_a.phi) as output signal [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 0)
DeclareVariable("drive_45_Outputs.machine.speedSensor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.machine.speedSensor.flange_a.tau", \
"Cut torque in the flange [N.m]", 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive_45_Outputs.machine.speedSensor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareVariable("drive_45_Outputs.machine.speedSensor.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive_45_Outputs.machine.speedSensor.phi_rel", "Relative angle between two flanges (flange_b.phi - flange_a.phi) [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 0)
DeclareAlias2("drive_45_Outputs.machine.speedSensor.der(phi_rel)", \
"der(Relative angle between two flanges (flange_b.phi - flange_a.phi)) [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareAlias2("drive_45_Outputs.machine.speedSensor.w_rel", "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi)) as output signal [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareVariable("drive_45_Outputs.machine.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive_45_Outputs.machine.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.machine.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.u", "Ratio of on-time to period duration [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 0)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.u", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareVariable("drive_45_Outputs.machine.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2569)
DeclareVariable("drive_45_Outputs.machine.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("drive_45_Outputs.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.ground.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.speedDependentTorque.useSupport", \
"= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("drive_45_Outputs.speedDependentTorque.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareVariable("drive_45_Outputs.speedDependentTorque.flange.tau", \
"Cut torque in the flange [N.m]", 5.139, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.speedDependentTorque.phi_support", \
"Absolute angle of support flange [rad|deg]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive_45_Outputs.speedDependentTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 -5.139, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.inertia.flange_a.tau", "Cut torque in the flange [N.m]",\
 "drive_45_Outputs.tau1", -1, 5, 1059, 132)
DeclareAlias2("drive_45_Outputs.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
DeclareVariable("drive_45_Outputs.inertia.flange_b.tau", "Cut torque in the flange [N.m]",\
 -5.139, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.inertia.J", "Moment of inertia [kg.m2]", \
0.0629, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive_45_Outputs.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("drive_45_Outputs.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 0, 0.0,0.0,0.0001,0,528)
DeclareAlias2("drive_45_Outputs.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareAlias2("drive_45_Outputs.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareAlias2("drive_45_Outputs.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "drive_45_Outputs.machine.coreElement.damper.der(w_rel)", -1, 6, 6, 0)
DeclareAlias2("drive_45_Outputs.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "drive_45_Outputs.machine.coreElement.damper.der(w_rel)", -1, 6, 6, 0)
DeclareAlias2("drive_45_Outputs.multiSensorLoad.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.multiSensorLoad.flange_a.der(phi)", \
"der(Absolute rotation angle of flange) [rad/s]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.multiSensorLoad.flange_a.tau", \
"Cut torque in the flange [N.m]", 5.139, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive_45_Outputs.multiSensorLoad.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
DeclareVariable("drive_45_Outputs.multiSensorLoad.flange_b.tau", \
"Cut torque in the flange [N.m]", -5.139, 0.0,0.0,0.0,0,777)
DeclareVariable("drive_45_Outputs.multiSensorLoad.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.multiSensorLoad.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareVariable("drive_45_Outputs.multiSensorLoad.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 5.139, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "firstOrder1.y", 1, 1, 8, 0)
DeclareAlias2("drive_45_Outputs.rotateCW_In", "[:#(type=Boolean)]", \
"rotateCW1.y", 1, 5, 875, 65)
DeclareVariable("drive_45_Outputs.pin_p.v", "Potential at the pin [V]", 60.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive_45_Outputs.pin_p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive_45_Outputs.pin_n.v", "Potential at the pin [V]", 0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.pin_n.i", "Current flowing into the pin [A]", \
"drive_45_Outputs.pin_p.i", -1, 5, 1056, 132)
DeclareVariable("drive_45_Outputs.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 -5.139, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive_45_Outputs.w1", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 0)
DeclareVariable("drive_45_Outputs.tau1", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive_45_Outputs.currentSensor.p.v", "Potential at the pin [V]", \
"drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.currentSensor.p.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 132)
DeclareAlias2("drive_45_Outputs.currentSensor.n.v", "Potential at the pin [V]", \
"drive_45_Outputs.inverter.pin_p_Out.v", 1, 5, 887, 4)
DeclareAlias2("drive_45_Outputs.currentSensor.n.i", "Current flowing into the pin [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", -1, 1, 7, 132)
DeclareAlias2("drive_45_Outputs.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 0)
DeclareAlias2("drive_45_Outputs.i1", "Current in the branch from p to n as output signal [A]",\
 "drive_45_Outputs.machine.coreElement.overallInductance.i", 1, 1, 7, 0)
DeclareVariable("constantVoltage1.V", "Value of constant voltage [V]", 60, \
0.0,0.0,0.0,0,513)
DeclareVariable("constantVoltage1.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 60, 0.0,0.0,0.0,0,513)
DeclareVariable("constantVoltage1.p.v", "Potential at the pin [V]", 60.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("constantVoltage1.p.i", "Current flowing into the pin [A]", \
"drive_45_Outputs.pin_p.i", -1, 5, 1056, 132)
DeclareVariable("constantVoltage1.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("constantVoltage1.n.i", "Current flowing into the pin [A]", \
"drive_45_Outputs.pin_p.i", 1, 5, 1056, 132)
DeclareAlias2("constantVoltage1.i", "Current flowing from pin p to pin n [A]", \
"drive_45_Outputs.pin_p.i", -1, 5, 1056, 0)
DeclareVariable("const.k", "Constant output value [N.m]", -5.139, 0.0,0.0,0.0,0,513)
DeclareVariable("const.y", "Connector of Real output signal [N.m]", -5.139, \
0.0,0.0,0.0,0,513)
DeclareVariable("firstOrder1.k", "Gain [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("firstOrder1.T", "Time Constant [s]", 0.08, 0.0,0.0,0.0,0,513)
DeclareVariable("firstOrder1.initType", "Type of initialization (1: no init, 2: steady state, 3/4: initial output) [:#(type=Modelica.Blocks.Types.Init)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("firstOrder1.y_start", "Initial or guess value of output (= state) [1]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("firstOrder1.u", "Connector of Real input signal", "dutyCycle2.y", 1,\
 5, 877, 0)
DeclareState("firstOrder1.y", "Connector of Real output signal [1]", 8, 0, \
0.0,0.0,0.0,0,544)
DeclareDerivative("firstOrder1.der(y)", "der(Connector of Real output signal) [s-1]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.hallSensorOutput[1]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.hallSensorOutput[2]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.hallSensorOutput[3]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareVariable("drive.inverter.voltageDC.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.hallSensorOutput[1]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.hallSensorOutput[2]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.hallSensorOutput[3]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.airgapTorque", 1,\
 5, 790, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.currentAC_Averaged",\
 "DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareVariable("drive_45_Outputs.inverter.voltageDC.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.bldcBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareAlias2("drive.controller.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.controller.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.controller.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.controller.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareAlias2("drive.controller.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.controller.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.controller.bldcBus.electricMachinePower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 499, 4)
DeclareAlias2("drive.controller.bldcBus.hallSensorOutput[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 81, 69)
DeclareAlias2("drive.controller.bldcBus.hallSensorOutput[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 82, 69)
DeclareAlias2("drive.controller.bldcBus.hallSensorOutput[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 83, 69)
DeclareAlias2("drive.controller.bldcBus.innerMechanicPower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 500, 4)
DeclareAlias2("drive.controller.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.controller.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.controller.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.controller.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.airgapTorque",\
 "Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.airgapTorque", 1,\
 5, 790, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.currentAC[1]",\
 "DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.currentAC[2]",\
 "DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.currentAC[3]",\
 "DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.currentDC", \
"DC current of the inverter [A]", "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.dutyCycle", \
"Ratio of on-time to period duration [1]", "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.innerTorque", 1,\
 5, 791, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.machineAngle",\
 "Ratio of on-time to period duration [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.machineSpeed",\
 "Ratio of on-time to period duration [rad/s|1/min]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareVariable("drive.controller.hallSensorOutput.electricDriveBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.inverter.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.inverter.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.inverter.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareAlias2("drive.inverter.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.inverter.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.inverter.bldcBus.electricMachinePower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 499, 4)
DeclareAlias2("drive.inverter.bldcBus.hallSensorOutput[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 81, 69)
DeclareAlias2("drive.inverter.bldcBus.hallSensorOutput[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 82, 69)
DeclareAlias2("drive.inverter.bldcBus.hallSensorOutput[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 83, 69)
DeclareAlias2("drive.inverter.bldcBus.innerMechanicPower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 500, 4)
DeclareAlias2("drive.inverter.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.inverter.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.inverter.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.inverter.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.currentAC.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.inverter.currentAC.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.inverter.currentAC.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.inverter.currentAC.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.inverter.currentAC.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.currentDC.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.inverter.currentDC.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.inverter.currentDC.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.inverter.currentDC.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.inverter.currentDC.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareVariable("drive.machine.airGapTorque.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.angleSensor.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.angleSensor.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.machine.angleSensor.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.machine.angleSensor.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.machine.angleSensor.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.airgapTorque",\
 "Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.airgapTorque", 1,\
 5, 790, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.currentAC[1]",\
 "DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.currentAC[2]",\
 "DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.currentAC[3]",\
 "DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.dutyCycle",\
 "Ratio of on-time to period duration [1]", "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.innerTorque",\
 "Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.innerTorque", 1,\
 5, 791, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.machineAngle",\
 "Ratio of on-time to period duration [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.machineSpeed",\
 "Ratio of on-time to period duration [rad/s|1/min]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareVariable("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.voltageDC",\
 "DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.machine.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.machine.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.machine.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareAlias2("drive.machine.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.bldcBus.electricMachinePower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 499, 4)
DeclareAlias2("drive.machine.bldcBus.hallSensorOutput[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 81, 69)
DeclareAlias2("drive.machine.bldcBus.hallSensorOutput[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 82, 69)
DeclareAlias2("drive.machine.bldcBus.hallSensorOutput[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 83, 69)
DeclareAlias2("drive.machine.bldcBus.innerMechanicPower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 500, 4)
DeclareAlias2("drive.machine.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.machine.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.machine.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.machine.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.airgapTorque", 1,\
 5, 790, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.dutyCycle", \
"Ratio of on-time to period duration [1]", "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.innerTorque", 1,\
 5, 791, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareVariable("drive.machine.electricMachinePower.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.airgapTorque", 1,\
 5, 790, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.dutyCycle", \
"Ratio of on-time to period duration [1]", "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.innerTorque", 1,\
 5, 791, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareVariable("drive.machine.innerMachinePower.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.innerTorque.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.innerTorque.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.machine.innerTorque.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.machine.innerTorque.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.machine.innerTorque.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.machineAngle.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.airgapTorque", 1,\
 5, 790, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.machineAngle.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.machine.machineAngle.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.machine.machineAngle.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareVariable("drive.machine.machineAngle.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.airgapTorque", 1,\
 5, 790, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareVariable("drive.machine.machineSpeed.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.modulation.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.airgapTorque", 1, 5, 790, 4)
DeclareAlias2("drive.modulation.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[1].i", 1, 5, 622, 4)
DeclareAlias2("drive.modulation.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[2].i", 1, 1, 0, 4)
DeclareAlias2("drive.modulation.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.machine.coreElement.overallInductance.inductor[3].i", 1, 1, 1, 4)
DeclareAlias2("drive.modulation.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.modulation.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "firstOrder.y", 1, 1, 4, 4)
DeclareAlias2("drive.modulation.bldcBus.electricMachinePower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 499, 4)
DeclareAlias2("drive.modulation.bldcBus.hallSensorOutput[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 81, 69)
DeclareAlias2("drive.modulation.bldcBus.hallSensorOutput[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 82, 69)
DeclareAlias2("drive.modulation.bldcBus.hallSensorOutput[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 83, 69)
DeclareAlias2("drive.modulation.bldcBus.innerMechanicPower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 500, 4)
DeclareAlias2("drive.modulation.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.modulation.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.machine.coreElement.damper.phi_rel", -1, 1, 2, 4)
DeclareAlias2("drive.modulation.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.machine.coreElement.damper.w_rel", -1, 1, 3, 4)
DeclareVariable("drive.modulation.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.airgapTorque", 1,\
 5, 790, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[1].i", 1,\
 5, 622, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[2].i", 1,\
 1, 0, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.machine.coreElement.overallInductance.inductor[3].i", 1,\
 1, 1, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.pin_p.i", 1, 5, 855, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 499, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 81, 69)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 82, 69)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 83, 69)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 500, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 791, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.machine.coreElement.damper.phi_rel", -1,\
 1, 2, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.machine.coreElement.damper.w_rel", -1,\
 1, 3, 4)
DeclareVariable("drive.modulation.dutyCycle.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.controller.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.controller.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.controller.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.controller.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.controller.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.controller.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.controller.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.controller.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.controller.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive_45_Outputs.machine.coreElement.airgapTorque", 1, 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.inverter.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.inverter.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.inverter.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.inverter.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.inverter.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive_45_Outputs.machine.coreElement.innerTorque", 1, 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.inverter.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
EndNonAlias(0)
PreNonAliasNew(1)
StartNonAlias(1)
DeclareAlias2("drive_45_Outputs.inverter.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 4)
DeclareVariable("drive_45_Outputs.inverter.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.airgapTorque",\
 "Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.innerTorque",\
 "Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.machineAngle",\
 "Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.machineSpeed",\
 "Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.inverter.currentAC_Averaged.bldcBus.voltageDC",\
 "DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.inverter.currentDC.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.inverter.currentDC.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.inverter.voltageDC.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.inverter.voltageDC.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.inverter.voltageDC.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.inverter.voltageDC.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.inverter.voltageDC.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.inverter.voltageDC.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.inverter.voltageDC.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.inverter.voltageDC.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.bldcBus.currentAC_Averaged",\
 "DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.bldcBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.airGapTorque.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.machine.airGapTorque.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive_45_Outputs.machine.coreElement.airgapTorque", 1, 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.machine.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.machine.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.machine.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.machine.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.machine.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive_45_Outputs.machine.coreElement.innerTorque", 1, 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.machine.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive_45_Outputs.inertia.phi", 1, 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive_45_Outputs.machine.coreElement.damper.w_rel", -1, 1, 6, 4)
DeclareVariable("drive_45_Outputs.machine.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.bldcBus.airgapTorque",\
 "Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.bldcBus.currentAC_Averaged",\
 "DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.bldcBus.currentDC",\
 "DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.bldcBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.bldcBus.innerTorque",\
 "Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.bldcBus.machineAngle",\
 "Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.electricMachinePower.bldcBus.machineSpeed",\
 "Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.machine.electricMachinePower.bldcBus.voltageDC",\
 "DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.bldcBus.airgapTorque",\
 "Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.bldcBus.currentAC_Averaged",\
 "DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.bldcBus.machineAngle",\
 "Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.innerMachinePower.bldcBus.machineSpeed",\
 "Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.machine.innerMachinePower.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.bldcBus.currentAC_Averaged",\
 "DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.bldcBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.machine.innerTorque.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.machine.innerTorque.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.bldcBus.currentAC_Averaged",\
 "DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.bldcBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.machine.machineAngle.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.machine.machineAngle.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.bldcBus.currentAC_Averaged",\
 "DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.bldcBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.machine.machineSpeed.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareVariable("drive_45_Outputs.machine.machineSpeed.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive_45_Outputs.modulation.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.airgapTorque", 1,\
 5, 1018, 4)
DeclareAlias2("drive_45_Outputs.modulation.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive_45_Outputs.inverter.currentAC_Averaged.u", 1,\
 5, 920, 4)
DeclareAlias2("drive_45_Outputs.modulation.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive_45_Outputs.pin_p.i", 1, 5, 1056, 4)
DeclareAlias2("drive_45_Outputs.modulation.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.electricMachinePower", 1,\
 5, 961, 4)
DeclareAlias2("drive_45_Outputs.modulation.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive_45_Outputs.machine.powerBalance.innerMachinePower", 1,\
 5, 962, 4)
DeclareAlias2("drive_45_Outputs.modulation.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive_45_Outputs.machine.coreElement.innerTorque", 1,\
 5, 1017, 4)
DeclareAlias2("drive_45_Outputs.modulation.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive_45_Outputs.inertia.phi", 1,\
 5, 1050, 4)
DeclareAlias2("drive_45_Outputs.modulation.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive_45_Outputs.machine.coreElement.damper.w_rel", -1,\
 1, 6, 4)
DeclareVariable("drive_45_Outputs.modulation.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareOutput("CPUtime", "[s]", 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("EventCounter", "", 1, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(1)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,84),"drive.controller.coreElement.halfBridgeOutput[1]", 1, 8);
pre(DYNX(W_,85),"drive.controller.coreElement.halfBridgeOutput[2]", 1, 9);
pre(DYNX(W_,86),"drive.controller.coreElement.halfBridgeOutput[3]", 1, 10);
pre(DYNX(W_,79),"drive.controller.coreElement.same", false, 7);
preWD(DYNX(W_,274),"drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].off",
   false, 0);
preWD(DYNX(W_,285),"drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].off",
   false, 1);
preWD(DYNX(W_,296),"drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].off",
   false, 2);
preWD(DYNX(W_,221),"drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].off",
   false, 3);
preWD(DYNX(W_,232),"drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].off",
   false, 4);
preWD(DYNX(W_,243),"drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].off",
   false, 5);
preWD(DYNX(W_,875),"rotateCW1.y", false, 6);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(F_,0), 0.0, 12);
DoRemember_(DYNX(F_,1), 0.0, 13);
DoRemember_(DYNX(W_,391), 0, 5);
DoRemember_(DYNX(W_,403), 0, 1);
DoRemember_(DYNX(W_,415), 0, 9);
DoRemember_(DYNX(W_,275), 0.0, 6);
DoRemember_(DYNX(W_,286), 0.0, 2);
DoRemember_(DYNX(W_,297), 0.0, 10);
DoRemember_(DYNX(W_,332), 0, 4);
DoRemember_(DYNX(W_,344), 0, 0);
DoRemember_(DYNX(W_,356), 0, 8);
DoRemember_(DYNX(W_,222), 0.0, 7);
DoRemember_(DYNX(W_,233), 0.0, 3);
DoRemember_(DYNX(W_,244), 0.0, 11);
EndEqBlock
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionEnd()
