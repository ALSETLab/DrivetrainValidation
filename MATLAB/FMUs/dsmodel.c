/* DSblock model generated by Dymola from Modelica model DrivetrainValidation.FMU.Sinusoidal
 Dymola Version 2021x (64-bit), 2020-11-26 translated this at Tue Feb 23 14:48:58 2021

  Evaluate = true;
OutputCPUtime = true;
 */
#ifndef DYN_MULTINSTANCE
#define DYN_MULTINSTANCE 1
#endif

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays25[3]={0.0, 0.0, 0.0};
static double DymArrays20[3]={2E-06, 3.0, 2.0};
static double DymArrays6[3]={1E-05, 1E-05, 0.0};
static double DymArrays16[3]={0.00775, 293.15, 0.0};
static double DymArrays8[3]={1.0, 1.0, 0.0};
static double DymArrays0[3]={1.0, 1.0, 3.0};
static double DymArrays9[3]={3.0, 0.0155, 2.0};
static double DymArrays2[3]={3.0, 3.0, 3.0};
static double DymArrays4[3]={293.15, 293.15, 293.15};
static double DymArrays28[4]={0.0, 0.0, 0.0, 0.0};
static double DymArrays26[4]={0.0, 0.0, 0.0, 314.1592653589793};
static double DymArrays21[4]={2E-06, 0.0, 0.0, 2E-06};
static double DymArrays1[4]={3.0, 3.0, 3.0, 3.0};
static double DymArrays27[4]={293.15, 293.15, 293.15, 293.15};
static double DymArrays24[5]={0.0, 0.0, 0.0, 0.0, 0.0};
static double DymArrays19[5]={0.0, 1.0, 157.07963267948966, 1.0, 0.0};
static double DymArrays3[6]={1E-05, 1E-05, 1E-05, 1E-05, 1E-05, 1E-05};
static double DymArrays7[7]={0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0};
static double DymArrays13[7]={4668.818000000001, 3550.0, 1.0, 1.3151600000000003,
   0.001, 3.5500000000000003, 0.0013151600000000003};
static double DymArrays23[8]={3.0, 0.0, 0.0, 1.0, 2.0, 100.0, 1.0, 0.0};
static double DymArrays5[9]={1E-05, 1E-05, 1E-05, 1E-05, 1E-05, 1E-05, 0.0, 0.0,
   0.0};
static double DymArrays15[9]={0.00775, 0.00775, 0.00775, 293.15, 293.15, 293.15,
   0.0, 0.0, 0.0};
static double DymArrays12[9]={2.0, 50.0, 293.15, 0.00775, 293.15, 0.0, 0.0, 0.0,
   1E-15};
static double DymArrays17[10]={0.0, 3.0, 0.0, 100.0, 314.1592653589793, 0.0, 0.0,
   0.0003141592653589793, 3.0, 1.0};
static double DymArrays11[11]={3.141592653589793, 2.0, 3.665191429188092, 
  4.71238898038469, 5.759586531581287, 0.5235987755982988, 1.5707963267948966, 
  2.617993877991494, 3.665191429188092, 4.71238898038469, 5.759586531581287};
static double DymArrays18[12]={0.6666666666666666, -0.33333333333333315, 
  -0.3333333333333336, 0.0, 0.5773502691896257, -0.5773502691896256, 1.0, 0.0, 
  -0.4999999999999998, 0.8660254037844387, -0.5000000000000004, -0.8660254037844385};
static double DymArrays14[12]={3.0, 0.0, 100.0, 314.1592653589793, 0.0, 0.0, 
  0.0003141592653589793, 0.0, 1.0, 157.07963267948966, 1.0, 0.0};
static double DymArrays22[13]={0.0, 0.0, 0.0, 0.0, 293.15, 0.0, 0.0, 0.0, 1.0, 
  2.0, 100.0, 1.0, 0.0};
static double DymArrays10[26]={4E-06, 1E-15, 1E-15, 0.0, 1.0, 0.1342, 71.0, 
  1E-15, 1E-15, 9.8, 3550.0, 50.0, 177.8, 23.853, 352.3819759776551, 
  8405.367272995007, 0.1342, 0.0003704676056338029, 0.00775, 2E-06, 2E-06, 0.0, 
  50.0, 0.03355, 9.012087208016212, 4668.818000000001};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct {
  RealArray    y0_0_0member;
  double   y00_0_0member;
};
DYMOLA_STATIC struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct
   Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(RealArray  
   x0_0);
DYMOLA_STATIC double   Modelica_Electrical_Machines_SpacePhasors_Functions_activePower
  (RealArray   v0_0, RealArray   i0_0);
DYMOLA_STATIC RealArray    Modelica_Electrical_Polyphase_Functions_symmetricOrientation
  (int  m0_0);
DYMOLA_STATIC RealArray    cos_For_1_0(RealArray   u0_0);
DYMOLA_STATIC RealArray    sin_For_1_0(RealArray   u0_0);
/* Codes used in model */

/* Flattened Modelica model:

function Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor
discrete input Real x[:] "Polyphase (voltage or current) input";
discrete output Real y[2] "Space phasor";
discrete output Real y0 "Zero sequence component (of voltage or current)";
protected 
parameter Integer m = size(x, 1) "Number of phases" annotation (Evaluate=true);
parameter Real phi[m](unit = "rad", displayUnit = "deg") = Modelica.Electrical.Polyphase.Functions.symmetricOrientation(m);
parameter Real TransformationMatrix[2, m] = 2*{cos(phi), sin(phi)}/m;
parameter Real InverseTransformation[m, 2] = array({cos(phi[k]),  -sin( -phi[k])} for k in 1:m);
public 
algorithm 
y := TransformationMatrix*x;
y0 := 1/m*sum(x);
annotation(Inline=true);
end Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor;

  */
DYMOLA_STATIC struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct
   Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(RealArray  
   x0_0) {
  PushContext("Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor")
  {
    /* Declare outputs and temporaries */
    RealArray    y0_0;
    double   y00_0;
    int   m0_0;
    RealArray    phi0_0;
    RealArray    TransformationMatrix0_0;
    RealArray    InverseTransformation0_0;
    RealArray    helperx_00;
    MarkObject retmark_ = PushMark();
    y0_0=RealTemporary( 1, 2);
    RePushMark(&retmark_);
    RealFillAssign( y0_0, 0);
    y00_0=0;
    m0_0 = DYNSizeSimple(x0_0, 1);
    phi0_0=RealTemporary( 1, m0_0);
    PushMark();
    RealAssign (phi0_0, Modelica_Electrical_Polyphase_Functions_symmetricOrientation
      (m0_0));
    Release();
    TransformationMatrix0_0=RealTemporary( 2, 2, m0_0);
    PushMark();
    RealAssign (TransformationMatrix0_0, RealScaleDiv (RealScale (RealArrayArray 
      ( 2, cos_For_1_0(phi0_0), sin_For_1_0(phi0_0)),2),m0_0));
    Release();
    helperx_00=RealTemporary( 2, IntegerBmax(0, m0_0), 2);
    PushMark();
    RealFillAssign( helperx_00, 0);
    InverseTransformation0_0=RealTemporary( 2, m0_0, 2);
    PushMark();
    {
      int end_ = m0_0;
      int k0_0_0;
      for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
        RealPutSub( RealScalarArray ( 2, cos(RealElement( phi0_0, (SizeType)(
          k0_0_0))),  -sin( -RealElement( phi0_0, (SizeType)(k0_0_0)))), 
          helperx_00 , Index, (Integer)(k0_0_0) ,Colon  , EndMark);
        Release();
      }
    }
    RealAssign (InverseTransformation0_0, helperx_00);
    Release();
    /* Start of real code */
      RealAssign (y0_0, RealMultiplyMV (TransformationMatrix0_0,x0_0));
      Release();
      y00_0 = divinvGuarded(m0_0,"m")*Realsum( x0_0);
      Release();
    /* Output section */
    PopMark(retmark_);
    PopContext()
    {
      struct Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor_struct out_;
      out_.y0_0_0member = y0_0;
      out_.y00_0_0member = y00_0;
      return out_;
    }
  }}

/* Flattened Modelica model:

function Modelica.Electrical.Machines.SpacePhasors.Functions.activePower
discrete input Real v[m](unit = "V") "Phase voltages";
discrete input Real i[m](unit = "A") "Phase currents";
discrete output Real p(unit = "W") "Active power";
protected 
constant Integer m = 3 "Number of phases";
discrete Real v_[2](unit = "V") "Voltage space phasor";
discrete Real i_[2](unit = "A") "Current space phasor";
public 
algorithm 
v_ := zeros(2);
i_ := zeros(2);
for k in (1:m) loop
v_ := v_+2/m*{cos((k-1)/m*2*3.141592653589793), sin((k-1)/m*2*3.141592653589793)}*v[k];
i_ := i_+2/m*{cos((k-1)/m*2*3.141592653589793), sin((k-1)/m*2*3.141592653589793)}*i[k];
end for;
p := m/2*(v_[1]*i_[1]+v_[2]*i_[2]);
annotation(Inline=true);
end Modelica.Electrical.Machines.SpacePhasors.Functions.activePower;

  */
DYMOLA_STATIC double   Modelica_Electrical_Machines_SpacePhasors_Functions_activePower
  (RealArray   v0_0, RealArray   i0_0) {
  PushContext("Modelica.Electrical.Machines.SpacePhasors.Functions.activePower")
  {
    /* Declare outputs and temporaries */
    double   p0_0;
    int   m0_0;
    RealArray    vx_0;
    RealArray    ix_0;
    MarkObject retmark_ = PushMark();
    p0_0=0;
    m0_0 = 3;
    vx_0=RealTemporary( 1, 2);
    PushMark();
    RealFillAssign( vx_0, 0);
    ix_0=RealTemporary( 1, 2);
    PushMark();
    RealFillAssign( ix_0, 0);
    AssertModelica(DYNSizeSimple(v0_0,1)==m0_0,"size(v, 1) == m","Dimension check of input to function failed");
    AssertModelica(DYNSizeSimple(i0_0,1)==m0_0,"size(i, 1) == m","Dimension check of input to function failed");
    /* Start of real code */
      RealFillAssign (vx_0, 0);
      Release();
      RealFillAssign (ix_0, 0);
      Release();
      {
        int end_ = m0_0;
        int k0_0_0;
        for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
          RealAssign (vx_0, RealAdd (vx_0,RealScale (RealScale (RealScalarArray 
            ( 2, cos(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793), 
            sin(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793)),
            divGuarded(2,"2",m0_0,"m")),RealElement( v0_0, (SizeType)(k0_0_0)))));
          Release();
          RealAssign (ix_0, RealAdd (ix_0,RealScale (RealScale (RealScalarArray 
            ( 2, cos(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793), 
            sin(divGuarded(k0_0_0-1,"k-1",m0_0,"m")*2*3.141592653589793)),
            divGuarded(2,"2",m0_0,"m")),RealElement( i0_0, (SizeType)(k0_0_0)))));
          Release();
        }
      }
      p0_0 = m0_0/(double)(2)*(RealVectorElement( vx_0, (SizeType)(1))*
        RealVectorElement( ix_0, (SizeType)(1))+RealVectorElement( vx_0, 
        (SizeType)(2))*RealVectorElement( ix_0, (SizeType)(2)));
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return p0_0;
  }}

/* Flattened Modelica model:

function Modelica.Electrical.Polyphase.Functions.symmetricOrientation
input Integer m "Number of phases";
discrete output Real orientation[m](unit = "rad", displayUnit = "deg") "Orientation of the resulting fundamental wave field phasors";

algorithm 
if (mod(m, 2) == 0) then 
if (m == 2) then 
orientation[1] := 0;
orientation[2] := 1.5707963267948966;
else
orientation[1:integer(m/2)] := Modelica.Electrical.Polyphase.Functions.symmetricOrientation(integer(m/2));
orientation[integer(m/2)+1:m] := Modelica.Electrical.Polyphase.Functions.symmetricOrientation(integer(m/2))-fill(3.141592653589793/m, integer(m/2));
end if;
else
orientation := array((k-1)*2*3.141592653589793/m for k in 1:m);
end if;
end Modelica.Electrical.Polyphase.Functions.symmetricOrientation;

  */
DYMOLA_STATIC RealArray    Modelica_Electrical_Polyphase_Functions_symmetricOrientation
  (int  m0_0) {
  PushContext("Modelica.Electrical.Polyphase.Functions.symmetricOrientation")
  {
    /* Declare outputs and temporaries */
    RealArray    orientation0_0;
    RealArray    helperx_00;
    MarkObject retmark_ = PushMark();
    orientation0_0=RealTemporary( 1, m0_0);
    RePushMark(&retmark_);
    RealFillAssign( orientation0_0, 0);
    helperx_00=RealTemporary( 1, IntegerBmax(0, m0_0));
    PushMark();
    RealFillAssign( helperx_00, 0);
    /* Start of real code */
      if (real2integer(modulusDymola(m0_0, 2)) == 0) {
        if (m0_0 == 2) {
          SetRealElement(0, orientation0_0, (SizeType)(1));
          SetRealElement(1.5707963267948966, orientation0_0, (SizeType)(2));
        }
        else{
          RealPutSub( Modelica_Electrical_Polyphase_Functions_symmetricOrientation
            (real2integer(m0_0/(double)(2))), orientation0_0 ,Range , (Integer)(1),
             (Integer)(real2integer(m0_0/(double)(2))) , EndMark);
          Release();
          RealPutSub( RealSubtract (Modelica_Electrical_Polyphase_Functions_symmetricOrientation
            (real2integer(m0_0/(double)(2))),RealFill( divGuarded(
            3.141592653589793,"3.141592653589793",m0_0,"m"), 1, (SizeType)(
            real2integer(m0_0/(double)(2))))), orientation0_0 ,Range , (Integer)
            (real2integer(m0_0/(double)(2))+1), (Integer)(m0_0) , EndMark);
          Release();
        }
      }
      else{
        {
          int end_ = m0_0;
          int k0_0_0;
          for(k0_0_0 = 1;k0_0_0 <= end_;k0_0_0 += 1) {
            SetRealElement(divGuarded((k0_0_0-1)*2*3.141592653589793,
              "(k-1)*2*3.141592653589793",m0_0,"m"), helperx_00, (SizeType)(
              k0_0_0));
          }
        }
        RealAssign (orientation0_0, helperx_00);
        Release();
      }
    /* Output section */
    PopMark(retmark_);
    PopContext()
    return orientation0_0;
  }}
DYMOLA_STATIC RealArray    cos_For_1_0(RealArray   u0_0) {
  PushContext("Vectorized ""cos")
   {
    RealArray   y0_0 = RealTemporary(  1, RealSize( u0_0, 1));
    int i_ ;
    int max_size_ = RealNrElements( y0_0);
    for(i_ = 0 ; i_ < max_size_; i_++) {
      y0_0.data[i_]=cos(u0_0.data[i_]);
    }
    PopContext()
    return y0_0;
  }
}
DYMOLA_STATIC RealArray    sin_For_1_0(RealArray   u0_0) {
  PushContext("Vectorized ""sin")
   {
    RealArray   y0_0 = RealTemporary(  1, RealSize( u0_0, 1));
    int i_ ;
    int max_size_ = RealNrElements( y0_0);
    for(i_ = 0 ; i_ < max_size_; i_++) {
      y0_0.data[i_]=sin(u0_0.data[i_]);
    }
    PopContext()
    return y0_0;
  }
}
/* DSblock C-code: */

BreakSectionFunctionDef(1)
BreakSectionFunctionDef(0)
BreakSectionFunctionDef(2)
BreakSectionFunctionDef(3)
#define NX_    4
#define NX2_   0
#define NU_    3
#define NY_    6
#define NW_    1035
#define NP_    0
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -1302967897
#define NHash2_ -814448994
#define NHash3_ 0
#define NI_    0
#define NRelF_ 16
#define NRel_  16
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    715
#define SizePre_ 4
#define SizeEq_ 14
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 261
#define NGlobalHelpI_ 36
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="DrivetrainValidation.FMU.Sinusoidal";
#endif
DYMOLA_STATIC const char*usedLibraries[]={"BrushlessDCDrivesLib",0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/meagh/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
DYMOLA_STATIC const char*GUIDString="{b17f7445-b78d-4257-95aa-9edc745ff030}";
DYMOLA_STATIC const double cvodeTolerance=1E-05;
#define FMIStateValueReferencesDef_ 1
DYMOLA_STATIC unsigned int FMIStateValueReferences_[4]={
33554432, 33554433, 33554434, 33554435};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_
#define DIRECT_FEED_THROUGH 1

TranslatedEquations
DYNX(Y_,4) = CurrentClockTime;
if (DYNEvent) DYNX(Y_,5) += 1;

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,1) = true;
DYNX(W_,3) = 3;
DYNX(W_,85) = 3;
DYNX(W_,86) = 3;
DYNX(W_,171) = 3;
DYNX(W_,175) = 3;
DYNX(W_,176) = 3;
DYNX(W_,182) = 3;
DYNX(W_,183) = 3;
DYNX(W_,192) = 3;
DYNX(W_,199) = 3;
DYNX(W_,200) = 3;
DYNX(W_,207) = 3;
DYNX(W_,208) = false;
DYNX(W_,216) = false;
DYNX(W_,222) = 1;
DYNX(W_,223) = 1;
DYNX(W_,228) = false;
DYNX(W_,234) = 1;
DYNX(W_,235) = 1;
DYNX(W_,240) = false;
memcpy(&DYNX(W_,246), &DymArrays0, sizeof(double)*3);
DYNX(W_,252) = 3;
DYNX(W_,253) = 3;
DYNX(W_,263) = 3;
DYNX(W_,264) = false;
DYNX(W_,272) = false;
DYNX(W_,278) = 1;
DYNX(W_,279) = 1;
DYNX(W_,284) = false;
DYNX(W_,290) = 1;
DYNX(W_,291) = 1;
DYNX(W_,296) = false;
memcpy(&DYNX(W_,302), &DymArrays0, sizeof(double)*3);
DYNX(W_,311) = 3;
DYNX(W_,312) = 3;
DYNX(W_,322) = 3;
DYNX(W_,323) = false;
DYNX(W_,332) = false;
DYNX(W_,338) = 1;
DYNX(W_,339) = 1;
DYNX(W_,345) = false;
DYNX(W_,351) = 1;
DYNX(W_,352) = 1;
DYNX(W_,358) = false;
memcpy(&DYNX(W_,364), &DymArrays0, sizeof(double)*3);
DYNX(W_,370) = 3;
DYNX(W_,374) = 3;
DYNX(W_,384) = 3;
DYNX(W_,385) = false;
DYNX(W_,395) = false;
DYNX(W_,401) = 1;
DYNX(W_,402) = 1;
DYNX(W_,409) = false;
DYNX(W_,415) = 1;
DYNX(W_,416) = 1;
DYNX(W_,423) = false;
DYNX(W_,429) = 1;
DYNX(W_,430) = 1;
DYNX(W_,439) = 3;
DYNX(W_,440) = 3;
DYNX(W_,464) = 3;
memcpy(&DYNX(W_,473), &DymArrays1, sizeof(double)*4);
DYNX(W_,515) = false;
DYNX(W_,516) = false;
DYNX(W_,517) = 3;
DYNX(W_,530) = 3;
DYNX(W_,550) = 3;
DYNX(W_,555) = 3;
DYNX(W_,556) = 3;
DYNX(W_,566) = false;
DYNX(W_,568) = false;
DYNX(W_,581) = 3;
DYNX(W_,587) = 3;
DYNX(W_,606) = true;
DYNX(W_,643) = 3;
DYNX(W_,644) = 3;
DYNX(W_,646) = 3;
DYNX(W_,650) = 3;
DYNX(W_,651) = 3;
DYNX(W_,664) = 3;
DYNX(W_,665) = true;
DYNX(W_,679) = true;
DYNX(W_,689) = true;
DYNX(W_,699) = true;
DYNX(W_,729) = true;
DYNX(W_,738) = 3;
DYNX(W_,755) = 3;
DYNX(W_,756) = 3;
DYNX(W_,761) = 3;
DYNX(W_,765) = 3;
DYNX(W_,766) = 3;
DYNX(W_,776) = true;
DYNX(W_,781) = false;
DYNX(W_,782) = 3;
DYNX(W_,783) = false;
DYNX(W_,784) = 293.15;
DYNX(W_,790) = 3;
DYNX(W_,801) = false;
DYNX(W_,819) = 3;
DYNX(W_,838) = 3.141592653589793;
DYNX(W_,839) = 3;
DYNX(W_,854) = false;
DYNX(W_,894) = false;
DYNX(W_,923) = true;
DYNX(W_,932) = 3;
DYNX(W_,933) = 1;
DYNX(W_,934) = false;
memcpy(&DYNX(W_,935), &DymArrays2, sizeof(double)*3);
DYNX(W_,939) = 3;
DYNX(W_,940) = 3;
DYNX(W_,947) = 3;
memcpy(&DYNX(W_,949), &DymArrays2, sizeof(double)*3);
DYNX(W_,962) = 3;
DYNX(W_,963) = 3;
DYNX(W_,985) = false;
DYNX(W_,989) = 3;
DYNX(W_,0) = 3;
DYNX(W_,2) = false;
DYNX(W_,87) = true;
DYNX(W_,4) = true;
DYNX(W_,88) = false;
DYNX(W_,5) = false;
DYNX(W_,89) = false;
DYNX(W_,6) = false;
DYNX(W_,90) = true;
DYNX(W_,7) = true;
DYNX(W_,91) = true;
DYNX(W_,8) = true;
DYNX(W_,92) = false;
DYNX(W_,9) = false;
DYNX(W_,93) = true;
DYNX(W_,10) = true;
DYNX(W_,94) = true;
DYNX(W_,11) = true;
DYNX(W_,95) = true;
DYNX(W_,12) = true;
DYNX(W_,96) = false;
DYNX(W_,13) = false;
DYNX(W_,97) = true;
DYNX(W_,14) = true;
DYNX(W_,98) = true;
DYNX(W_,15) = true;
DYNX(W_,99) = false;
DYNX(W_,16) = false;
DYNX(W_,100) = false;
DYNX(W_,17) = false;
DYNX(W_,101) = true;
DYNX(W_,18) = true;
DYNX(W_,102) = false;
DYNX(W_,19) = false;
DYNX(W_,103) = false;
DYNX(W_,20) = false;
DYNX(W_,104) = false;
DYNX(W_,21) = false;
DYNX(W_,105) = true;
DYNX(W_,22) = true;
DYNX(W_,106) = false;
DYNX(W_,23) = false;
DYNX(W_,107) = true;
DYNX(W_,24) = true;
DYNX(W_,108) = false;
DYNX(W_,25) = false;
DYNX(W_,109) = true;
DYNX(W_,26) = true;
DYNX(W_,110) = false;
DYNX(W_,27) = false;
DYNX(W_,111) = 1;
DYNX(W_,28) = 1;
DYNX(W_,112) = 2;
DYNX(W_,29) = 2;
DYNX(W_,113) = 4;
DYNX(W_,30) = 4;
DYNX(W_,114) = 1;
DYNX(W_,31) = 1;
DYNX(W_,115) = 4;
DYNX(W_,32) = 4;
DYNX(W_,116) = 2;
DYNX(W_,33) = 2;
DYNX(W_,117) = 4;
DYNX(W_,34) = 4;
DYNX(W_,118) = 1;
DYNX(W_,35) = 1;
DYNX(W_,119) = 2;
DYNX(W_,36) = 2;
DYNX(W_,120) = 2;
DYNX(W_,37) = 2;
DYNX(W_,121) = 1;
DYNX(W_,38) = 1;
DYNX(W_,122) = 4;
DYNX(W_,39) = 4;
DYNX(W_,123) = 2;
DYNX(W_,40) = 2;
DYNX(W_,124) = 4;
DYNX(W_,41) = 4;
DYNX(W_,125) = 1;
DYNX(W_,42) = 1;
DYNX(W_,126) = 4;
DYNX(W_,43) = 4;
DYNX(W_,127) = 2;
DYNX(W_,44) = 2;
DYNX(W_,128) = 1;
DYNX(W_,45) = 1;
DYNX(W_,129) = 4;
DYNX(W_,46) = 4;
DYNX(W_,130) = 4;
DYNX(W_,47) = 4;
DYNX(W_,131) = 4;
DYNX(W_,48) = 4;
DYNX(W_,132) = 4;
DYNX(W_,49) = 4;
DYNX(W_,133) = 4;
DYNX(W_,50) = 4;
DYNX(W_,134) = 4;
DYNX(W_,51) = 4;
DYNX(W_,135) = 2;
DYNX(W_,52) = 2;
DYNX(W_,136) = 1;
DYNX(W_,53) = 1;
DYNX(W_,137) = 4;
DYNX(W_,54) = 4;
DYNX(W_,138) = 2;
DYNX(W_,55) = 2;
DYNX(W_,139) = 4;
DYNX(W_,56) = 4;
DYNX(W_,140) = 1;
DYNX(W_,57) = 1;
DYNX(W_,141) = 4;
DYNX(W_,58) = 4;
DYNX(W_,142) = 2;
DYNX(W_,59) = 2;
DYNX(W_,143) = 1;
DYNX(W_,60) = 1;
DYNX(W_,144) = 1;
DYNX(W_,61) = 1;
DYNX(W_,145) = 2;
DYNX(W_,62) = 2;
DYNX(W_,146) = 4;
DYNX(W_,63) = 4;
DYNX(W_,147) = 1;
DYNX(W_,64) = 1;
DYNX(W_,148) = 4;
DYNX(W_,65) = 4;
DYNX(W_,149) = 2;
DYNX(W_,66) = 2;
DYNX(W_,150) = 4;
DYNX(W_,67) = 4;
DYNX(W_,151) = 1;
DYNX(W_,68) = 1;
DYNX(W_,152) = 2;
#endif
BreakSectionFunctionCallNew(0);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(1);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,69) = 2;
DYNX(W_,153) = 4;
DYNX(W_,70) = 4;
DYNX(W_,154) = 4;
DYNX(W_,71) = 4;
DYNX(W_,155) = 4;
DYNX(W_,72) = 4;
DYNX(W_,156) = 4;
DYNX(W_,73) = 4;
DYNX(W_,157) = 4;
DYNX(W_,74) = 4;
DYNX(W_,158) = 4;
DYNX(W_,75) = 4;
DYNX(W_,159) = 3;
DYNX(W_,160) = 3;
DYNX(W_,167) = 3;
DYNX(W_,461) = false;
DYNX(W_,172) = false;
DYNX(W_,462) = 1E-05;
DYNX(W_,173) = 1E-05;
DYNX(W_,463) = 1E-05;
DYNX(W_,174) = 1E-05;
memcpy(&DYNX(W_,201), &DymArrays3, sizeof(double)*6);
memcpy(&DYNX(W_,209), &DymArrays4, sizeof(double)*3);
DYNX(W_,214) = 1E-05;
DYNX(W_,215) = 1E-05;
DYNX(W_,217) = 293.15;
DYNX(W_,226) = 1E-05;
DYNX(W_,227) = 1E-05;
DYNX(W_,229) = 293.15;
DYNX(W_,238) = 1E-05;
DYNX(W_,239) = 1E-05;
DYNX(W_,241) = 293.15;
memcpy(&DYNX(W_,257), &DymArrays3, sizeof(double)*6);
memcpy(&DYNX(W_,265), &DymArrays4, sizeof(double)*3);
DYNX(W_,270) = 1E-05;
DYNX(W_,271) = 1E-05;
DYNX(W_,273) = 293.15;
DYNX(W_,282) = 1E-05;
DYNX(W_,283) = 1E-05;
DYNX(W_,285) = 293.15;
DYNX(W_,294) = 1E-05;
DYNX(W_,295) = 1E-05;
DYNX(W_,297) = 293.15;
memcpy(&DYNX(W_,313), &DymArrays5, sizeof(double)*9);
memcpy(&DYNX(W_,324), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,329), &DymArrays6, sizeof(double)*3);
DYNX(W_,333) = 293.15;
memcpy(&DYNX(W_,342), &DymArrays6, sizeof(double)*3);
DYNX(W_,346) = 293.15;
memcpy(&DYNX(W_,355), &DymArrays6, sizeof(double)*3);
DYNX(W_,359) = 293.15;
memcpy(&DYNX(W_,375), &DymArrays5, sizeof(double)*9);
memcpy(&DYNX(W_,386), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,392), &DymArrays6, sizeof(double)*3);
DYNX(W_,396) = 293.15;
memcpy(&DYNX(W_,406), &DymArrays6, sizeof(double)*3);
DYNX(W_,410) = 293.15;
memcpy(&DYNX(W_,420), &DymArrays6, sizeof(double)*3);
DYNX(W_,424) = 293.15;
DYNX(W_,441) = false;
memcpy(&DYNX(W_,443), &DymArrays7, sizeof(double)*7);
memcpy(&DYNX(W_,451), &DymArrays8, sizeof(double)*3);
DYNX(W_,455) = 1.0;
DYNX(W_,456) = 0.0;
DYNX(W_,457) = false;
DYNX(W_,458) = 2;
DYNX(W_,459) = false;
DYNX(W_,460) = 3;
memcpy(&DYNX(W_,484), &DymArrays9, sizeof(double)*3);
DYNX(W_,487) = true;
DYNX(W_,488) = true;
memcpy(&DYNX(W_,489), &DymArrays10, sizeof(double)*26);
DYNX(W_,525) = 3;
DYNX(W_,526) = 2;
DYNX(W_,551) = 0.5235987755982988;
DYNX(W_,531) = 0.5235987755982988;
DYNX(W_,552) = 1.5707963267948966;
DYNX(W_,532) = 1.5707963267948966;
DYNX(W_,553) = 2.617993877991494;
DYNX(W_,533) = 2.617993877991494;
DYNX(W_,554) = 3.141592653589793;
memcpy(&DYNX(W_,534), &DymArrays11, sizeof(double)*11);
memcpy(&DYNX(W_,557), &DymArrays12, sizeof(double)*9);
DYNX(W_,567) = 1E-15;
memcpy(&DYNX(W_,569), &DymArrays13, sizeof(double)*7);
DYNX(W_,580) = 1E-15;
DYNX(W_,586) = 1E-15;
DYNX(W_,593) = 0;
memcpy(&DYNX(W_,599), &DymArrays13, sizeof(double)*7);
memcpy(&DYNX(W_,611), &DymArrays14, sizeof(double)*12);
memcpy(&DYNX(W_,655), &DymArrays15, sizeof(double)*9);
memcpy(&DYNX(W_,666), &DymArrays4, sizeof(double)*3);
memcpy(&DYNX(W_,675), &DymArrays16, sizeof(double)*3);
DYNX(W_,680) = 293.15;
memcpy(&DYNX(W_,685), &DymArrays16, sizeof(double)*3);
DYNX(W_,690) = 293.15;
memcpy(&DYNX(W_,695), &DymArrays16, sizeof(double)*3);
DYNX(W_,700) = 293.15;
DYNX(W_,705) = 0.0;
DYNX(W_,706) = 0.0;
memcpy(&DYNX(W_,719), &DymArrays17, sizeof(double)*10);
DYNX(W_,739) = 1;
memcpy(&DYNX(W_,743), &DymArrays18, sizeof(double)*12);
memcpy(&DYNX(W_,771), &DymArrays19, sizeof(double)*5);
DYNX(W_,785) = 293.15;
DYNX(W_,806) = 293.15;
DYNX(W_,809) = 293.15;
DYNX(W_,812) = 293.15;
DYNX(W_,815) = 293.15;
DYNX(W_,817) = 293.15;
DYNX(W_,889) = 293.15;
DYNX(W_,825) = 293.15;
DYNX(W_,890) = 293.15;
DYNX(W_,826) = 293.15;
DYNX(W_,836) = 293.15;
DYNX(W_,892) = 2E-06;
DYNX(W_,857) = 2E-06;
DYNX(W_,893) = 2E-06;
memcpy(&DYNX(W_,858), &DymArrays20, sizeof(double)*3);
memcpy(&DYNX(W_,885), &DymArrays21, sizeof(double)*4);
DYNX(W_,891) = 9.012087208016212;
memcpy(&DYNX(W_,895), &DymArrays22, sizeof(double)*13);
DYNX(W_,928) = 20284.32289001934;
DYNX(W_,908) = 20284.32289001934;
memcpy(&DYNX(W_,915), &DymArrays23, sizeof(double)*8);
DYNX(W_,942) = 0;
DYNX(W_,974) = -1;
DYNX(W_,988) = 0.0629;
DYNX(W_,995) = 65;
DYNX(W_,1010) = 293.15;
DYNX(W_,527) = 0;
DYNX(W_,981) = 0;
DYNX(W_,589) = 0.0;
DYNX(W_,588) = 0;
DYNX(W_,994) = 0;
DYNX(W_,996) = 65;
DYNX(W_,993) = 65.0;
DYNX(W_,431) = 65.0;
DYNX(W_,716) = 0;
DYNX(W_,714) = 0.0;
DYNX(W_,911) = 0;
DYNX(W_,767) = 0;
DYNX(W_,978) = 0;
DYNX(W_,945) = 0;
DYNX(W_,591) = 0.0;
DYNX(W_,590) = 0.0;
DYNX(W_,641) = 20284.32289001934;
DYNX(W_,642) = 0.0;
DYNX(Y_,2) = 65.0;
DYNX(W_,478) = 0;
DYNX(W_,1006) = 0;
DYNX(W_,480) = 0;
DYNX(W_,481) = 65.0;
DYNX(W_,952) = 0;
DYNX(W_,520) = 0.0;
DYNX(W_,529) = 0;
DYNX(W_,583) = 0.0;
DYNX(W_,625) = 0.0;
memcpy(&DYNX(W_,629), &DymArrays24, sizeof(double)*5);
DYNX(W_,736) = 0;
DYNX(W_,737) = 314.1592653589793;
DYNX(W_,787) = 0.0;
DYNX(W_,789) = 0.0;
DYNX(W_,803) = 0.0;
DYNX(W_,944) = 0.0;
DYNX(W_,971) = 0.0;
DYNX(W_,986) = 0;
DYNX(W_,637) = 0.0;
DYNX(W_,638) = 0.0;
DYNX(W_,998) = 0.0;
DYNX(W_,997) = 65.0;
DYNX(W_,1009) = 65.0;
DYNX(W_,1008) = 65.0;
DYNX(W_,1018) = 65.0;
DYNX(W_,1019) = 65.0;
DYNX(W_,983) = 0.0;
DYNX(W_,1020) = 65.0;
DYNX(W_,434) = 0.0;
DYNX(W_,435) = 0.0;
DYNX(W_,433) = 65.0;
DYNX(W_,398) = 293.15;
DYNX(W_,390) = 0.0;
DYNX(W_,412) = 293.15;
DYNX(W_,404) = 0.0;
DYNX(W_,426) = 293.15;
DYNX(W_,418) = 0.0;
memcpy(&DYNX(W_,371), &DymArrays25, sizeof(double)*3);
DYNX(W_,275) = 293.15;
DYNX(W_,268) = 0.0;
DYNX(W_,287) = 293.15;
DYNX(W_,280) = 0.0;
DYNX(W_,299) = 293.15;
DYNX(W_,292) = 0.0;
memcpy(&DYNX(W_,254), &DymArrays25, sizeof(double)*3);
DYNX(W_,438) = 0.0;
DYNX(W_,437) = 65.0;
DYNX(W_,190) = 0.0;
DYNX(W_,184) = 0.0;
DYNX(W_,186) = 0.0;
DYNX(W_,188) = 0.0;
DYNX(W_,450) = 0.0;
DYNX(W_,454) = 0.0;
DYNX(W_,335) = 293.15;
DYNX(W_,348) = 293.15;
DYNX(W_,361) = 293.15;
DYNX(W_,219) = 293.15;
DYNX(W_,231) = 293.15;
DYNX(W_,243) = 293.15;
DYNX(W_,1021) = 65.0;
DYNX(W_,1022) = 65.0;
DYNX(W_,472) = 65.0;
DYNX(W_,471) = 65.0;
DYNX(W_,169) = 0.0;
DYNX(W_,168) = 65.0;
DYNX(W_,1012) = 65.0;
DYNX(W_,482) = 65.0;
DYNX(W_,479) = 0.0;
DYNX(W_,477) = 65.0;
DYNX(W_,1023) = 65.0;
DYNX(W_,1024) = 65.0;
memcpy(&DYNX(W_,547), &DymArrays25, sizeof(double)*3);
DYNX(W_,1025) = 65.0;
DYNX(W_,528) = 0.0;
DYNX(W_,980) = 0.0;
DYNX(W_,982) = 0.0;
DYNX(W_,1026) = 65.0;
DYNX(W_,863) = 20284.32289001934;
DYNX(W_,864) = 0.0;
DYNX(W_,882) = 20284.32289001934;
DYNX(W_,883) = 0.0;
DYNX(W_,881) = 0.0;
DYNX(W_,929) = 0.0;
DYNX(W_,594) = 0.0;
DYNX(W_,607) = 293.15;
DYNX(W_,597) = 0.0;
DYNX(W_,592) = 0.0;
DYNX(W_,582) = 0.0;
DYNX(W_,584) = 0.0;
DYNX(W_,585) = 0.0;
DYNX(W_,609) = 0.0;
DYNX(W_,610) = 0.0;
DYNX(W_,853) = 0.0;
DYNX(W_,852) = 293.15;
DYNX(W_,856) = 0.0;
DYNX(W_,855) = 293.15;
DYNX(W_,849) = 0.0;
DYNX(W_,848) = 293.15;
DYNX(W_,847) = 0.0;
DYNX(W_,846) = 293.15;
#endif
BreakSectionFunctionEnd()
BreakSectionFunctionStart(2);
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,841) = 0.0;
DYNX(W_,840) = 293.15;
DYNX(W_,843) = 0.0;
DYNX(W_,842) = 293.15;
DYNX(W_,845) = 0.0;
DYNX(W_,844) = 293.15;
DYNX(W_,851) = 0.0;
DYNX(W_,850) = 293.15;
DYNX(W_,707) = 0.0;
DYNX(W_,708) = 0.0;
DYNX(W_,718) = 0.0;
DYNX(W_,717) = 0.0;
DYNX(W_,715) = 0.0;
DYNX(W_,713) = 0.0;
DYNX(W_,925) = 0.0;
DYNX(W_,924) = 293.15;
DYNX(W_,926) = 0.0;
DYNX(W_,909) = -20284.32289001934;
DYNX(W_,910) = 0.0;
memcpy(&DYNX(W_,912), &DymArrays25, sizeof(double)*3);
DYNX(W_,669) = 293.15;
DYNX(W_,671) = 293.15;
DYNX(W_,673) = 293.15;
DYNX(W_,684) = 0.00775;
DYNX(W_,683) = 293.15;
DYNX(W_,681) = 293.15;
DYNX(W_,694) = 0.00775;
DYNX(W_,693) = 293.15;
DYNX(W_,691) = 293.15;
DYNX(W_,704) = 0.00775;
DYNX(W_,703) = 293.15;
DYNX(W_,701) = 293.15;
DYNX(W_,760) = 0.0;
DYNX(W_,759) = 0.0;
DYNX(W_,758) = 0.0;
DYNX(W_,757) = 0.0;
DYNX(W_,731) = 0.0;
DYNX(W_,730) = 293.15;
memcpy(&DYNX(W_,732), &DymArrays26, sizeof(double)*4);
DYNX(W_,778) = 0.0;
DYNX(W_,777) = 293.15;
DYNX(W_,779) = 0.0;
memcpy(&DYNX(W_,768), &DymArrays25, sizeof(double)*3);
memcpy(&DYNX(W_,762), &DymArrays25, sizeof(double)*3);
DYNX(W_,828) = 0.0;
DYNX(W_,788) = 0.0;
DYNX(W_,827) = 0.0;
DYNX(W_,837) = 293.15;
DYNX(W_,1011) = 293.15;
DYNX(W_,818) = 293.15;
DYNX(W_,816) = 293.15;
DYNX(W_,835) = 293.15;
DYNX(W_,834) = 0.0;
DYNX(W_,833) = 293.15;
DYNX(W_,811) = 0.0;
DYNX(W_,810) = 293.15;
DYNX(W_,832) = 293.15;
DYNX(W_,831) = 0.0;
DYNX(W_,830) = 293.15;
DYNX(W_,808) = 0.0;
DYNX(W_,807) = 293.15;
DYNX(W_,805) = 293.15;
DYNX(W_,804) = 293.15;
DYNX(W_,814) = 0.0;
DYNX(W_,813) = 293.15;
memcpy(&DYNX(W_,820), &DymArrays27, sizeof(double)*4);
DYNX(W_,800) = 293.15;
DYNX(W_,802) = 293.15;
DYNX(W_,797) = 0.0;
DYNX(W_,796) = 293.15;
DYNX(W_,795) = 0.0;
DYNX(W_,794) = 293.15;
memcpy(&DYNX(W_,791), &DymArrays4, sizeof(double)*3);
DYNX(W_,799) = 0.0;
DYNX(W_,798) = 293.15;
DYNX(W_,1027) = 65.0;
DYNX(W_,953) = 0.0;
DYNX(W_,955) = 0.0;
DYNX(W_,954) = 0.0;
DYNX(W_,957) = 0.0;
DYNX(W_,956) = 0.0;
DYNX(W_,943) = 0.0;
DYNX(W_,973) = 0.0;
DYNX(W_,972) = 0.0;
DYNX(W_,1028) = 65.0;
DYNX(W_,1029) = 65.0;
DYNX(W_,946) = 0.0;
DYNX(W_,1030) = 65.0;
DYNX(W_,1031) = 65.0;
DYNX(W_,977) = 0.0;
DYNX(W_,979) = 0.0;
DYNX(W_,970) = 0.0;
DYNX(W_,965) = 0.0;
DYNX(W_,964) = 0.0;
DYNX(W_,967) = 0.0;
DYNX(W_,966) = 0.0;
DYNX(W_,969) = 0.0;
DYNX(W_,968) = 0.0;
DYNX(W_,941) = 0.0;
DYNX(W_,938) = 0.0;
DYNX(W_,1032) = 65.0;
DYNX(W_,1033) = 65.0;
DYNX(W_,1005) = 65.0;
DYNX(W_,1007) = 65.0;
memcpy(&DYNX(W_,1000), &DymArrays28, sizeof(double)*4);
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,336) = true;
DYNX(W_,337) = 0;
DYNX(W_,349) = true;
DYNX(W_,350) = 0;
DYNX(W_,362) = true;
DYNX(W_,363) = 0;
DYNX(W_,399) = true;
DYNX(W_,400) = 0;
DYNX(W_,413) = true;
DYNX(W_,414) = 0;
DYNX(W_,427) = true;
DYNX(W_,428) = 0;
DYNX(W_,576) = 0;
DYNX(Y_,1) = 0;
#endif
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,442) = homotopy(IF GreaterS(DYNX(U_,1),"dutyCycle", 1.0,"1.0", 0) THEN 
  1.0 ELSE IF LessS(DYNX(U_,1),"dutyCycle", 0.0,"0.0", 1) THEN 0.0 ELSE 
  DYNX(U_,1), DYNX(U_,1));
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection
DYNX(DYNhelp,0) = fabs(DYNX(X_,3));
DYNX(W_,596) = IF DYNX(DYNhelp,0) > 3.5500000000000003 THEN 0.0003704676056338029
  *(IF DYNX(X_,3) > 0 THEN 1 ELSE IF DYNX(X_,3) < 0 THEN -1 ELSE 0)*
  DYNX(DYNhelp,0) ELSE 0.00037046760563380285*DYNX(X_,3);
DYNX(W_,861) = 2*DYNX(X_,0);
DYNX(W_,875) = sin(DYNX(W_,861));
DYNX(W_,876) = cos(DYNX(W_,861));
DYNX(W_,710) = DYNX(W_,875)*DYNX(X_,1)+DYNX(W_,876)*DYNX(X_,2);
DYNX(W_,873) = DYNX(W_,876);
DYNX(W_,884) = 20284.32289001934+DYNX(X_,1);
DYNX(W_,869) = 2E-06*DYNX(W_,884);
DYNX(W_,874) =  -DYNX(W_,875);
DYNX(W_,870) = 2E-06*DYNX(X_,2);
DYNX(W_,865) = DYNX(W_,873)*DYNX(W_,869)+DYNX(W_,874)*DYNX(W_,870);
DYNX(W_,709) = DYNX(W_,873)*DYNX(X_,1)+DYNX(W_,874)*DYNX(X_,2);
DYNX(W_,866) = DYNX(W_,875)*DYNX(W_,869)+DYNX(W_,876)*DYNX(W_,870);
DYNX(W_,577) = 3.0*(DYNX(W_,710)*DYNX(W_,865)-DYNX(W_,709)*DYNX(W_,866));
DYNX(Y_,1) = DYNX(X_,3);

/* Introducing 1 common subexpressions used in 1 expressions */
/* Of the common subexpressions 1 are reals, 0 are integers, and 0
   are booleans. */
DYNX(DYNhelp,1) = DYNX(W_,710)+1.7320508075688783*DYNX(W_,709);
DYNX(W_,470) = 0.33333333333333326*(2.598076211353316*DYNX(DYNhelp,1)-
  3.0000000000000018*DYNX(W_,709));
DYNX(W_,466) = 0.8660254037844384*(1.1547005383792521*DYNX(W_,470)-
  DYNX(DYNhelp,1));
DYNX(W_,468) = 3.0000000000000018*(DYNX(W_,709)-0.3333333333333336*DYNX(W_,470)+
  0.6666666666666666*DYNX(W_,466));

DYNX(W_,545) = 2*DYNX(X_,0);
DYNX(W_,546) = modulusDymolaEvent(DYNX(W_,545),"drive.machine.angleSensor.coreElement.electricAngle",
   6.283185307179586,"6.283185307179586", 2);
DYNX(W_,79) = GreaterEqual(DYNX(W_,546),"drive.machine.angleSensor.coreElement.electricAngleLim",
   0.5235987755982988,"0.5235987755982988", 3) AND LessEqual(DYNX(W_,546),
  "drive.machine.angleSensor.coreElement.electricAngleLim", 3.665191429188092,
  "3.665191429188092", 4);
DYNX(W_,80) = GreaterEqual(DYNX(W_,546),"drive.machine.angleSensor.coreElement.electricAngleLim",
   1.5707963267948966,"1.5707963267948966", 5) AND LessEqual(DYNX(W_,546),
  "drive.machine.angleSensor.coreElement.electricAngleLim", 4.71238898038469,
  "4.71238898038469", 6);
DYNX(W_,81) = GreaterEqual(DYNX(W_,546),"drive.machine.angleSensor.coreElement.electricAngleLim",
   2.617993877991494,"2.617993877991494", 7) AND LessEqual(DYNX(W_,546),
  "drive.machine.angleSensor.coreElement.electricAngleLim", 5.759586531581287,
  "5.759586531581287", 8);

DYNX(Y_,0) = 0.999999999999984*(DYNX(W_,596)+1.589825119236884E-14*DYNX(U_,2)-
  DYNX(W_,577));
DYNX(F_,3) = 15.89825119236884*(DYNX(U_,2)-DYNX(Y_,0));
DYNX(W_,579) = 1E-15*DYNX(F_,3)-DYNX(W_,577);

DYNX(W_,442) = IF GreaterS(DYNX(U_,1),"dutyCycle", 1.0,"1.0", 0) THEN 1.0 ELSE 
  IF LessS(DYNX(U_,1),"dutyCycle", 0.0,"0.0", 1) THEN 0.0 ELSE DYNX(U_,1);
DYNX(W_,436) = IF DYNX(W_,442) >= 0 THEN DYNX(W_,442) ELSE  -DYNX(W_,442);
DYNX(W_,177) = 65.0*DYNX(W_,436);
DYNX(W_,1034) = IF DYNX(U_,0) THEN 2 ELSE 0.0;
DYNX(W_,78) = Greater(DYNX(W_,1034),"DymolaConvertInputToReal0", 1,"1", 9);
DYNX(W_,77) = PRE(DYNX(W_,77), 0);
DYNX(W_,82) = PRE(DYNX(W_,82), 1);
DYNX(W_,83) = PRE(DYNX(W_,83), 2);
DYNX(W_,84) = PRE(DYNX(W_,84), 3);
  DYNX(W_,76) = 0;
  {
    int i_0_;
    int end_ = DYNSizeSimple(IntegerTemporaryDense( &DYNX(W_,28), 2, 8, 3), 1);
    int row0_0_0;
    for(i_0_ = 0, row0_0_0 = 1;row0_0_0 <= end_;row0_0_0 += 1 , ++i_0_) {
      DYNX(W_,77) = true;
      PopAllMarks();
      {
        int i_1_;
        int end_ = DYNSizeSimple(IntegerTemporaryDense( &DYNX(W_,28), 2, 8, 3), 2);
        int col0_0_0;
        for(i_1_ = 0, col0_0_0 = 1;col0_0_0 <= end_;col0_0_0 += 1 , ++i_1_) {
          DYNX(W_,77) = DYNX(W_,77) AND (Integer)(PushModelContext(2,
            "drive.controller.coreElement.inputTable[row, col]")RealElement( 
            RealTemporaryDense( &DYNX(W_,4), 2, 8, 3), (SizeType)(row0_0_0), 
            (SizeType)(col0_0_0))) == (Integer)(PushModelContext(2,
            "drive.controller.coreElement.u[col]")RealElement( RealTemporaryDense( 
            &DYNX(W_,79), 1, 3), (SizeType)(col0_0_0)));
          PopAllMarks();
        }
      }
      if (DYNX(W_,77)) {
        DYNX(W_,76) = row0_0_0;
      }
    }
  }
  AssertModelica(DYNX(W_,76) > 0,"drive.controller.coreElement.activeRow > 0", 
    "### SixStep controller did not find suitable combinations of inputs in the inputTable ###\n");
  if (DYNX(W_,78)) {
    RealPutSub( RealConvertInteger (IntegerConvertReal((PushModelContext(2,
      "drive.controller.coreElement.outputTableCW[drive.controller.coreElement.activeRow, :]")
      RealGetSub( RealTemporaryDense( &DYNX(W_,28), 2, 8, 3) , Index, (Integer)(
      DYNX(W_,76)) ,Colon  , EndMark)))), RealTemporaryDense( &DYNX(W_,82), 1, 3)
       ,Colon  , EndMark);
    PopAllMarks();
  }
  else{
    RealPutSub( RealConvertInteger (IntegerConvertReal((PushModelContext(2,
      "drive.controller.coreElement.outputTableCCW[drive.controller.coreElement.activeRow, :]")
      RealGetSub( RealTemporaryDense( &DYNX(W_,52), 2, 8, 3) , Index, (Integer)(
      DYNX(W_,76)) ,Colon  , EndMark)))), RealTemporaryDense( &DYNX(W_,82), 1, 3)
       ,Colon  , EndMark);
    PopAllMarks();
  }
DYNX(W_,161) = DYNX(W_,82) == 1 OR DYNX(W_,82) == 3;
DYNX(W_,220) =  NOT DYNX(W_,161);
DYNX(W_,162) = DYNX(W_,82) == 2 OR DYNX(W_,82) == 3;
DYNX(W_,276) =  NOT DYNX(W_,162);

MixedSystemOfEquations(11, DYNX(DYNhelp,2))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[3] */
  /* Introducing 8 common subexpressions used in 9 expressions */
  /* Of the common subexpressions 8 are reals, 0 are integers, and 0
     are booleans. */
  /* Automatic tearing of linear system of 11 simultaneous equations
  gave a linear system of 4 equations for numerical solution.*/
  {
    const char*const varnames_[]={"drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].s",
       "drive.inverter.coreElement.upperDiode.idealDiode[1].s", "drive.inverter.coreElement.lowerDiode.idealDiode[1].s",
       "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].s"};
    const double nominal_[]={1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,13), 64, 
      DYNX(did_->helpvari_vec,0), 12);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,77) = IF DYNX(W_,336) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,78) = IF DYNX(W_,399) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,79) = IF DYNX(W_,220) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,80) = IF DYNX(W_,336) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,81) = IF DYNX(W_,399) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,82) = IF DYNX(W_,276) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,83) =  -DYNX(DYNhelp,78);
      DYNX(DYNhelp,84) = IF DYNX(W_,220) THEN 1 ELSE 1E-05;
      SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,77));
      SetMatrixLeading(J, 1, 3, 4, DYNX(DYNhelp,78));
      SetMatrixLeading(J, 2, 1, 4, DYNX(DYNhelp,79));
      SetMatrixLeading(J, 2, 2, 4, (-1.0)*DYNX(DYNhelp,80));
      SetMatrixLeading(J, 2, 3, 4, DYNX(DYNhelp,81));
      SetMatrixLeading(J, 2, 4, 4, (-1.0)*DYNX(DYNhelp,82));
      SetMatrixLeading(J, 3, 3, 4, DYNX(DYNhelp,83));
      SetMatrixLeading(J, 3, 4, 4,  -(IF DYNX(W_,276) THEN 1 ELSE 1E-05));
      SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,84));
      SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,83));
    }
    SetVector(b, 1,  -DYNX(W_,177));
    SetVector(b, 2,  -DYNX(W_,466));
    SetVector(b, 4, DYNX(W_,177));
    SetVector(y, 1, RememberSimple_(DYNX(W_,221), 0));
    SetVector(y, 2, RememberSimple_(DYNX(W_,337), 1));
    SetVector(y, 3, RememberSimple_(DYNX(W_,400), 2));
    SetVector(y, 4, RememberSimple_(DYNX(W_,277), 3));
    SolveLinearSystemOfEquationsMixed(J, b, y, 3, "simulation.linear[3]");
    DYNX(W_,221) = GetVector(y, 1);
    DYNX(W_,337) = GetVector(y, 2);
    DYNX(W_,400) = GetVector(y, 3);
    DYNX(W_,277) = GetVector(y, 4);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,196) = DYNX(W_,221)*DYNX(DYNhelp,79);
  DYNX(W_,327) = DYNX(W_,337)*DYNX(DYNhelp,77);
  DYNX(W_,308) = DYNX(W_,337)*DYNX(DYNhelp,80);
  DYNX(W_,367) = DYNX(W_,400)*DYNX(DYNhelp,81);
  DYNX(W_,249) = DYNX(W_,277)*DYNX(DYNhelp,82);
  DYNX(W_,465) =  -DYNX(W_,400)*DYNX(DYNhelp,78);
  DYNX(W_,212) = DYNX(W_,221)*DYNX(DYNhelp,84);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,336),"drive.inverter.coreElement.upperDiode.idealDiode[1].off",
     Less(DYNX(W_,337),"drive.inverter.coreElement.upperDiode.idealDiode[1].s", 0,
    "0", 10));
  UpdateVariableNamed(DYNX(W_,399),"drive.inverter.coreElement.lowerDiode.idealDiode[1].off",
     Less(DYNX(W_,400),"drive.inverter.coreElement.lowerDiode.idealDiode[1].s", 0,
    "0", 11));
  MixedModeInit(2, DYNX(DYNhelp,85))
  ThetaMixedCross(0,10)
  ThetaMixedCross(1,11)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,212), 1)
  UpdateReal(DYNX(W_,221), 2)
  UpdateReal(DYNX(W_,196), 3)
  UpdateReal(DYNX(W_,400), 4)
  UpdateReal(DYNX(W_,367), 5)
  UpdateReal(DYNX(W_,249), 6)
  UpdateReal(DYNX(W_,277), 7)
  UpdateReal(DYNX(W_,465), 8)
  UpdateReal(DYNX(W_,327), 9)
  UpdateReal(DYNX(W_,337), 10)
  UpdateReal(DYNX(W_,308), 11)
EndMixedSystemOfEquations

DYNX(W_,178) = DYNX(W_,308)-DYNX(W_,196);
DYNX(W_,163) = DYNX(W_,83) == 1 OR DYNX(W_,83) == 3;
DYNX(W_,232) =  NOT DYNX(W_,163);
DYNX(W_,164) = DYNX(W_,83) == 2 OR DYNX(W_,83) == 3;
DYNX(W_,288) =  NOT DYNX(W_,164);

MixedSystemOfEquations(11, DYNX(DYNhelp,87))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[4] */
  /* Introducing 8 common subexpressions used in 9 expressions */
  /* Of the common subexpressions 8 are reals, 0 are integers, and 0
     are booleans. */
  /* Automatic tearing of linear system of 11 simultaneous equations
  gave a linear system of 4 equations for numerical solution.*/
  {
    const char*const varnames_[]={"drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].s",
       "drive.inverter.coreElement.upperDiode.idealDiode[2].s", "drive.inverter.coreElement.lowerDiode.idealDiode[2].s",
       "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].s"};
    const double nominal_[]={1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,98), 64, 
      DYNX(did_->helpvari_vec,12), 12);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,162) = IF DYNX(W_,349) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,163) = IF DYNX(W_,413) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,164) = IF DYNX(W_,232) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,165) = IF DYNX(W_,349) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,166) = IF DYNX(W_,413) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,167) = IF DYNX(W_,288) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,168) =  -DYNX(DYNhelp,163);
      DYNX(DYNhelp,169) = IF DYNX(W_,232) THEN 1 ELSE 1E-05;
      SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,162));
      SetMatrixLeading(J, 1, 3, 4, DYNX(DYNhelp,163));
      SetMatrixLeading(J, 2, 1, 4, DYNX(DYNhelp,164));
      SetMatrixLeading(J, 2, 2, 4, (-1.0)*DYNX(DYNhelp,165));
      SetMatrixLeading(J, 2, 3, 4, DYNX(DYNhelp,166));
      SetMatrixLeading(J, 2, 4, 4, (-1.0)*DYNX(DYNhelp,167));
      SetMatrixLeading(J, 3, 3, 4, DYNX(DYNhelp,168));
      SetMatrixLeading(J, 3, 4, 4,  -(IF DYNX(W_,288) THEN 1 ELSE 1E-05));
      SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,169));
      SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,168));
    }
    SetVector(b, 1,  -DYNX(W_,177));
    SetVector(b, 2,  -DYNX(W_,468));
    SetVector(b, 4, DYNX(W_,177));
    SetVector(y, 1, RememberSimple_(DYNX(W_,233), 4));
    SetVector(y, 2, RememberSimple_(DYNX(W_,350), 5));
    SetVector(y, 3, RememberSimple_(DYNX(W_,414), 6));
    SetVector(y, 4, RememberSimple_(DYNX(W_,289), 7));
    SolveLinearSystemOfEquationsMixed(J, b, y, 4, "simulation.linear[4]");
    DYNX(W_,233) = GetVector(y, 1);
    DYNX(W_,350) = GetVector(y, 2);
    DYNX(W_,414) = GetVector(y, 3);
    DYNX(W_,289) = GetVector(y, 4);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,197) = DYNX(W_,233)*DYNX(DYNhelp,164);
  DYNX(W_,340) = DYNX(W_,350)*DYNX(DYNhelp,162);
  DYNX(W_,309) = DYNX(W_,350)*DYNX(DYNhelp,165);
  DYNX(W_,368) = DYNX(W_,414)*DYNX(DYNhelp,166);
  DYNX(W_,250) = DYNX(W_,289)*DYNX(DYNhelp,167);
  DYNX(W_,467) =  -DYNX(W_,414)*DYNX(DYNhelp,163);
  DYNX(W_,224) = DYNX(W_,233)*DYNX(DYNhelp,169);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,349),"drive.inverter.coreElement.upperDiode.idealDiode[2].off",
     Less(DYNX(W_,350),"drive.inverter.coreElement.upperDiode.idealDiode[2].s", 0,
    "0", 12));
  UpdateVariableNamed(DYNX(W_,413),"drive.inverter.coreElement.lowerDiode.idealDiode[2].off",
     Less(DYNX(W_,414),"drive.inverter.coreElement.lowerDiode.idealDiode[2].s", 0,
    "0", 13));
  MixedModeInit(2, DYNX(DYNhelp,170))
  ThetaMixedCross(0,12)
  ThetaMixedCross(1,13)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,224), 1)
  UpdateReal(DYNX(W_,233), 2)
  UpdateReal(DYNX(W_,197), 3)
  UpdateReal(DYNX(W_,414), 4)
  UpdateReal(DYNX(W_,368), 5)
  UpdateReal(DYNX(W_,250), 6)
  UpdateReal(DYNX(W_,289), 7)
  UpdateReal(DYNX(W_,467), 8)
  UpdateReal(DYNX(W_,340), 9)
  UpdateReal(DYNX(W_,350), 10)
  UpdateReal(DYNX(W_,309), 11)
EndMixedSystemOfEquations

DYNX(W_,179) = DYNX(W_,309)-DYNX(W_,197);
BreakSectionFunctionEnd()
BreakSectionFunctionStart(3);
DYNX(W_,165) = DYNX(W_,84) == 1 OR DYNX(W_,84) == 3;
DYNX(W_,244) =  NOT DYNX(W_,165);
DYNX(W_,166) = DYNX(W_,84) == 2 OR DYNX(W_,84) == 3;
DYNX(W_,300) =  NOT DYNX(W_,166);

MixedSystemOfEquations(11, DYNX(DYNhelp,172))

   /* Linear system of equations to solve. */
  /* Tag: simulation.linear[5] */
  /* Introducing 8 common subexpressions used in 9 expressions */
  /* Of the common subexpressions 8 are reals, 0 are integers, and 0
     are booleans. */
  /* Automatic tearing of linear system of 11 simultaneous equations
  gave a linear system of 4 equations for numerical solution.*/
  {
    const char*const varnames_[]={"drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].s",
       "drive.inverter.coreElement.upperDiode.idealDiode[3].s", "drive.inverter.coreElement.lowerDiode.idealDiode[3].s",
       "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].s"};
    const double nominal_[]={1, 1, 1, 1};
    DidLinearSystemOfEquations(J, b, y, 4, DYNX(DYNhelp,183), 64, 
      DYNX(did_->helpvari_vec,24), 12);
    /* Jacobian depending on discrete variables */
    /* Special case for simplified event handling */
    #if defined(EventIterate_) && (EventIterate_==0)
    SetNeedFactor(J);
    #else
    if (NewParametersJac||DYNEvent|| dymolaEventsNr_!=*(factoredForEventsP_))
       SetNeedFactor(J);
    #endif
    if (NeedFactor(J)) {
      *(factoredForEventsP_)=dymolaEventsNr_;
      MatrixZeros(J);
      DYNX(DYNhelp,247) = IF DYNX(W_,362) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,248) = IF DYNX(W_,427) THEN 1 ELSE 1E-05;
      DYNX(DYNhelp,249) = IF DYNX(W_,244) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,250) = IF DYNX(W_,362) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,251) = IF DYNX(W_,427) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,252) = IF DYNX(W_,300) THEN 1E-05 ELSE 1;
      DYNX(DYNhelp,253) =  -DYNX(DYNhelp,248);
      DYNX(DYNhelp,254) = IF DYNX(W_,244) THEN 1 ELSE 1E-05;
      SetMatrixLeading(J, 1, 2, 4, DYNX(DYNhelp,247));
      SetMatrixLeading(J, 1, 3, 4, DYNX(DYNhelp,248));
      SetMatrixLeading(J, 2, 1, 4, DYNX(DYNhelp,249));
      SetMatrixLeading(J, 2, 2, 4, (-1.0)*DYNX(DYNhelp,250));
      SetMatrixLeading(J, 2, 3, 4, DYNX(DYNhelp,251));
      SetMatrixLeading(J, 2, 4, 4, (-1.0)*DYNX(DYNhelp,252));
      SetMatrixLeading(J, 3, 3, 4, DYNX(DYNhelp,253));
      SetMatrixLeading(J, 3, 4, 4,  -(IF DYNX(W_,300) THEN 1 ELSE 1E-05));
      SetMatrixLeading(J, 4, 1, 4, DYNX(DYNhelp,254));
      SetMatrixLeading(J, 4, 3, 4, DYNX(DYNhelp,253));
    }
    SetVector(b, 1,  -DYNX(W_,177));
    SetVector(b, 2,  -DYNX(W_,470));
    SetVector(b, 4, DYNX(W_,177));
    SetVector(y, 1, RememberSimple_(DYNX(W_,245), 8));
    SetVector(y, 2, RememberSimple_(DYNX(W_,363), 9));
    SetVector(y, 3, RememberSimple_(DYNX(W_,428), 10));
    SetVector(y, 4, RememberSimple_(DYNX(W_,301), 11));
    SolveLinearSystemOfEquationsMixed(J, b, y, 5, "simulation.linear[5]");
    DYNX(W_,245) = GetVector(y, 1);
    DYNX(W_,363) = GetVector(y, 2);
    DYNX(W_,428) = GetVector(y, 3);
    DYNX(W_,301) = GetVector(y, 4);
    EndStaticLinearSystemOfEquations(J);
  }
  DYNX(W_,198) = DYNX(W_,245)*DYNX(DYNhelp,249);
  DYNX(W_,353) = DYNX(W_,363)*DYNX(DYNhelp,247);
  DYNX(W_,310) = DYNX(W_,363)*DYNX(DYNhelp,250);
  DYNX(W_,369) = DYNX(W_,428)*DYNX(DYNhelp,251);
  DYNX(W_,251) = DYNX(W_,301)*DYNX(DYNhelp,252);
  DYNX(W_,469) =  -DYNX(W_,428)*DYNX(DYNhelp,248);
  DYNX(W_,236) = DYNX(W_,245)*DYNX(DYNhelp,254);
   /* End of Equation Block */ 


  MixedModeStartBoolean
  UpdateVariableNamed(DYNX(W_,362),"drive.inverter.coreElement.upperDiode.idealDiode[3].off",
     Less(DYNX(W_,363),"drive.inverter.coreElement.upperDiode.idealDiode[3].s", 0,
    "0", 14));
  UpdateVariableNamed(DYNX(W_,427),"drive.inverter.coreElement.lowerDiode.idealDiode[3].off",
     Less(DYNX(W_,428),"drive.inverter.coreElement.lowerDiode.idealDiode[3].s", 0,
    "0", 15));
  MixedModeInit(2, DYNX(DYNhelp,255))
  ThetaMixedCross(0,14)
  ThetaMixedCross(1,15)
  MixedModeEndBoolean
  UpdateReal(DYNX(W_,236), 1)
  UpdateReal(DYNX(W_,245), 2)
  UpdateReal(DYNX(W_,198), 3)
  UpdateReal(DYNX(W_,428), 4)
  UpdateReal(DYNX(W_,369), 5)
  UpdateReal(DYNX(W_,251), 6)
  UpdateReal(DYNX(W_,301), 7)
  UpdateReal(DYNX(W_,469), 8)
  UpdateReal(DYNX(W_,353), 9)
  UpdateReal(DYNX(W_,363), 10)
  UpdateReal(DYNX(W_,310), 11)
EndMixedSystemOfEquations

DYNX(W_,180) = DYNX(W_,310)-DYNX(W_,198);
DYNX(W_,181) =  -(DYNX(W_,178)+DYNX(W_,179)+DYNX(W_,180));
DYNX(Y_,3) =  -DYNX(W_,436)*DYNX(W_,181);
DYNX(W_,999) =  -DYNX(Y_,3);
DYNX(W_,1013) =  -DYNX(W_,577);
DYNX(W_,1014) =  -DYNX(W_,466);
DYNX(W_,1015) =  -DYNX(W_,468);
DYNX(W_,1016) =  -DYNX(W_,470);
DYNX(W_,987) =  -DYNX(Y_,0);
DYNX(W_,432) =  -DYNX(W_,181);
DYNX(W_,391) =  -DYNX(W_,367);
DYNX(W_,389) =  -DYNX(W_,465);
DYNX(W_,405) =  -DYNX(W_,368);
DYNX(W_,403) =  -DYNX(W_,467);
DYNX(W_,419) =  -DYNX(W_,369);
DYNX(W_,417) =  -DYNX(W_,469);
DYNX(W_,269) =  -DYNX(W_,249);
DYNX(W_,281) =  -DYNX(W_,250);
DYNX(W_,293) =  -DYNX(W_,251);
DYNX(W_,328) =  -DYNX(W_,308);
DYNX(W_,341) =  -DYNX(W_,309);
DYNX(W_,354) =  -DYNX(W_,310);
DYNX(W_,213) =  -DYNX(W_,196);
DYNX(W_,225) =  -DYNX(W_,197);
DYNX(W_,237) =  -DYNX(W_,198);
DYNX(W_,598) =  -DYNX(W_,596);
DYNX(W_,711) =  -DYNX(W_,709);
DYNX(W_,712) =  -DYNX(W_,710);
DYNX(W_,990) = DYNX(Y_,1);
DYNX(W_,1017) = DYNX(Y_,1);
DYNX(W_,576) = DYNX(Y_,1);
DYNX(W_,578) = DYNX(Y_,0);

DynamicsSection
DYNX(F_,0) = DYNX(X_,3);
DYNX(W_,678) = (-0.00775)*DYNX(W_,466);
DYNX(W_,652) = DYNX(W_,465)-DYNX(W_,678);
DYNX(W_,688) = (-0.00775)*DYNX(W_,468);
DYNX(W_,653) = DYNX(W_,467)-DYNX(W_,688);
DYNX(W_,698) = (-0.00775)*DYNX(W_,470);
DYNX(W_,654) = DYNX(W_,469)-DYNX(W_,698);
DYNX(W_,741) = (-0.3333333333333333)*(DYNX(W_,654)-2*DYNX(W_,653)+DYNX(W_,652));
DYNX(W_,645) = DYNX(W_,653)-DYNX(W_,741);
DYNX(W_,740) = DYNX(W_,652)-DYNX(W_,645);
DYNX(W_,742) = DYNX(W_,654)-DYNX(W_,645);
DYNX(W_,867) = 0.6666666666666666*DYNX(W_,740)-0.33333333333333315*DYNX(W_,741)-
  0.3333333333333336*DYNX(W_,742);
DYNX(W_,862) = 2*DYNX(X_,3);
DYNX(W_,877) =  -DYNX(W_,862)*DYNX(W_,875);
DYNX(W_,878) =  -DYNX(W_,862)*DYNX(W_,876);
DYNX(W_,868) = 0.5773502691896257*DYNX(W_,741)-0.5773502691896256*DYNX(W_,742);
DYNX(W_,879) = DYNX(W_,862)*DYNX(W_,876);
DYNX(W_,880) =  -DYNX(W_,862)*DYNX(W_,875);

 /* Linear system of equations to solve. */
/* Tag: simulation.linear[6] */
{
const char*const varnames_[]={"drive.machine.coreElement.airGap.der(psi_mr[2])",
   "drive.machine.coreElement.airGap.der(psi_mr[1])"};
const double nominal_[]={1, 1};
DYNX(W_,872)=RememberSimple_(DYNX(W_,872), 12);
DYNX(W_,871)=RememberSimple_(DYNX(W_,871), 13);
SolveLinear2by2( -DYNX(W_,874),  -DYNX(W_,873), 
 -DYNX(W_,876),  -DYNX(W_,875), 
DYNX(W_,877)*DYNX(W_,869)+DYNX(W_,878)*DYNX(W_,870)-DYNX(W_,867), DYNX(W_,879)*
  DYNX(W_,869)+DYNX(W_,880)*DYNX(W_,870)-DYNX(W_,868), &DYNX(W_,872), &
  DYNX(W_,871), 
varnames_, (DSE_STRUCT QiErr), "simulation.linear[6]");
if (*(DSE_STRUCT QiErr)!=0) {goto leave;}
}
 /* End of Equation Block */ 

DYNX(F_,1) = 500000.0*DYNX(W_,871);
DYNX(F_,2) = 500000.0*DYNX(W_,872);
DYNX(W_,1004) = DYNX(F_,0);

AcceptedSection1

AcceptedSection2
DYNX(W_,185) = DYNX(W_,249)-DYNX(W_,367);
DYNX(W_,187) = DYNX(W_,250)-DYNX(W_,368);
DYNX(W_,189) = DYNX(W_,251)-DYNX(W_,369);
DYNX(W_,191) =  -(DYNX(W_,185)+DYNX(W_,187)+DYNX(W_,189));
DYNX(W_,170) = DYNX(W_,181)+DYNX(Y_,3)+DYNX(W_,191);
DYNX(W_,193) = DYNX(W_,177)-DYNX(W_,465);
DYNX(W_,194) = DYNX(W_,177)-DYNX(W_,467);
DYNX(W_,195) = DYNX(W_,177)-DYNX(W_,469);
DYNX(W_,218) = DYNX(W_,212)*DYNX(W_,196);
DYNX(W_,230) = DYNX(W_,224)*DYNX(W_,197);
DYNX(W_,242) = DYNX(W_,236)*DYNX(W_,198);
DYNX(W_,274) = DYNX(W_,465)*DYNX(W_,249);
DYNX(W_,286) = DYNX(W_,467)*DYNX(W_,250);
DYNX(W_,298) = DYNX(W_,469)*DYNX(W_,251);
DYNX(W_,305) = DYNX(W_,465)-DYNX(W_,177);
DYNX(W_,306) = DYNX(W_,467)-DYNX(W_,177);
DYNX(W_,307) = DYNX(W_,469)-DYNX(W_,177);
DYNX(W_,334) = DYNX(W_,327)*DYNX(W_,308);
DYNX(W_,347) = DYNX(W_,340)*DYNX(W_,309);
DYNX(W_,360) = DYNX(W_,353)*DYNX(W_,310);
DYNX(W_,397) =  -DYNX(W_,465)*DYNX(W_,367);
DYNX(W_,411) =  -DYNX(W_,467)*DYNX(W_,368);
DYNX(W_,425) =  -DYNX(W_,469)*DYNX(W_,369);
DYNX(W_,483) = DYNX(Y_,0)*DYNX(X_,3);
{
  RealAssign(RealTemporaryDense(&(DYNX(DYNhelp,257)), 1, 2), (PushModelContext(1,
    "Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({drive.inverter.plug.pin[1].v, drive.inverter.plug.pin[2].v, drive.inverter.plug.pin[3].v})")
    Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(
    RealScalarArray ( 3, DYNX(W_,465), DYNX(W_,467), DYNX(W_,469))).y0_0_0member));
}
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,958), 1, 2), RealTemporaryDense(&(
  DYNX(DYNhelp,257)), 1, 2));
PopAllMarks();
{
  RealAssign(RealTemporaryDense(&(DYNX(DYNhelp,259)), 1, 2), (PushModelContext(1,
    "Modelica.Electrical.Machines.SpacePhasors.Functions.ToSpacePhasor({ -drive.inverter.plug.pin[1].i,  -drive.inverter.plug.pin[2].i,  -drive.inverter.plug.pin[3].i})")
    Modelica_Electrical_Machines_SpacePhasors_Functions_ToSpacePhasor(
    RealScalarArray ( 3,  -DYNX(W_,466),  -DYNX(W_,468),  -DYNX(W_,470))).
    y0_0_0member));
}
PopAllMarks();
RealAssign (RealTemporaryDense( &DYNX(W_,960), 1, 2), RealTemporaryDense(&(
  DYNX(DYNhelp,259)), 1, 2));
PopAllMarks();
DYNX(W_,518) = 1.5*(DYNX(W_,958)*DYNX(W_,960)+DYNX(W_,959)*DYNX(W_,961));
DYNX(W_,931) = DYNX(W_,577)+DYNX(W_,579);
DYNX(W_,930) = DYNX(W_,931)-DYNX(Y_,0);
DYNX(W_,519) =  -DYNX(X_,3)*DYNX(W_,930);
DYNX(W_,521) = 1E-15*DYNX(F_,3)*DYNX(X_,3);
DYNX(W_,682) =  -DYNX(W_,678)*DYNX(W_,466);
DYNX(W_,692) =  -DYNX(W_,688)*DYNX(W_,468);
DYNX(W_,702) =  -DYNX(W_,698)*DYNX(W_,470);
DYNX(W_,524) = DYNX(W_,596)*DYNX(X_,3);
DYNX(W_,522) = DYNX(W_,682)+DYNX(W_,692)+DYNX(W_,702)+DYNX(W_,524);
DYNX(W_,523) = DYNX(W_,682)+DYNX(W_,692)+DYNX(W_,702);
DYNX(W_,595) = DYNX(W_,596)-DYNX(W_,577);
DYNX(W_,634) = DYNX(W_,465)-DYNX(W_,645);
DYNX(W_,635) = DYNX(W_,467)-DYNX(W_,645);
DYNX(W_,636) = DYNX(W_,469)-DYNX(W_,645);
DYNX(W_,623) = (PushModelContext(1,"Modelica.Electrical.Machines.SpacePhasors.Functions.activePower({drive.machine.coreElement.vs[1], drive.machine.coreElement.vs[2], drive.machine.coreElement.vs[3]}, { -drive.inverter.plug.pin[1].i,  -drive.inverter.plug.pin[2].i,  -drive.inverter.plug.pin[3].i})")
  Modelica_Electrical_Machines_SpacePhasors_Functions_activePower(
  RealTemporaryDense( &DYNX(W_,634), 1, 3), RealScalarArray ( 3,  -DYNX(W_,466),
    -DYNX(W_,468),  -DYNX(W_,470))));
PopAllMarks();
DYNX(W_,624) =  -DYNX(X_,3)*DYNX(Y_,0);
DYNX(W_,626) = 1E-15*DYNX(F_,3)*DYNX(X_,3);
DYNX(W_,628) = DYNX(W_,682)+DYNX(W_,692)+DYNX(W_,702);
DYNX(W_,627) = DYNX(W_,628)+DYNX(W_,524);
DYNX(W_,639) = 20284.32289001934*DYNX(W_,873);
DYNX(W_,640) = 20284.32289001934*DYNX(W_,875);
DYNX(W_,647) = DYNX(W_,465)-DYNX(W_,652);
DYNX(W_,648) = DYNX(W_,467)-DYNX(W_,653);
DYNX(W_,649) = DYNX(W_,469)-DYNX(W_,654);
DYNX(W_,780) = sqrtGuarded(0.3333333333333333*(sqr(DYNX(W_,466))+sqr(
  DYNX(W_,468))+sqr(DYNX(W_,470))),"0.3333333333333333*(drive.inverter.plug.pin[1].i^2+drive.inverter.plug.pin[2].i^2+drive.inverter.plug.pin[3].i^2)");
DYNX(W_,786) = DYNX(W_,682)+DYNX(W_,692)+DYNX(W_,702);
DYNX(W_,829) = DYNX(W_,786)+DYNX(W_,524);
DYNX(W_,927) = DYNX(W_,780);
DYNX(W_,948) = 1.5*(DYNX(W_,959)*DYNX(W_,960)-DYNX(W_,958)*DYNX(W_,961));
DYNX(W_,984) = DYNX(Y_,3)-DYNX(W_,170);
DYNX(W_,992) =  -DYNX(U_,2)*DYNX(X_,3);
DYNX(W_,608) =  -DYNX(W_,524);
DYNX(W_,670) =  -DYNX(W_,682);
DYNX(W_,672) =  -DYNX(W_,692);
DYNX(W_,674) =  -DYNX(W_,702);
DYNX(W_,824) =  -DYNX(W_,786);
DYNX(W_,976) =  -DYNX(W_,930);
DYNX(W_,991) =  -DYNX(U_,2);
DYNX(W_,975) = DYNX(W_,976);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareVariable("drive.controller.m", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("drive.controller.useDirectionInput", "[:#(type=Boolean)]", true,\
 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.rotateCW", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,515)
DeclareAlias2("drive.controller.rotateCW_In", "[:#(type=Boolean)]", \
"drive.controller.coreElement.rotateCW", 1, 5, 78, 65)
DeclareAlias2("drive.controller.dutyCycleOut", "Connector of Real output signal [1]",\
 "dutyCycle", 1, 2, 1, 0)
DeclareVariable("drive.controller.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.inputTable[1, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[1, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[1, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[2, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[2, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[2, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[3, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[3, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[3, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[4, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[4, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[4, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[5, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[5, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[5, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[6, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[6, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[6, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[7, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[7, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[7, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[8, 1]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[8, 2]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.inputTable[8, 3]", \
"Values from the Hall sensors, last two should not occur [:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.coreElement.outputTableCW[1, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[1, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[1, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[2, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[2, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[2, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[3, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[3, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[3, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[4, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[4, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[4, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[5, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[5, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[5, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[6, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[6, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[6, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[7, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[7, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[7, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[8, 1]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[8, 2]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCW[8, 3]", \
"Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[1, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[1, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[1, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[2, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[2, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[2, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[3, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[3, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[3, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[4, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[4, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[4, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[5, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[5, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[5, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[6, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[6, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[6, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[7, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[7, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[7, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[8, 1]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[8, 2]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.outputTableCCW[8, 3]", \
"Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.coreElement.activeRow", "Row in 'inputTable' which was provided by the sensor, 'outputTable' is chosen accordingly [:#(type=Integer)]",\
 0, 0.0,0.0,0.0,0,644)
DeclareVariable("drive.controller.coreElement.same", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.controller.coreElement.rotateCW", "[:#(type=Boolean)]", \
false, 0.0,0.0,0.0,0,642)
DeclareVariable("drive.controller.coreElement.u[1]", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,642)
DeclareVariable("drive.controller.coreElement.u[2]", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,642)
DeclareVariable("drive.controller.coreElement.u[3]", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,642)
DeclareVariable("drive.controller.coreElement.halfBridgeOutput[1]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]", 1, 1.0,4.0,\
0.0,0,644)
DeclareVariable("drive.controller.coreElement.halfBridgeOutput[2]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]", 1, 1.0,4.0,\
0.0,0,644)
DeclareVariable("drive.controller.coreElement.halfBridgeOutput[3]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]", 1, 1.0,4.0,\
0.0,0,644)
DeclareAlias2("drive.controller.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 0)
DeclareVariable("drive.controller.hallSensorOutput.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.controller.hallSensorOutput.u[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 79, 65)
DeclareAlias2("drive.controller.hallSensorOutput.u[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 80, 65)
DeclareAlias2("drive.controller.hallSensorOutput.u[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 81, 65)
DeclareVariable("drive.controller.data.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.controller.data.inputTable[1, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[1, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[1, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[2, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[2, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[2, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[3, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[3, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[3, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[4, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[4, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[4, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[5, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[5, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[5, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[6, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[6, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[6, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[7, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[7, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[7, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[8, 1]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[8, 2]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.inputTable[8, 3]", "Values from the Hall sensors, last two should not occur [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.controller.data.outputTableCW[1, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[1, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[1, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[2, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[2, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[2, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[3, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[3, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[3, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[4, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[4, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[4, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[5, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[5, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[5, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[6, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[6, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[6, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[7, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[7, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[7, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[8, 1]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[8, 2]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCW[8, 3]", "Values for inverter switch control for clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[1, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[1, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[1, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[2, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[2, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[2, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[3, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[3, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[3, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[4, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[4, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[4, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[5, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[5, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[5, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[6, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[6, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 1, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[6, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[7, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[7, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[7, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[8, 1]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[8, 2]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareVariable("drive.controller.data.outputTableCCW[8, 3]", "Values for inverter switch control for counter-clockwise direction [:#(type=BrushlessDCDrives.Common.Types.HalfBridgeStatus)]",\
 4, 1.0,4.0,0.0,0,517)
DeclareAlias2("drive.controller.halfBridgeOutput[1]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]",\
 "drive.controller.coreElement.halfBridgeOutput[1]", 1, 5, 82, 66)
DeclareAlias2("drive.controller.halfBridgeOutput[2]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]",\
 "drive.controller.coreElement.halfBridgeOutput[2]", 1, 5, 83, 66)
DeclareAlias2("drive.controller.halfBridgeOutput[3]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeOutput)]",\
 "drive.controller.coreElement.halfBridgeOutput[3]", 1, 5, 84, 66)
DeclareVariable("drive.modulation.m", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareAlias2("drive.modulation.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 0)
DeclareVariable("drive.modulation.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.modulation.coreElement.halfBridgeInput[1]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]", \
"drive.controller.coreElement.halfBridgeOutput[1]", 1, 5, 82, 66)
DeclareAlias2("drive.modulation.coreElement.halfBridgeInput[2]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]", \
"drive.controller.coreElement.halfBridgeOutput[2]", 1, 5, 83, 66)
DeclareAlias2("drive.modulation.coreElement.halfBridgeInput[3]", \
"[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]", \
"drive.controller.coreElement.halfBridgeOutput[3]", 1, 5, 84, 66)
DeclareAlias2("drive.modulation.coreElement.y[1, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[1, 1]", 1, 5, 161, 65)
DeclareAlias2("drive.modulation.coreElement.y[1, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[1, 2]", 1, 5, 162, 65)
DeclareAlias2("drive.modulation.coreElement.y[2, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[2, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.modulation.coreElement.y[2, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[2, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.modulation.coreElement.y[3, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[3, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.modulation.coreElement.y[3, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[3, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.modulation.coreElement.dutyCycleOut", "Connector of Real output signal [1]",\
 "dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.modulation.coreElement.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.modulation.dutyCycleOut", "Connector of Real output signal [1]",\
 "dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.modulation.halfBridgeInput[1]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]",\
 "drive.controller.coreElement.halfBridgeOutput[1]", 1, 5, 82, 66)
DeclareAlias2("drive.modulation.halfBridgeInput[2]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]",\
 "drive.controller.coreElement.halfBridgeOutput[2]", 1, 5, 83, 66)
DeclareAlias2("drive.modulation.halfBridgeInput[3]", "[:#(type=BrushlessDCDrives.Common.Interfaces.HalfBridgeInput)]",\
 "drive.controller.coreElement.halfBridgeOutput[3]", 1, 5, 84, 66)
DeclareVariable("drive.modulation.y[1, 1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[1, 2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[2, 1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[2, 2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[3, 1]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareVariable("drive.modulation.y[3, 2]", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,642)
DeclareAlias2("drive.modulation.dutyCycle.u", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 0)
DeclareVariable("drive.inverter.m", "Number of phases [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("drive.inverter.pin_p.v", "Potential at the pin [V]", 65.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.pin_p.i", "Current flowing into the pin [A]", \
"batteryPack.n.i", 1, 5, 999, 132)
DeclareVariable("drive.inverter.pin_n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.pin_n.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.bidirectional", "Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.inverter.coreElement.Ron", "Closed switch resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.Goff", "Opened switch conductance [S]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.star_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.pin[1].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.star_p.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.pin[2].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.star_p.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareVariable("drive.inverter.coreElement.star_p.plug_p.pin[3].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.star_p.pin_n.v", "Potential at the pin [V]",\
 "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1, 5, 177, 4)
DeclareVariable("drive.inverter.coreElement.star_p.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.star_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[1].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[2].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.star_n.plug_p.pin[3].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.star_n.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.star_n.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.coreElement.upperSwitch.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.upperSwitch.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[1]", 1,\
 5, 196, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[2]", 1,\
 5, 197, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[3]", 1,\
 5, 198, 132)
DeclareVariable("drive.inverter.coreElement.upperSwitch.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].n.i", 1,\
 5, 213, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].n.i", 1,\
 5, 225, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].n.i", 1,\
 5, 237, 132)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Ron[1]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Ron[2]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Ron[3]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Goff[1]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Goff[2]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.Goff[3]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.upperSwitch.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperSwitch.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.control[1]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[1, 1]", 1, 5, 161, 65)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.control[2]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[2, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.control[3]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[3, 1]", 1, 5, 165, 65)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].v",\
 "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].p.v",\
 "Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[1]", 1,\
 5, 196, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].n.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].n.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperSwitch.i[1]", 1,\
 5, 196, 0)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[1].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[1, 1]", 1, 5, 161, 65)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].v",\
 "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].p.v",\
 "Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[2]", 1,\
 5, 197, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].n.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].n.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperSwitch.i[2]", 1,\
 5, 197, 0)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[2].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[2, 1]", 1, 5, 163, 65)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].v",\
 "Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].p.v",\
 "Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.upperSwitch.i[3]", 1,\
 5, 198, 132)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].n.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].n.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperSwitch.i[3]", 1,\
 5, 198, 0)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.upperSwitch.idealClosingSwitch[3].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[3, 1]", 1, 5, 165, 65)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 0)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[1]", 1,\
 5, 249, 132)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[2]", 1,\
 5, 250, 132)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[3]", 1,\
 5, 251, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_n.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].n.i", 1,\
 5, 269, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_n.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].n.i", 1,\
 5, 281, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.plug_n.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].n.i", 1,\
 5, 293, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Ron[1]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Ron[2]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Ron[3]", \
"Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Goff[1]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Goff[2]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.Goff[3]", \
"Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.control[1]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[1, 2]", 1, 5, 162, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.control[2]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[2, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.control[3]", \
"true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[3, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[1].v", 1,\
 5, 465, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].p.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[1]", 1,\
 5, 249, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].n.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerSwitch.i[1]", 1,\
 5, 249, 0)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[1].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[1, 2]", 1, 5, 162, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[2].v", 1,\
 5, 467, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].p.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[2]", 1,\
 5, 250, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].n.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerSwitch.i[2]", 1,\
 5, 250, 0)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[2].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[2, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", "drive.inverter.plug.pin[3].v", 1,\
 5, 469, 0)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].p.v",\
 "Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].p.i",\
 "Current flowing into the pin [A]", "drive.inverter.coreElement.lowerSwitch.i[3]", 1,\
 5, 251, 132)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].n.v",\
 "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].n.i",\
 "Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerSwitch.i[3]", 1,\
 5, 251, 0)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].Ron",\
 "Closed switch resistance [Ohm]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].Goff",\
 "Opened switch conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].T",\
 "Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].off",\
 "Indicates off-state [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2690)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].s",\
 "Auxiliary variable [1]", 0.0, 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareAlias2("drive.inverter.coreElement.lowerSwitch.idealClosingSwitch[3].control",\
 "true => p--n connected, false => switch open [:#(type=Boolean)]", \
"drive.modulation.y[3, 2]", 1, 5, 166, 65)
DeclareVariable("drive.inverter.coreElement.upperDiode.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.upperDiode.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[1]", 1,\
 5, 308, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[2]", 1,\
 5, 309, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[3]", 1,\
 5, 310, 132)
DeclareVariable("drive.inverter.coreElement.upperDiode.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.idealDiode[1].n.i", 1,\
 5, 328, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.idealDiode[2].n.i", 1,\
 5, 341, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.idealDiode[3].n.i", 1,\
 5, 354, 132)
DeclareVariable("drive.inverter.coreElement.upperDiode.Ron[1]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Ron[2]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Ron[3]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Goff[1]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Goff[2]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Goff[3]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Vknee[1]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Vknee[2]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.Vknee[3]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.upperDiode.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperDiode.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[1]", 1,\
 5, 308, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].n.v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[1].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperDiode.i[1]", 1,\
 5, 308, 0)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[1].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[2]", 1,\
 5, 309, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].n.v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[2].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperDiode.i[2]", 1,\
 5, 309, 0)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[2].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.upperDiode.i[3]", 1,\
 5, 310, 132)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].n.v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.upperDiode.idealDiode[3].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.upperDiode.i[3]", 1,\
 5, 310, 0)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.upperDiode.idealDiode[3].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.coreElement.lowerDiode.idealDiode[1].v", 1, 5, 389, 0)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.coreElement.lowerDiode.idealDiode[2].v", 1, 5, 403, 0)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 "drive.inverter.coreElement.lowerDiode.idealDiode[3].v", 1, 5, 417, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_p.pin[1].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[1]", 1,\
 5, 367, 132)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_p.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[2]", 1,\
 5, 368, 132)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_p.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[3]", 1,\
 5, 369, 132)
DeclareVariable("drive.inverter.coreElement.lowerDiode.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.idealDiode[1].n.i", 1,\
 5, 391, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.idealDiode[2].n.i", 1,\
 5, 405, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.idealDiode[3].n.i", 1,\
 5, 419, 132)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Ron[1]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Ron[2]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Ron[3]", "Closed diode resistance [Ohm]",\
 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Goff[1]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Goff[2]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Goff[3]", \
"Opened diode conductance [S]", 1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Vknee[1]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Vknee[2]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.Vknee[3]", \
"Threshold voltage [V]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.lowerDiode.useHeatPort", \
"= true, if all heat ports are enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerDiode.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].p.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[1].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[1]", 1,\
 5, 367, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[1].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[1].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerDiode.i[1]", 1,\
 5, 367, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[1].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].p.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[2].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[2]", 1,\
 5, 368, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[2].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[2].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerDiode.i[2]", 1,\
 5, 368, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[2].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].v", \
"Voltage drop of the two pins (= p.v - n.v) [V]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].p.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[3].p.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.lowerDiode.i[3]", 1,\
 5, 369, 132)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[3].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].n.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inverter.coreElement.lowerDiode.idealDiode[3].i", \
"Current flowing from pin p to pin n [A]", "drive.inverter.coreElement.lowerDiode.i[3]", 1,\
 5, 369, 0)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].Ron", \
"Forward state-on differential resistance (closed resistance) [Ohm]", 1E-05, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].Goff", \
"Backward state-off conductance (opened conductance) [S]", 1E-05, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].Vknee", \
"Forward threshold voltage [V]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].useHeatPort",\
 "= true, if heatPort is enabled [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].T", \
"Fixed device temperature if useHeatPort = false [K|degC]", 293.15, 0.0,1E+100,\
300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].LossPower",\
 "Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].T_heatPort",\
 "Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].off", \
"Switching state [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,706)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].s", \
"Auxiliary variable for actual position on the ideal diode characteristic [1]", 0,\
 0.0,0.0,0.0,0,2560)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].unitVoltage",\
 "[V]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.lowerDiode.idealDiode[3].unitCurrent",\
 "[A]", 1, 0.0,0.0,0.0,0,1537)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.v1", \
"Voltage drop of port 1 (= p1.v - n1.v) [V]", 65.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.v2", \
"Voltage drop of port 2 (= p2.v - n2.v) [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 0)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.i1", \
"Current flowing from pos. to neg. pin of port 1 [A]", "batteryPack.n.i", 1, 5, 999,\
 0)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.i2", \
"Current flowing from pos. to neg. pin of port 2 [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.p1.v", \
"Potential at the pin [V]", 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.p1.i", \
"Current flowing into the pin [A]", "batteryPack.n.i", 1, 5, 999, 132)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.n1.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.n1.i", \
"Current flowing into the pin [A]", "i", 1, 3, 3, 132)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.p2.v", \
"Potential at the pin [V]", "drive.inverter.coreElement.star_p.plug_p.pin[1].v", 1,\
 5, 177, 4)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.p2.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.idealBuckConverter.i2", 1,\
 5, 432, 132)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.n2.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.idealBuckConverter.n2.i", \
"Current flowing into the pin [A]", "drive.inverter.coreElement.star_p.pin_n.i", 1,\
 5, 181, 132)
DeclareVariable("drive.inverter.coreElement.idealBuckConverter.dutyCycle", "[1]",\
 0.0, 0.0,1.0,0.0,0,512)
DeclareAlias2("drive.inverter.coreElement.dutyCycle", "[1]", "dutyCycle", 1, 2, 1,\
 0)
DeclareVariable("drive.inverter.coreElement.pin_p.v", "Potential at the pin [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.pin_p.i", "Current flowing into the pin [A]",\
 "batteryPack.n.i", 1, 5, 999, 132)
DeclareAlias2("drive.inverter.coreElement.u[1, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[1, 1]", 1, 5, 161, 65)
DeclareAlias2("drive.inverter.coreElement.u[1, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[1, 2]", 1, 5, 162, 65)
DeclareAlias2("drive.inverter.coreElement.u[2, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[2, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.inverter.coreElement.u[2, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[2, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.u[3, 1]", "[:#(type=Boolean)]", \
"drive.modulation.y[3, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.inverter.coreElement.u[3, 2]", "[:#(type=Boolean)]", \
"drive.modulation.y[3, 2]", 1, 5, 166, 65)
DeclareVariable("drive.inverter.coreElement.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.coreElement.pin_n.i", "Current flowing into the pin [A]",\
 "drive.inverter.pin_n.i", 1, 5, 170, 132)
DeclareVariable("drive.inverter.coreElement.plug.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.coreElement.plug.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.coreElement.plug.pin[1].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.inverter.coreElement.plug.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.coreElement.plug.pin[2].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.inverter.coreElement.plug.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.coreElement.plug.pin[3].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareVariable("drive.inverter.coreElement.rotationSwitch.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.inverter.coreElement.rotationSwitch.bidirectional", \
"Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[1, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[1, 1]", 1, 5, 161, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[1, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[1, 2]", 1, 5, 162, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[2, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[2, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[2, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[2, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[3, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[3, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.u[3, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[3, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[1, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[1, 1]", 1, 5, 161, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[1, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[1, 2]", 1, 5, 162, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[2, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[2, 1]", 1, 5, 163, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[2, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[2, 2]", 1, 5, 164, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[3, 1]", \
"[:#(type=Boolean)]", "drive.modulation.y[3, 1]", 1, 5, 165, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.y[3, 2]", \
"[:#(type=Boolean)]", "drive.modulation.y[3, 2]", 1, 5, 166, 65)
DeclareAlias2("drive.inverter.coreElement.rotationSwitch.dutyCycle", "[1]", \
"dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.u", \
"Connector of Real input signal [1]", "dutyCycle", 1, 2, 1, 0)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.y", \
"Connector of Real output signal [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.u1", \
"Lower boundary of input u, switching from constant value y1 to linear interpolation",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.u2", \
"Upper boundary of input u, switching from linear interpolation to constant value y2",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.y1", \
"Minimum value for y", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.y2", \
"Maximum value for y", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.k", \
"Slope of the resulting line equation [1]", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.y0", \
"Offset of the resulting line equation", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.gradient.k", \
"Gain value multiplied with input signal [1]", 1.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.gradient.u", \
"Input signal connector [1]", "dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.gradient.y", \
"Output signal connector [1]", "dutyCycle", 1, 2, 1, 0)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.add.u1", \
"Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.add.u2", \
"Connector of Real input signal 2 [1]", "dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.add.y", \
"Connector of Real output signal", "dutyCycle", 1, 2, 1, 0)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.add.k1", \
"Gain of input signal 1", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.add.k2", \
"Gain of input signal 2", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.offset.k", \
"Constant output value", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.offset.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.limiter.uMax", \
"Upper limits of input signals", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.limiter.uMin", \
"Lower limits of input signals", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.limiter.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("drive.inverter.coreElement.uniOrBidirectional.limiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.limiter.u", \
"Connector of Real input signal", "dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.limiter.y", \
"Connector of Real output signal [1]", "drive.inverter.coreElement.uniOrBidirectional.y", 1,\
 5, 442, 0)
DeclareAlias2("drive.inverter.coreElement.uniOrBidirectional.limiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization", "dutyCycle", 1, 2, 1,\
 1024)
DeclareAlias2("drive.inverter.coreElement.abs.u", "Connector of Real input signal [1]",\
 "drive.inverter.coreElement.uniOrBidirectional.y", 1, 5, 442, 0)
DeclareAlias2("drive.inverter.coreElement.abs.y", "Connector of Real output signal [1]",\
 "drive.inverter.coreElement.idealBuckConverter.dutyCycle", 1, 5, 436, 0)
DeclareVariable("drive.inverter.coreElement.abs.generateEvent", "Choose whether events shall be generated [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.inverter.data.m", "Number of phases [:#(type=Integer)]", 3,\
 0.0,0.0,0.0,0,517)
DeclareVariable("drive.inverter.data.bidirectional", "Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.inverter.data.Ron", "Closed switch resistance [Ohm]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.inverter.data.Goff", "Opened switch conductance [S]", \
1E-05, 0.0,1E+100,0.0,0,513)
DeclareAlias2("drive.inverter.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.inverter.u[1, 1]", "[:#(type=Boolean)]", "drive.modulation.y[1, 1]", 1,\
 5, 161, 65)
DeclareAlias2("drive.inverter.u[1, 2]", "[:#(type=Boolean)]", "drive.modulation.y[1, 2]", 1,\
 5, 162, 65)
DeclareAlias2("drive.inverter.u[2, 1]", "[:#(type=Boolean)]", "drive.modulation.y[2, 1]", 1,\
 5, 163, 65)
DeclareAlias2("drive.inverter.u[2, 2]", "[:#(type=Boolean)]", "drive.modulation.y[2, 2]", 1,\
 5, 164, 65)
DeclareAlias2("drive.inverter.u[3, 1]", "[:#(type=Boolean)]", "drive.modulation.y[3, 1]", 1,\
 5, 165, 65)
DeclareAlias2("drive.inverter.u[3, 2]", "[:#(type=Boolean)]", "drive.modulation.y[3, 2]", 1,\
 5, 166, 65)
DeclareVariable("drive.inverter.plug.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.inverter.plug.pin[1].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareVariable("drive.inverter.plug.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.plug.pin[2].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareVariable("drive.inverter.plug.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.plug.pin[3].v", "Potential at the pin [V]", 0.0,\
 0.0,0.0,0.0,0,520)
DeclareVariable("drive.inverter.plug.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.inverter.currentSensorDC.p.v", "Potential at the pin [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.currentSensorDC.p.i", "Current flowing into the pin [A]",\
 "batteryPack.n.i", 1, 5, 999, 132)
DeclareVariable("drive.inverter.currentSensorDC.n.v", "Potential at the pin [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.currentSensorDC.n.i", "Current flowing into the pin [A]",\
 "i", 1, 3, 3, 132)
DeclareAlias2("drive.inverter.currentSensorDC.i", "Current in the branch from p to n as output signal [A]",\
 "batteryPack.n.i", 1, 5, 999, 0)
DeclareAlias2("drive.inverter.currentDC.u", "DC current of the inverter [A]", \
"batteryPack.n.i", 1, 5, 999, 0)
DeclareVariable("drive.inverter.currentSensorAC.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.inverter.currentSensorAC.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 132)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 132)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 132)
DeclareVariable("drive.inverter.currentSensorAC.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.currentSensorAC.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareAlias2("drive.inverter.currentSensorAC.i[1]", "Current in the branch from p to n as output signal [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 0)
DeclareAlias2("drive.inverter.currentSensorAC.i[2]", "Current in the branch from p to n as output signal [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 0)
DeclareAlias2("drive.inverter.currentSensorAC.i[3]", "Current in the branch from p to n as output signal [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 0)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].p.i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].n.i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[1].i", \
"Current in the branch from p to n as output signal [A]", "drive.controller.bldcBus.currentAC[1]", 1,\
 5, 1014, 0)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].p.i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].n.i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[2].i", \
"Current in the branch from p to n as output signal [A]", "drive.controller.bldcBus.currentAC[2]", 1,\
 5, 1015, 0)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].p.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].p.i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].n.v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].n.i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareAlias2("drive.inverter.currentSensorAC.currentSensor[3].i", \
"Current in the branch from p to n as output signal [A]", "drive.controller.bldcBus.currentAC[3]", 1,\
 5, 1016, 0)
DeclareVariable("drive.inverter.currentAC.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.inverter.currentAC.u[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 0)
DeclareAlias2("drive.inverter.currentAC.u[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 0)
DeclareAlias2("drive.inverter.currentAC.u[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 0)
DeclareVariable("drive.inverter.voltageSensorDC.p.v", "Potential at the pin [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.voltageSensorDC.p.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.inverter.voltageSensorDC.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.inverter.voltageSensorDC.n.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.inverter.voltageSensorDC.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 65.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.inverter.voltageDC.u", "DC current of the inverter [V]", \
65.0, 0.0,0.0,0.0,0,513)
DeclareState("drive.multiSensorMotor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 0, 0, 0.0,0.0,0.0,0,568)
DeclareDerivative("drive.multiSensorMotor.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.multiSensorMotor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "drive.machine.coreElement.flange.tau", 1, 5, 578, 132)
DeclareAlias2("drive.multiSensorMotor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.multiSensorMotor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "drive.inertia.flange_a.tau", 1, 5, 987, 132)
DeclareVariable("drive.multiSensorMotor.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.multiSensorMotor.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive.multiSensorMotor.flange_a.der(phi)", 1, 6, 0, 0)
DeclareAlias2("drive.multiSensorMotor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.machine.coreElement.flange.tau", 1, 5, 578, 0)
DeclareVariable("drive.machine.data.m", "Number of phases [:#(type=Integer)]", 3,\
 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.data.Rt", "Terminal resistances [Ohm]", 0.0155, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.data.useL", "Internal inductance shall be used [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.data.useLt", "if true Lt is used in the main diagonal otherwise L on the main d. and M for the other elements [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.data.Lt", "Terminal inductance = 2*(L-M) [H]", \
4E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.L", "Stator self inductance [H]", 1E-15, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.M", "Stator mututal inductance [H]", 1E-15, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Ls_sigma", "Leakage inductance at the terminals [H]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.fluxSource", "Selection which variable shall be used to compute the Back-EMF [:#(type=BrushlessDCDrives.Common.Types.FluxSource)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("drive.machine.data.k_tau", "Torque constant [N.m/A]", 0.1342, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.k_speed", "Speed constant in rpm/V [rev.min-1/V]",\
 71, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Jr", "Rotor's moment of inertia [kg.m2]", \
1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Js", "Stator's moment of inertia (only has effect if stator not fixed (useSupport = false)) [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.I_0", "No load current, used to compute a linear friction element [A]",\
 9.8, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.data.w_0", "No load speed to compute a linear friction element [rad/s]",\
 3550, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.data.u_s_nom", "Nominal voltage [V]", 50, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.i_s_nom", "Nominal current [A]", 177.8, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.tau_nom", "Nominal torque [N.m]", 23.853, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.w_nom", "Nominal mechanical speed [rad/s]", \
352.3819759776551, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.P_nom", "Nominal mechanical power [W]", \
8405.367272995007, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.kDC", "Torque constant for BLDC Model [N.m/A]",\
 0.1342, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.b", "Damping coefficient from no-load current [N.m.s/rad]",\
 0.0003704676056338029, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Rs", "Resistance of a single stator winding [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Ls", "Overall stator winding inductance [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Lm", "Main diagonal elements for Inductance Matrix (L-M) [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Lssigma", "Leakage inductance of a single phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.fs_nominal", "Nominal Frequency used for the computation of flux from 'Vs_openCircuit' [Hz]",\
 50, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.V_backEMF_max", "Maximum induced voltage (back-EMF) at 1 rad/s (electrical) in a single phase [V]",\
 0.03355, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.Vs_openCircuit", "Open voltage of the machine rotating at fs_nominal [V]",\
 9.012087208016212, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.data.frictionPower", "Power dissipated by the linear friction element at no load speed [W]",\
 4668.818000000001, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.useSupport", "True: stator is able to rotate, false: stator is fixed internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.useThermalPort", "True: thermal connector is provided, false: temperature is fixed to 20degC internally [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive.machine.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.machine.flange.tau", "Cut torque in the flange [N.m]", \
"drive.machine.coreElement.flange.tau", 1, 5, 578, 132)
DeclareVariable("drive.machine.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.plug_p.pin[1].v", "Potential at the pin [V]", \
"drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 132)
DeclareAlias2("drive.machine.plug_p.pin[2].v", "Potential at the pin [V]", \
"drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 132)
DeclareAlias2("drive.machine.plug_p.pin[3].v", "Potential at the pin [V]", \
"drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 132)
DeclareVariable("drive.machine.powerBalance.electricMachinePower", \
"Electrical power (stator) [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.innerMachinePower", "Mechanical power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.statorInertiaPower", \
"Stator inertia power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.powerBalance.rotorInertiaPower", "Rotor inertia power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.totalLossPower", "Total loss power [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.statorWindingLossPower", \
"Stator copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.powerBalance.frictionLossPower", "Friction losses [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.angleSensor.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.angleSensor.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.machine.angleSensor.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareVariable("drive.machine.angleSensor.flange.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.angleSensor.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.angleSensor.support.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.angleSensor.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStart[1]", \
"Starting angles of the pulses [rad|deg]", 0.5235987755982988, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStart[2]", \
"Starting angles of the pulses [rad|deg]", 1.5707963267948966, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStart[3]", \
"Starting angles of the pulses [rad|deg]", 2.617993877991494, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseWidth", \
"Width of the TRUE pulse output by the Hall sensors [rad|deg]", 3.141592653589793,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEnd[1]", \
"Ending angle of the pulses [rad|deg]", 3.665191429188092, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEnd[2]", \
"Ending angle of the pulses [rad|deg]", 4.71238898038469, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEnd[3]", \
"Ending angle of the pulses [rad|deg]", 5.759586531581287, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStartLim[1]", \
"Start angle < 2*pi [rad|deg]", 0.5235987755982988, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStartLim[2]", \
"Start angle < 2*pi [rad|deg]", 1.5707963267948966, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseStartLim[3]", \
"Start angle < 2*pi [rad|deg]", 2.617993877991494, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEndLim[1]", \
"End angle < 2*pi [rad|deg]", 3.665191429188092, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEndLim[2]", \
"End angle < 2*pi [rad|deg]", 4.71238898038469, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.pulseEndLim[3]", \
"End angle < 2*pi [rad|deg]", 5.759586531581287, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.coreElement.electricAngle", \
"[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.angleSensor.coreElement.electricAngleLim", \
"[rad|deg]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.angleSensor.coreElement.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareVariable("drive.machine.angleSensor.coreElement.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.angleSensor.coreElement.y[1]", "[:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 79, 65)
DeclareAlias2("drive.machine.angleSensor.coreElement.y[2]", "[:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 80, 65)
DeclareAlias2("drive.machine.angleSensor.coreElement.y[3]", "[:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 81, 65)
DeclareVariable("drive.machine.angleSensor.coreElement.support.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.angleSensor.coreElement.support.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.m", \
"Number of phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.pulseStart[1]", \
"Starting angles of the pulses [rad|deg]", 0.5235987755982988, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.pulseStart[2]", \
"Starting angles of the pulses [rad|deg]", 1.5707963267948966, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.pulseStart[3]", \
"Starting angles of the pulses [rad|deg]", 2.617993877991494, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.pulseConfiguration.pulseWidth", \
"Width of the TRUE pulse output by the Hall sensors [rad|deg]", 3.141592653589793,\
 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.angleSensor.hallSensorOutput.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.u[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 65)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.u[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 65)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.u[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 65)
DeclareVariable("drive.machine.coreElement.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.p", "Number of pole pairs (Integer) [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.fsNominal", "Nominal frequency [Hz]",\
 50.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.TsOperational", "Operational temperature of stator resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.Rs", "Stator resistance per phase at TRef [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.TsRef", "Reference temperature of stator resistance [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.alpha20s", "Temperature coefficient of stator resistance at 20 degC [1/K|1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Lszero", "Stator zero sequence inductance [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Lssigma", "Stator stray inductance per phase [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Jr", "Rotor's moment of inertia [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.useSupport", "Enable / disable (=fixed stator) support [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.coreElement.Js", "Stator's moment of inertia [kg.m2]",\
 1E-15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.useThermalPort", "Enable / disable (=fixed temperatures) thermal port [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.coreElement.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 4668.818000000001, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 3550.0, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.frictionParameters.power_w", \
"Exponent of friction torque w.r.t. angular velocity", 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", \
1.3151600000000003, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity [1]", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.frictionParameters.wLinear", \
"Linear angular velocity range [rad/s]", 3.5500000000000003, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.frictionParameters.tauLinear", \
"Torque corresponding with linear angular velocity range [N.m]", \
0.0013151600000000003, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.phiMechanical", "Mechanical angle of rotor against stator [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareAlias2("drive.machine.coreElement.der(phiMechanical)", "der(Mechanical angle of rotor against stator) [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareVariable("drive.machine.coreElement.wMechanical", "Mechanical angular velocity of rotor against stator [rad/s|rev/min]",\
 0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.tauElectrical", "Electromagnetic torque [N.m]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.tauShaft", "Shaft torque [N.m]", \
"drive.inertia.flange_a.tau", 1, 5, 987, 0)
DeclareAlias2("drive.machine.coreElement.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareVariable("drive.machine.coreElement.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.flange_a.tau", \
"Cut torque in the flange [N.m]", "drive.machine.coreElement.tauElectrical", 1, 5,\
 577, 132)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareVariable("drive.machine.coreElement.inertiaRotor.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.inertiaRotor.J", "Moment of inertia [kg.m2]",\
 1E-15, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaRotor.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.phi", "Absolute rotation angle of component [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.der(phi)", \
"der(Absolute rotation angle of component) [rad/s]", "drive.inertia.der(phi)", 1,\
 5, 990, 0)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 "drive.inertia.der(w)", 1, 6, 3, 0)
DeclareAlias2("drive.machine.coreElement.inertiaRotor.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "drive.inertia.der(w)", 1, 6, 3, 0)
DeclareVariable("drive.machine.coreElement.inertiaStator.flange_a.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.inertiaStator.flange_a.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.inertiaStator.flange_b.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.inertiaStator.flange_b.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.inertiaStator.J", "Moment of inertia [kg.m2]",\
 1E-15, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.stateSelect", \
"Priority to use phi and w as states [:#(type=StateSelect)]", 3, 1.0,5.0,0.0,0,1541)
DeclareVariable("drive.machine.coreElement.inertiaStator.phi", "Absolute rotation angle of component [rad|deg]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.der(phi)", \
"der(Absolute rotation angle of component) [rad/s]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.der(w)", \
"der(Absolute angular velocity of component (= der(phi))) [rad/s2]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.inertiaStator.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.machine.coreElement.friction.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareVariable("drive.machine.coreElement.friction.flange.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.friction.support.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.friction.support.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.machine.coreElement.friction.phi", "Angle between shaft and support [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareAlias2("drive.machine.coreElement.friction.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareAlias2("drive.machine.coreElement.friction.tau", "Torque [N.m]", \
"drive.machine.coreElement.friction.support.tau", 1, 5, 598, 0)
DeclareAlias2("drive.machine.coreElement.friction.w", "Relative angular velocity of flange and support [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareVariable("drive.machine.coreElement.friction.frictionParameters.PRef", \
"Reference friction losses at wRef [W]", 4668.818000000001, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.friction.frictionParameters.wRef", \
"Reference angular velocity that the PRef refer to [rad/s|rev/min]", 3550.0, \
1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.friction.frictionParameters.power_w",\
 "Exponent of friction torque w.r.t. angular velocity", 1.0, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.friction.frictionParameters.tauRef", \
"Reference friction torque at reference angular velocity [N.m]", \
1.3151600000000003, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.friction.frictionParameters.linear", \
"Linear angular velocity range with respect to reference angular velocity", \
0.001, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.friction.frictionParameters.wLinear",\
 "Linear angular velocity range [rad/s]", 3.5500000000000003, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.friction.frictionParameters.tauLinear",\
 "Torque corresponding with linear angular velocity range [N.m]", \
0.0013151600000000003, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.friction.useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.friction.heatPort.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.friction.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.machine.coreElement.friction.lossPower", "Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 "drive.machine.powerBalance.frictionLossPower", 1, 5, 524, 0)
DeclareVariable("drive.machine.coreElement.internalSupport.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalSupport.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.statorCoreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.statorCoreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCoreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", 100,\
 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCoreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
314.1592653589793, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCoreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0, 0.0,1.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCoreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCoreParameters.wMin", \
"Angular velocity limit [rad/s]", 0.0003141592653589793, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", \
157.07963267948966, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoadParameters.power_w", \
"Exponent of stray load loss torque w.r.t. angular velocity", 1, 1E-60,1E+100,\
0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoadParameters.tauRef", \
"Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.powerBalance.powerStator", \
"Electrical power (stator) [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.powerBalance.powerMechanical", \
"Mechanical power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.powerBalance.powerInertiaStator", \
"Stator inertia power [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.powerBalance.powerInertiaRotor", \
"Rotor inertia power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.powerBalance.lossPowerTotal", \
"Total loss power [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.powerBalance.lossPowerStatorWinding",\
 "Stator copper losses [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.powerBalance.lossPowerStatorCore", \
"Stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.powerBalance.lossPowerRotorCore", \
"Rotor core losses [W]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.powerBalance.lossPowerStrayLoad", \
"Stray load losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.powerBalance.lossPowerFriction", \
"Friction losses [W]", "drive.machine.powerBalance.frictionLossPower", 1, 5, 524,\
 0)
DeclareVariable("drive.machine.coreElement.powerBalance.lossPowerRotorWinding", \
"Rotor copper losses [W]", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.powerBalance.lossPowerPermanentMagnet",\
 "Permanent magnet losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.vs[1]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.vs[2]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.vs[3]", "Stator instantaneous voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.is[1]", "Stator instantaneous currents [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 0)
DeclareAlias2("drive.machine.coreElement.is[2]", "Stator instantaneous currents [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 0)
DeclareAlias2("drive.machine.coreElement.is[3]", "Stator instantaneous currents [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 0)
DeclareVariable("drive.machine.coreElement.i_0_s", "Stator zero-sequence current [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.der(i_0_s)", "der(Stator zero-sequence current) [A/s]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.idq_ss[1]", "Stator space phasor current / stator fixed frame [A]",\
 "drive.machine.coreElement.lssigma.i_[1]", 1, 5, 709, 0)
DeclareAlias2("drive.machine.coreElement.idq_ss[2]", "Stator space phasor current / stator fixed frame [A]",\
 "drive.machine.coreElement.lssigma.i_[2]", 1, 5, 710, 0)
DeclareState("drive.machine.coreElement.idq_sr[1]", "Stator space phasor current / rotor fixed frame [A]",\
 1, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.machine.coreElement.der(idq_sr[1])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("drive.machine.coreElement.idq_sr[2]", "Stator space phasor current / rotor fixed frame [A]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.machine.coreElement.der(idq_sr[2])", "der(Stator space phasor current / rotor fixed frame) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.idq_rs[1]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.idq_rs[2]", "Rotor space phasor current / stator fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.idq_rr[1]", "Rotor space phasor current / rotor fixed frame [A]",\
 20284.32289001934, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.idq_rr[2]", "Rotor space phasor current / rotor fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 132)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 132)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.coreElement.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 132)
DeclareVariable("drive.machine.coreElement.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.coreElement.plug_sn.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareAlias2("drive.machine.coreElement.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareVariable("drive.machine.coreElement.rs.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.rs.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.rs.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.rs.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.rs.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 0)
DeclareAlias2("drive.machine.coreElement.rs.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 0)
DeclareAlias2("drive.machine.coreElement.rs.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 0)
DeclareVariable("drive.machine.coreElement.rs.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.rs.plug_p.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.coreElement.rs.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 132)
DeclareAlias2("drive.machine.coreElement.rs.plug_p.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.coreElement.rs.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 132)
DeclareAlias2("drive.machine.coreElement.rs.plug_p.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.coreElement.rs.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 132)
DeclareVariable("drive.machine.coreElement.rs.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.coreElement.rs.plug_n.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.rs.plug_n.pin[1].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareVariable("drive.machine.coreElement.rs.plug_n.pin[2].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.rs.plug_n.pin[2].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareVariable("drive.machine.coreElement.rs.plug_n.pin[3].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.machine.coreElement.rs.plug_n.pin[3].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareVariable("drive.machine.coreElement.rs.R[1]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.R[2]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.R[3]", "Resistances R_ref at temperatures T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.T_ref[1]", "Reference temperatures [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.T_ref[2]", "Reference temperatures [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.T_ref[3]", "Reference temperatures [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.alpha[1]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.alpha[2]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.alpha[3]", "Temperature coefficients of resistances at reference temperatures [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.mh", "Number of heatPorts=number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.rs.useHeatPort", "= true, if all heat ports are enabled [:#(type=Boolean)]",\
 true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.rs.T[1]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.T[2]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.T[3]", "Fixed device temperatures if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.heatPort[1].T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.rs.heatPort[1].Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.rs.heatPort[2].T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.rs.heatPort[2].Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.rs.heatPort[3].T", "Port temperature [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.rs.heatPort[3].Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].R", "Resistance at temperature T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].T_ref", \
"Reference temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.rs.resistor[1].p.v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.coreElement.rs.resistor[1].p.i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 132)
DeclareAlias2("drive.machine.coreElement.rs.resistor[1].n.v", "Potential at the pin [V]",\
 "drive.machine.coreElement.rs.plug_n.pin[1].v", 1, 5, 652, 4)
DeclareAlias2("drive.machine.coreElement.rs.resistor[1].n.i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.machine.coreElement.rs.resistor[1].i", "Current flowing from pin p to pin n [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 0)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].heatPort.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.rs.resistor[1].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.heatPort[1].Q_flow", 1, 5, 670, 132)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].T_heatPort", \
"Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[1].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.00775, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].R", "Resistance at temperature T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].T_ref", \
"Reference temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.rs.resistor[2].p.v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.coreElement.rs.resistor[2].p.i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 132)
DeclareAlias2("drive.machine.coreElement.rs.resistor[2].n.v", "Potential at the pin [V]",\
 "drive.machine.coreElement.rs.plug_n.pin[2].v", 1, 5, 653, 4)
DeclareAlias2("drive.machine.coreElement.rs.resistor[2].n.i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.machine.coreElement.rs.resistor[2].i", "Current flowing from pin p to pin n [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 0)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].heatPort.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.rs.resistor[2].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.heatPort[2].Q_flow", 1, 5, 672, 132)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].T_heatPort", \
"Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[2].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.00775, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].R", "Resistance at temperature T_ref [Ohm]",\
 0.00775, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].T_ref", \
"Reference temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].alpha", \
"Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.rs.resistor[3].p.v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.coreElement.rs.resistor[3].p.i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 132)
DeclareAlias2("drive.machine.coreElement.rs.resistor[3].n.v", "Potential at the pin [V]",\
 "drive.machine.coreElement.rs.plug_n.pin[3].v", 1, 5, 654, 4)
DeclareAlias2("drive.machine.coreElement.rs.resistor[3].n.i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareAlias2("drive.machine.coreElement.rs.resistor[3].i", "Current flowing from pin p to pin n [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 0)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].heatPort.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.rs.resistor[3].heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.heatPort[3].Q_flow", 1, 5, 674, 132)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].LossPower", \
"Loss power leaving component via heatPort [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].T_heatPort", \
"Temperature of heatPort [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.rs.resistor[3].R_actual", \
"Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]", 0.00775, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.lssigma.L[1]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.lssigma.L[2]", "Inductance of both axes [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.lssigma.v_[1]", "[V]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("drive.machine.coreElement.lssigma.v_[2]", "[V]", 0.0, 0.0,0.0,\
0.0,0,513)
DeclareVariable("drive.machine.coreElement.lssigma.i_[1]", "[A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("drive.machine.coreElement.lssigma.i_[2]", "[A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareAlias2("drive.machine.coreElement.lssigma.spacePhasor_a.v_[1]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[1])", 1,\
 5, 867, 4)
DeclareAlias2("drive.machine.coreElement.lssigma.spacePhasor_a.v_[2]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[2])", 1,\
 5, 868, 4)
DeclareAlias2("drive.machine.coreElement.lssigma.spacePhasor_a.i_[1]", \
"1=real, 2=imaginary part [A]", "drive.machine.coreElement.lssigma.i_[1]", 1, 5,\
 709, 132)
DeclareAlias2("drive.machine.coreElement.lssigma.spacePhasor_a.i_[2]", \
"1=real, 2=imaginary part [A]", "drive.machine.coreElement.lssigma.i_[2]", 1, 5,\
 710, 132)
DeclareAlias2("drive.machine.coreElement.lssigma.spacePhasor_b.v_[1]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[1])", 1,\
 5, 867, 4)
DeclareAlias2("drive.machine.coreElement.lssigma.spacePhasor_b.v_[2]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[2])", 1,\
 5, 868, 4)
DeclareVariable("drive.machine.coreElement.lssigma.spacePhasor_b.i_[1]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.lssigma.spacePhasor_b.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.lszero.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.lszero.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.lszero.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.lszero.n.v", "Potential at the pin [V]",\
 0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.lszero.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.lszero.i", "Current flowing from pin p to pin n [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.lszero.L", "Inductance [H]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCore.coreParameters.m", \
"Number of phases (1 for DC, 3 for induction machines) [:#(type=Integer)]", 3, \
0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.statorCore.coreParameters.PRef", \
"Reference core losses at reference inner voltage VRef [W]", 0.0, 0.0,1E+100,0.0,\
0,513)
DeclareVariable("drive.machine.coreElement.statorCore.coreParameters.VRef", \
"Reference inner RMS voltage that reference core losses PRef refer to [V]", \
100.0, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCore.coreParameters.wRef", \
"Reference angular velocity that reference core losses PRef refer to [rad/s]", \
314.1592653589793, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCore.coreParameters.ratioHysteresis",\
 "Ratio of hysteresis losses with respect to the total core losses at VRef and fRef",\
 0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCore.coreParameters.GcRef", \
"Reference conductance at reference frequency and voltage [S]", 0.0, 0.0,0.0,0.0,\
0,513)
DeclareVariable("drive.machine.coreElement.statorCore.coreParameters.wMin", \
"Angular velocity limit [rad/s]", 0.0003141592653589793, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCore.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.statorCore.turnsRatio", \
"Effective number of stator turns / effective number of rotor turns (if used as rotor core)",\
 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCore.useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.statorCore.heatPort.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.statorCore.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.statorCore.lossPower", \
"Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.statorCore.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[1])", 1,\
 5, 867, 4)
DeclareAlias2("drive.machine.coreElement.statorCore.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[2])", 1,\
 5, 868, 4)
DeclareVariable("drive.machine.coreElement.statorCore.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.statorCore.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.statorCore.w", "Remagnetization angular velocity [rad/s]",\
 314.1592653589793, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCore.Gc", "Variable core loss conductance [S]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.statorCore.wLimit", "Limited angular velocity [rad/s]",\
 314.1592653589793, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.spacePhasorS.turnsRatio", \
"Turns ratio [1]", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.spacePhasorS.v[1]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.spacePhasorS.v[2]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.spacePhasorS.v[3]", "Instantaneous phase voltages [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.i[1]", "Instantaneous phase currents [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 0)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.i[2]", "Instantaneous phase currents [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 0)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.i[3]", "Instantaneous phase currents [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 0)
DeclareVariable("drive.machine.coreElement.spacePhasorS.TransformationMatrix[1, 1]",\
 "[1]", 0.6666666666666666, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.TransformationMatrix[1, 2]",\
 "[1]", -0.33333333333333315, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.TransformationMatrix[1, 3]",\
 "[1]", -0.3333333333333336, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.TransformationMatrix[2, 1]",\
 "[1]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.TransformationMatrix[2, 2]",\
 "[1]", 0.5773502691896257, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.TransformationMatrix[2, 3]",\
 "[1]", -0.5773502691896256, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.InverseTransformation[1, 1]",\
 "", 1.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.InverseTransformation[1, 2]",\
 "", 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.InverseTransformation[2, 1]",\
 "", -0.4999999999999998, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.InverseTransformation[2, 2]",\
 "", 0.8660254037844387, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.InverseTransformation[3, 1]",\
 "", -0.5000000000000004, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.InverseTransformation[3, 2]",\
 "", -0.8660254037844385, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.spacePhasorS.plug_p.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.machine.coreElement.rs.plug_n.pin[1].v", 1, 5,\
 652, 4)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 132)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.machine.coreElement.rs.plug_n.pin[2].v", 1, 5,\
 653, 4)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 132)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.machine.coreElement.rs.plug_n.pin[3].v", 1, 5,\
 654, 4)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 132)
DeclareVariable("drive.machine.coreElement.spacePhasorS.plug_n.m", \
"Number of phases [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_n.pin[1].v", \
"Potential at the pin [V]", "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645,\
 4)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_n.pin[2].v", \
"Potential at the pin [V]", "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645,\
 4)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_n.pin[3].v", \
"Potential at the pin [V]", "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645,\
 4)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareVariable("drive.machine.coreElement.spacePhasorS.zero.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.spacePhasorS.zero.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.spacePhasorS.ground.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.spacePhasorS.ground.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.spacePhasor.v_[1]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[1])", 1,\
 5, 867, 4)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.spacePhasor.v_[2]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[2])", 1,\
 5, 868, 4)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.spacePhasor.i_[1]", \
"1=real, 2=imaginary part [A]", "drive.machine.coreElement.lssigma.spacePhasor_b.i_[1]", 1,\
 5, 711, 132)
DeclareAlias2("drive.machine.coreElement.spacePhasorS.spacePhasor.i_[2]", \
"1=real, 2=imaginary part [A]", "drive.machine.coreElement.lssigma.spacePhasor_b.i_[2]", 1,\
 5, 712, 132)
DeclareVariable("drive.machine.coreElement.strayLoad.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.strayLoad.v[1]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoad.v[2]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoad.v[3]", "Voltage drops of the two polyphase plugs [V]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.strayLoad.i[1]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 0)
DeclareAlias2("drive.machine.coreElement.strayLoad.i[2]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 0)
DeclareAlias2("drive.machine.coreElement.strayLoad.i[3]", "Currents flowing into positive polyphase plugs [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 0)
DeclareVariable("drive.machine.coreElement.strayLoad.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 132)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 132)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 132)
DeclareVariable("drive.machine.coreElement.strayLoad.plug_n.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_n.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_n.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_n.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_n.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_n.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.coreElement.strayLoad.plug_n.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareAlias2("drive.machine.coreElement.strayLoad.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareVariable("drive.machine.coreElement.strayLoad.flange.tau", \
"Cut torque in the flange [N.m]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.strayLoad.support.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.strayLoad.support.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.coreElement.strayLoad.phi", "Angle between shaft and support [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareAlias2("drive.machine.coreElement.strayLoad.der(phi)", "der(Angle between shaft and support) [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareVariable("drive.machine.coreElement.strayLoad.tau", "Torque [N.m]", 0.0, \
0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.strayLoad.w", "Relative angular velocity of flange and support [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareVariable("drive.machine.coreElement.strayLoad.strayLoadParameters.PRef", \
"Reference stray load losses at IRef and wRef [W]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoad.strayLoadParameters.IRef", \
"Reference RMS current that PRef refers to [A]", 1.0, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoad.strayLoadParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", \
157.07963267948966, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoad.strayLoadParameters.power_w",\
 "Exponent of stray load loss torque w.r.t. angular velocity", 1.0, 1E-60,1E+100,\
0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoad.strayLoadParameters.tauRef",\
 "Reference stray load torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoad.useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.strayLoad.heatPort.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.strayLoad.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.strayLoad.lossPower", \
"Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.strayLoad.iRMS", "[A]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("drive.machine.coreElement.thermalAmbient.useDamperCage", \
"Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.coreElement.thermalAmbient.m", "Number of stator phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.thermalAmbient.useTemperatureInputs",\
 "If true, temperature inputs are used; else, temperatures are constant [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.coreElement.thermalAmbient.TDefault", \
"Default temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Ts", "Temperature of stator windings [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Q_flowStatorWinding", \
"Heat flow rate of stator windings [W]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Q_flowStatorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Q_flowRotorCore", \
"Heat flow rate of stator core losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Q_flowStrayLoad", \
"Heat flow rate of stray load losses [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.Q_flowFriction", \
"Heat flow rate of friction losses [W]", "drive.machine.powerBalance.frictionLossPower", 1,\
 5, 524, 0)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.m", \
"Number of stator phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,525)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.resistor[1].LossPower", 1, 5, 682, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.resistor[2].LossPower", 1, 5, 692, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.resistor[3].LossPower", 1, 5, 702, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortRotorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStrayLoad.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortFriction.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.powerBalance.frictionLossPower", 1, 5, 524, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.useDamperCage",\
 "Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,523)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortPermanentMagnet.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalPort.heatPortPermanentMagnet.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureStatorWinding.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.temperatureStatorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.thermalAmbient.Q_flowStatorWinding", 1, 5, 786, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureStatorWinding.T",\
 "[K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureStatorCore.T",\
 "Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureStatorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureStatorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureRotorCore.T",\
 "Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureRotorCore.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureRotorCore.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureStrayLoad.T",\
 "Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureStrayLoad.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureStrayLoad.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureFriction.T",\
 "Fixed temperature at port [K|degC]", 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureFriction.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.temperatureFriction.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.powerBalance.frictionLossPower", 1, 5, 524, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.constTs.k", \
"Constant output value [K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.constTs.y", \
"Connector of Real output signal [K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.m",\
 "Number of collected heat flows [:#(type=Integer)]", 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[1].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.resistor[1].LossPower", 1, 5, 682, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[2].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.resistor[2].LossPower", 1, 5, 692, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[3].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareAlias2("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.port_a[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", \
"drive.machine.coreElement.rs.resistor[3].LossPower", 1, 5, 702, 132)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.port_b.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.thermalCollectorStator.port_b.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,776)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Tpm", "Temperature of permanent magnet [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Tr", "Temperature of damper cage (optional) [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Q_flowRotorWinding", \
"Heat flow rate of damper cage (optional) [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Q_flowPermanentMagnet",\
 "Heat flow rate of permanent magnets [W]", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.Q_flowTotal", "[W]", \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureRotorWinding.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureRotorWinding.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperatureRotorWinding.T",\
 "[K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperaturePermanentMagnet.port.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperaturePermanentMagnet.port.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.thermalAmbient.temperaturePermanentMagnet.T",\
 "[K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.constTpm.k", \
"Constant output value [K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.constTpm.y", \
"Connector of Real output signal [K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.pi", "", 3.141592653589793, 0.0,0.0,\
0.0,0,2561)
DeclareVariable("drive.machine.coreElement.internalThermalPort.m", \
"Number of stator phases [:#(type=Integer)]", 3, 0.0,0.0,0.0,0,2573)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStatorWinding[1].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStatorWinding[1].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStatorWinding[2].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStatorWinding[2].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStatorWinding[3].T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStatorWinding[3].Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStatorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStatorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortRotorCore.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortRotorCore.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStrayLoad.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortStrayLoad.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortFriction.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortFriction.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.internalThermalPort.useDamperCage", \
"Enable / disable damper cage [:#(type=Boolean)]", false, 0.0,0.0,0.0,0,2571)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortPermanentMagnet.T",\
 "Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,2569)
DeclareVariable("drive.machine.coreElement.internalThermalPort.heatPortPermanentMagnet.Q_flow",\
 "Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.coreElement.airGap.Lmd", "Main field inductance d-axis [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.airGap.Lmq", "Main field inductance q-axis [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.airGap.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.coreElement.airGap.p", "Number of pole pairs [:#(type=Integer)]",\
 2, 1.0,1E+100,0.0,0,517)
DeclareAlias2("drive.machine.coreElement.airGap.tauElectrical", "[N.m]", \
"drive.machine.coreElement.tauElectrical", 1, 5, 577, 0)
DeclareVariable("drive.machine.coreElement.airGap.gamma", "Rotor displacement angle [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(gamma)", "der(Rotor displacement angle) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.airGap.i_ss[1]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "drive.machine.coreElement.lssigma.i_[1]", 1, 5, 709, 0)
DeclareAlias2("drive.machine.coreElement.airGap.i_ss[2]", "Stator current space phasor with respect to the stator fixed frame [A]",\
 "drive.machine.coreElement.lssigma.i_[2]", 1, 5, 710, 0)
DeclareAlias2("drive.machine.coreElement.airGap.i_sr[1]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "drive.machine.coreElement.idq_sr[1]", 1, 1, 1, 0)
DeclareAlias2("drive.machine.coreElement.airGap.i_sr[2]", "Stator current space phasor with respect to the rotor fixed frame [A]",\
 "drive.machine.coreElement.idq_sr[2]", 1, 1, 2, 0)
DeclareAlias2("drive.machine.coreElement.airGap.i_rs[1]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "drive.machine.coreElement.idq_rs[1]", 1, 5, 639, 0)
DeclareAlias2("drive.machine.coreElement.airGap.i_rs[2]", "Rotor current space phasor with respect to the stator fixed frame [A]",\
 "drive.machine.coreElement.idq_rs[2]", 1, 5, 640, 0)
DeclareVariable("drive.machine.coreElement.airGap.i_rr[1]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 20284.32289001934, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.airGap.i_rr[2]", "Rotor current space phasor with respect to the rotor fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.airGap.psi_ms[1]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.psi_ms[2]", "Magnetizing flux phasor with respect to the stator fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(psi_ms[1])", \
"der(Magnetizing flux phasor with respect to the stator fixed frame) [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(psi_ms[2])", \
"der(Magnetizing flux phasor with respect to the stator fixed frame) [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.psi_mr[1]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.psi_mr[2]", "Magnetizing flux phasor with respect to the rotor fixed frame [Wb]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(psi_mr[1])", \
"der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(psi_mr[2])", \
"der(Magnetizing flux phasor with respect to the rotor fixed frame) [V]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.RotationMatrix[1, 1]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.RotationMatrix[1, 2]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.RotationMatrix[2, 1]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.RotationMatrix[2, 2]", \
"Matrix of rotation from rotor to stator [1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(RotationMatrix[1, 1])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(RotationMatrix[1, 2])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(RotationMatrix[2, 1])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.airGap.der(RotationMatrix[2, 2])", \
"der(Matrix of rotation from rotor to stator) [s-1]", 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.airGap.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.machine.coreElement.airGap.flange.tau", "Cut torque in the flange [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 132)
DeclareVariable("drive.machine.coreElement.airGap.support.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.coreElement.airGap.support.tau", "Cut torque in the flange [N.m]",\
 "drive.machine.coreElement.tauElectrical", 1, 5, 577, 132)
DeclareAlias2("drive.machine.coreElement.airGap.spacePhasor_s.v_[1]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[1])", 1,\
 5, 867, 4)
DeclareAlias2("drive.machine.coreElement.airGap.spacePhasor_s.v_[2]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_ms[2])", 1,\
 5, 868, 4)
DeclareAlias2("drive.machine.coreElement.airGap.spacePhasor_s.i_[1]", \
"1=real, 2=imaginary part [A]", "drive.machine.coreElement.lssigma.i_[1]", 1, 5,\
 709, 132)
DeclareAlias2("drive.machine.coreElement.airGap.spacePhasor_s.i_[2]", \
"1=real, 2=imaginary part [A]", "drive.machine.coreElement.lssigma.i_[2]", 1, 5,\
 710, 132)
DeclareAlias2("drive.machine.coreElement.airGap.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_mr[1])", 1,\
 5, 871, 4)
DeclareAlias2("drive.machine.coreElement.airGap.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_mr[2])", 1,\
 5, 872, 4)
DeclareVariable("drive.machine.coreElement.airGap.spacePhasor_r.i_[1]", \
"1=real, 2=imaginary part [A]", 20284.32289001934, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.airGap.spacePhasor_r.i_[2]", \
"1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.airGap.i_mr[1]", "Magnetizing current space phasor with respect to the rotor fixed frame [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.coreElement.airGap.i_mr[2]", "Magnetizing current space phasor with respect to the rotor fixed frame [A]",\
 "drive.machine.coreElement.idq_sr[2]", 1, 1, 2, 0)
DeclareVariable("drive.machine.coreElement.airGap.L[1, 1]", "Inductance matrix [H]",\
 2E-06, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.airGap.L[1, 2]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.airGap.L[2, 1]", "Inductance matrix [H]",\
 0.0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.airGap.L[2, 2]", "Inductance matrix [H]",\
 2E-06, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.TpmOperational", "Operational temperature of permanent magnet [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.TrOperational", "Operational temperature of (optional) damper cage [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.VsOpenCircuit", "Open circuit RMS voltage per phase @ fsNominal [V]",\
 9.012087208016212, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Lmd", "Stator main field inductance per phase in d-axis [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Lmq", "Stator main field inductance per phase in q-axis [H]",\
 2E-06, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.useDamperCage", "Enable / disable damper cage [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.coreElement.Lrsigmad", "Damper stray inductance in d-axis [H]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Lrsigmaq", "Damper stray inductance in q-axis [H]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Rrd", "Damper resistance in d-axis at TRef [Ohm]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.Rrq", "Damper resistance in q-axis at TRef [Ohm]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.TrRef", "Reference temperature of damper resistances in d- and q-axis [K|degC]",\
 293.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.machine.coreElement.alpha20r", "Temperature coefficient of damper resistances in d- and q-axis [1/K|1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnetLossParameters.PRef", \
"Reference permanent magnet losses at IRef and wRef [W]", 0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnetLossParameters.c", \
"Part of permanent magnet losses at current = 0, i.e. independent of current", 0,\
 0.0,1.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnetLossParameters.IRef", \
"Reference stator RMS current that PRef refers to [A]", 1, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnetLossParameters.power_I",\
 "Exponent of permanent magnet loss torque w.r.t. stator current", 2, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnetLossParameters.wRef", \
"Reference angular velocity that PRef refers to [rad/s|rev/min]", 100, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnetLossParameters.power_w",\
 "Exponent of permanent magnet loss torque w.r.t. angular velocity", 1, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnetLossParameters.tauRef",\
 "Reference permanent magnet loss torque at reference angular velocity and reference current [N.m]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnet.Ie", "Equivalent excitation current [A]",\
 20284.32289001934, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.spacePhasor_r.v_[1]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_mr[1])", 1,\
 5, 871, 4)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.spacePhasor_r.v_[2]", \
"1=real, 2=imaginary part [V]", "drive.machine.coreElement.airGap.der(psi_mr[2])", 1,\
 5, 872, 4)
DeclareVariable("drive.machine.coreElement.permanentMagnet.spacePhasor_r.i_[1]",\
 "1=real, 2=imaginary part [A]", -20284.32289001934, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.permanentMagnet.spacePhasor_r.i_[2]",\
 "1=real, 2=imaginary part [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareVariable("drive.machine.coreElement.permanentMagnet.flange.tau", \
"Cut torque in the flange [N.m]", 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.permanentMagnet.support.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.coreElement.permanentMagnet.support.tau", \
"Cut torque in the flange [N.m]", 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.phi", "Angle between shaft and support [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.der(phi)", \
"der(Angle between shaft and support) [rad/s]", "drive.inertia.der(phi)", 1, 5, 990,\
 0)
DeclareVariable("drive.machine.coreElement.permanentMagnet.tau", "Torque [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.w", "Relative angular velocity of flange and support [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareVariable("drive.machine.coreElement.permanentMagnet.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.coreElement.permanentMagnet.permanentMagnetLossParameters.PRef",\
 "Reference permanent magnet losses at IRef and wRef [W]", 0.0, 0.0,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnet.permanentMagnetLossParameters.c",\
 "Part of permanent magnet losses at current = 0, i.e. independent of current", \
0.0, 0.0,1.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnet.permanentMagnetLossParameters.IRef",\
 "Reference stator RMS current that PRef refers to [A]", 1.0, 1E-60,1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnet.permanentMagnetLossParameters.power_I",\
 "Exponent of permanent magnet loss torque w.r.t. stator current", 2.0, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnet.permanentMagnetLossParameters.wRef",\
 "Reference angular velocity that PRef refers to [rad/s|rev/min]", 100.0, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnet.permanentMagnetLossParameters.power_w",\
 "Exponent of permanent magnet loss torque w.r.t. angular velocity", 1.0, 1E-60,\
1E+100,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnet.permanentMagnetLossParameters.tauRef",\
 "Reference permanent magnet loss torque at reference angular velocity and reference current [N.m]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.permanentMagnet.useHeatPort", \
"= true, if heatPort is enabled [:#(type=Boolean)]", true, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.machine.coreElement.permanentMagnet.heatPort.T", \
"Port temperature [K|degC]", 293.15, 0.0,1E+100,300.0,0,521)
DeclareVariable("drive.machine.coreElement.permanentMagnet.heatPort.Q_flow", \
"Heat flow rate (positive if flowing from outside into the component) [W]", 0.0,\
 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.coreElement.permanentMagnet.lossPower", \
"Loss power leaving component via heatPort (> 0, if heat is flowing out of component) [W]",\
 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.is[1]", \
"Instantaneous stator currents [A]", "drive.controller.bldcBus.currentAC[1]", 1,\
 5, 1014, 0)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.is[2]", \
"Instantaneous stator currents [A]", "drive.controller.bldcBus.currentAC[2]", 1,\
 5, 1015, 0)
DeclareAlias2("drive.machine.coreElement.permanentMagnet.is[3]", \
"Instantaneous stator currents [A]", "drive.controller.bldcBus.currentAC[3]", 1,\
 5, 1016, 0)
DeclareVariable("drive.machine.coreElement.permanentMagnet.iRMS", "[A]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.Ie", "Equivalent excitation current [A]",\
 20284.32289001934, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.machine.coreElement.damperCageLossPower", \
"Damper losses [W]", 0.0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("drive.machine.coreElement.airgapTorque", "[N.m]", \
"drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 0)
DeclareVariable("drive.machine.coreElement.innerTorque", "[N.m]", 0.0, 0.0,0.0,\
0.0,0,512)
DeclareVariable("drive.machine.coreElement.inertiaTorque", "[N.m]", 0.0, \
0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.terminalBox.m", "Number of phases [:#(type=Integer)]",\
 3, 0.0,0.0,0.0,0,517)
DeclareVariable("drive.machine.terminalBox.terminalConnection", "Choose Y=star/D=delta [:#(type=BrushlessDCDrives.Common.Types.Terminal)]",\
 1, 1.0,2.0,0.0,0,517)
DeclareVariable("drive.machine.terminalBox.isDelta", "[:#(type=Boolean)]", false,\
 0.0,0.0,0.0,0,515)
DeclareVariable("drive.machine.terminalBox.plug_sp.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[1].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[2].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sp.pin[3].i", "Current flowing into the pin [A]",\
 "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareVariable("drive.machine.terminalBox.plug_sn.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[1].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[1].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 132)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[2].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[2].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 132)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[3].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareAlias2("drive.machine.terminalBox.plug_sn.pin[3].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 132)
DeclareVariable("drive.machine.terminalBox.plugSupply.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[1].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[1].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 132)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[2].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[2].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 132)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[3].v", "Potential at the pin [V]",\
 "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.terminalBox.plugSupply.pin[3].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 132)
DeclareAlias2("drive.machine.terminalBox.starpoint.v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareVariable("drive.machine.terminalBox.starpoint.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.terminalBox.star.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.terminalBox.star.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[1].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 132)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[2].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 132)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[3].v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareAlias2("drive.machine.terminalBox.star.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 132)
DeclareAlias2("drive.machine.terminalBox.star.pin_n.v", "Potential at the pin [V]",\
 "drive.machine.coreElement.plug_sn.pin[1].v", 1, 5, 645, 4)
DeclareVariable("drive.machine.terminalBox.star.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.internalSupport.phi", "Absolute rotation angle of flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2569)
DeclareVariable("drive.machine.internalSupport.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,2825)
DeclareVariable("drive.machine.electricPowerSensor.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,517)
DeclareAlias2("drive.machine.electricPowerSensor.P", "[W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 0)
DeclareVariable("drive.machine.electricPowerSensor.Q", "[var]", 0.0, 0.0,0.0,0.0,\
0,512)
DeclareVariable("drive.machine.electricPowerSensor.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[1].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 132)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[2].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 132)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_p.pin[3].i", \
"Current flowing into the pin [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 132)
DeclareVariable("drive.machine.electricPowerSensor.plug_ni.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[1].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[1].v", 1, 5, 465, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[1].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[1].i", 1, 5, 466, 132)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[2].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[2].v", 1, 5, 467, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[2].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[2].i", 1, 5, 468, 132)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[3].v", \
"Potential at the pin [V]", "drive.inverter.plug.pin[3].v", 1, 5, 469, 4)
DeclareAlias2("drive.machine.electricPowerSensor.plug_ni.pin[3].i", \
"Current flowing into the pin [A]", "drive.inverter.plug.pin[3].i", 1, 5, 470, 132)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[1].v", \
"Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[1].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[2].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[2].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[3].v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.electricPowerSensor.plug_nv.pin[3].i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.electricPowerSensor.v_[1]", "[V]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("drive.machine.electricPowerSensor.v_[2]", "[V]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("drive.machine.electricPowerSensor.i_[1]", "[A]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("drive.machine.electricPowerSensor.i_[2]", "[A]", 0.0, 0.0,0.0,\
0.0,0,2560)
DeclareVariable("drive.machine.star.m", "Number of phases [:#(type=Integer)]", 3,\
 1.0,1E+100,0.0,0,517)
DeclareVariable("drive.machine.star.plug_p.m", "Number of phases [:#(type=Integer)]",\
 3, 1.0,1E+100,0.0,0,525)
DeclareVariable("drive.machine.star.plug_p.pin[1].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.star.plug_p.pin[1].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.star.plug_p.pin[2].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.star.plug_p.pin[2].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.star.plug_p.pin[3].v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.star.plug_p.pin[3].i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.star.pin_n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.star.pin_n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.machine.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.ground.p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.electricMachinePower.u", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 518, 0)
DeclareAlias2("drive.machine.innerTorque.u", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 0)
DeclareAlias2("drive.machine.airGapTorque.u", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 0)
DeclareAlias2("drive.machine.machineAngle.u", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareAlias2("drive.machine.machineSpeed.u", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 0)
DeclareVariable("drive.machine.signChange.k", "Gain value multiplied with input signal [1]",\
 -1, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.machine.signChange.u", "Input signal connector [N.m]", \
"drive.machine.coreElement.innerTorque", 1, 5, 930, 0)
DeclareVariable("drive.machine.signChange.y", "Output signal connector [J]", 0.0,\
 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.innerPower.u1", "Connector of Real input signal 1 [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareVariable("drive.machine.innerPower.u2", "Connector of Real input signal 2 [J/rad]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.machine.innerPower.y", "Connector of Real output signal [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 519, 0)
DeclareVariable("drive.machine.speedSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.speedSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.speedSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareVariable("drive.machine.speedSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.speedSensor.phi_rel", "Relative angle between two flanges (flange_b.phi - flange_a.phi) [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareAlias2("drive.machine.speedSensor.der(phi_rel)", "der(Relative angle between two flanges (flange_b.phi - flange_a.phi)) [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareAlias2("drive.machine.speedSensor.w_rel", "Relative angular velocity between two flanges (= der(flange_b.phi) - der(flange_a.phi)) as output signal [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareVariable("drive.machine.angleSensorIdeal.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.machine.angleSensorIdeal.flange_a.tau", "Cut torque in the flange [N.m]",\
 0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.angleSensorIdeal.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareVariable("drive.machine.angleSensorIdeal.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,777)
DeclareAlias2("drive.machine.angleSensorIdeal.phi_rel", "Relative angle between two flanges (= flange_b.phi - flange_a.phi) as output signal [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareAlias2("drive.machine.torqueSensor.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.machine.torqueSensor.flange_a.tau", "Cut torque in the flange [N.m]",\
 "drive.inertia.flange_a.tau", 1, 5, 987, 132)
DeclareAlias2("drive.machine.torqueSensor.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.machine.torqueSensor.flange_b.tau", "Cut torque in the flange [N.m]",\
 "drive.machine.coreElement.flange.tau", 1, 5, 578, 132)
DeclareAlias2("drive.machine.torqueSensor.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.inertia.flange_a.tau", 1, 5, 987, 0)
DeclareAlias2("drive.machine.innerMachinePower.u", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 519, 0)
DeclareVariable("drive.ground.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("drive.ground.p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareVariable("drive.speedDependentTorque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("drive.speedDependentTorque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.speedDependentTorque.flange.tau", "Cut torque in the flange [N.m]",\
 "drive.multiSensorLoad.flange_a.tau", 1, 5, 991, 132)
DeclareVariable("drive.speedDependentTorque.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("drive.speedDependentTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "tau", 1, 2, 2, 0)
DeclareAlias2("drive.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareVariable("drive.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"tau", 1, 2, 2, 132)
DeclareVariable("drive.inertia.J", "Moment of inertia [kg.m2]", 0.0629, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareAlias2("drive.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 0)
DeclareVariable("drive.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("drive.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 3, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "drive.inertia.der(w)", 1, 6, 3, 0)
DeclareAlias2("drive.multiSensorLoad.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.multiSensorLoad.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 4)
DeclareVariable("drive.multiSensorLoad.flange_a.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.multiSensorLoad.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.multiSensorLoad.flange_b.tau", "Cut torque in the flange [N.m]",\
 "tau", 1, 2, 2, 132)
DeclareVariable("drive.multiSensorLoad.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.multiSensorLoad.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive.inertia.der(phi)", 1, 5, 990, 0)
DeclareAlias2("drive.multiSensorLoad.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.multiSensorLoad.flange_a.tau", 1, 5, 991, 0)
DeclareAlias2("drive.dutyCycleIn", "Ratio of on-time to period duration [1]", \
"dutyCycle", 1, 2, 1, 0)
DeclareAlias2("drive.rotateCW_In", "[:#(type=Boolean)]", "drive.controller.coreElement.rotateCW", 1,\
 5, 78, 65)
DeclareVariable("drive.pin_p.v", "Potential at the pin [V]", 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.pin_p.i", "Current flowing into the pin [A]", \
"batteryPack.n.i", 1, 5, 999, 132)
DeclareVariable("drive.pin_n.v", "Potential at the pin [V]", 0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.pin_n.i", "Current flowing into the pin [A]", "i", 1, 3, 3,\
 132)
DeclareAlias2("drive.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "tau", 1, 2, 2, 0)
DeclareAlias2("drive.w1", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive.multiSensorMotor.flange_a.der(phi)", 1, 6, 0, 0)
DeclareAlias2("drive.tau1", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.machine.coreElement.flange.tau", 1, 5, 578, 0)
DeclareVariable("batteryPack.V", "Value of constant voltage [V]", 65, 0.0,0.0,\
0.0,0,513)
DeclareVariable("batteryPack.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 65, 0.0,0.0,0.0,0,513)
DeclareVariable("batteryPack.p.v", "Potential at the pin [V]", 65.0, 0.0,0.0,0.0,\
0,521)
DeclareAlias2("batteryPack.p.i", "Current flowing into the pin [A]", "i", 1, 3, 3,\
 132)
DeclareVariable("batteryPack.n.v", "Potential at the pin [V]", 0.0, 0.0,0.0,0.0,\
0,521)
DeclareVariable("batteryPack.n.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,776)
DeclareAlias2("batteryPack.i", "Current flowing from pin p to pin n [A]", "i", 1,\
 3, 3, 0)
DeclareInput("rotationCW", "[:#(prefix=input):#(type=Boolean)]", 0, false, \
0.0,0.0,0.0,0,642)
DeclareInput("dutyCycle", "[1:#(prefix=input)]", 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareInput("tau", "Accelerating torque acting at flange (= -flange.tau) [N.m:#(prefix=input)]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("tau_out", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("omega_out", "Absolute angular velocity of flange_a as output signal",\
 1, 0, 0.0,0.0,0.0,0,512)
DeclareAlias2("realExtend.u", "[N.m]", "drive.machine.coreElement.flange.tau", 1,\
 5, 578, 0)
DeclareVariable("realExtend.y[1]", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("realExtend.y[2]", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("realExtend.y[3]", "", "tau_out", 1, 3, 0, 0)
DeclareAlias2("realExtend1.u", "[rad/s]", "drive.multiSensorMotor.flange_a.der(phi)", 1,\
 6, 0, 0)
DeclareVariable("realExtend1.y[1]", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("realExtend1.y[2]", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("realExtend1.y[3]", "", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("potentialSensor.p.v", "Potential at the pin [V]", 65.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("potentialSensor.p.i", "Current flowing into the pin [A]", 0, \
0.0,0.0,0.0,0,777)
DeclareVariable("potentialSensor.phi", "Absolute voltage potential as output signal [V]",\
 65.0, 0.0,0.0,0.0,0,513)
DeclareOutput("phi1", "Absolute voltage potential as output signal [V]", 2, 65.0,\
 0.0,0.0,0.0,0,513)
DeclareVariable("currentSensor.p.v", "Potential at the pin [V]", 65.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("currentSensor.p.i", "Current flowing into the pin [A]", "i", 1, 3,\
 3, 132)
DeclareVariable("currentSensor.n.v", "Potential at the pin [V]", 65.0, 0.0,0.0,\
0.0,0,521)
DeclareAlias2("currentSensor.n.i", "Current flowing into the pin [A]", \
"batteryPack.n.i", 1, 5, 999, 132)
DeclareAlias2("currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "i", 1, 3, 3, 0)
DeclareOutput("i", "Current in the branch from p to n as output signal [A]", 3, \
0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.machine.coreElement.thermalAmbient.constTr.k", \
"Constant output value [K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.machine.coreElement.thermalAmbient.constTr.y", \
"Connector of Real output signal [K]", 293.15, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.hallSensorOutput[1]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.hallSensorOutput[2]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.hallSensorOutput[3]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 4)
DeclareVariable("drive.inverter.voltageDC.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.hallSensorOutput[1]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.hallSensorOutput[2]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.hallSensorOutput[3]",\
 "Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.controller.bldcBus.airgapTorque", 1,\
 5, 1013, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.controller.bldcBus.machineSpeed", 1,\
 5, 1017, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareVariable("drive.controller.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("drive.controller.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("drive.controller.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("drive.controller.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.controller.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.controller.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.controller.bldcBus.electricMachinePower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 518, 4)
DeclareAlias2("drive.controller.bldcBus.hallSensorOutput[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 79, 69)
DeclareAlias2("drive.controller.bldcBus.hallSensorOutput[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 80, 69)
DeclareAlias2("drive.controller.bldcBus.hallSensorOutput[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 81, 69)
DeclareAlias2("drive.controller.bldcBus.innerMechanicPower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 519, 4)
DeclareAlias2("drive.controller.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.controller.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareVariable("drive.controller.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareVariable("drive.controller.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.airgapTorque",\
 "Ratio of on-time to period duration [N.m]", "drive.controller.bldcBus.airgapTorque", 1,\
 5, 1013, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.currentAC[1]",\
 "DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.currentAC[2]",\
 "DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.currentAC[3]",\
 "DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.currentDC", \
"DC current of the inverter [A]", "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.dutyCycle", \
"Ratio of on-time to period duration [1]", "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.innerTorque", 1,\
 5, 930, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.machineAngle",\
 "Ratio of on-time to period duration [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareAlias2("drive.controller.hallSensorOutput.electricDriveBus.machineSpeed",\
 "Ratio of on-time to period duration [rad/s|1/min]", "drive.controller.bldcBus.machineSpeed", 1,\
 5, 1017, 4)
DeclareVariable("drive.controller.hallSensorOutput.electricDriveBus.voltageDC", \
"DC current of the inverter [V]", 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 4)
DeclareAlias2("drive.inverter.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 4)
DeclareAlias2("drive.inverter.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 4)
DeclareAlias2("drive.inverter.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 4)
DeclareAlias2("drive.inverter.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.inverter.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.inverter.bldcBus.electricMachinePower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 518, 4)
DeclareAlias2("drive.inverter.bldcBus.hallSensorOutput[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 79, 69)
DeclareAlias2("drive.inverter.bldcBus.hallSensorOutput[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 80, 69)
DeclareAlias2("drive.inverter.bldcBus.hallSensorOutput[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 81, 69)
DeclareAlias2("drive.inverter.bldcBus.innerMechanicPower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 519, 4)
DeclareAlias2("drive.inverter.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.inverter.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.inverter.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 4)
DeclareVariable("drive.inverter.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.currentAC.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.inverter.currentAC.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.inverter.currentAC.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.inverter.currentAC.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.inverter.currentAC.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 4)
DeclareVariable("drive.inverter.currentAC.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.currentDC.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.inverter.currentDC.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.inverter.currentDC.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.inverter.currentDC.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.inverter.currentDC.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 4)
DeclareVariable("drive.inverter.currentDC.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.inverter.voltageDC.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.airGapTorque.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.controller.bldcBus.machineSpeed", 1,\
 5, 1017, 4)
DeclareVariable("drive.machine.airGapTorque.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.angleSensor.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.machine.angleSensor.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.machine.angleSensor.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.angleSensor.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.machine.angleSensor.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 4)
DeclareVariable("drive.machine.angleSensor.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.airgapTorque",\
 "Ratio of on-time to period duration [N.m]", "drive.controller.bldcBus.airgapTorque", 1,\
 5, 1013, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.currentAC[1]",\
 "DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.currentAC[2]",\
 "DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.currentAC[3]",\
 "DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.currentDC",\
 "DC current of the inverter [A]", "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.dutyCycle",\
 "Ratio of on-time to period duration [1]", "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.electricMachinePower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.innerMechanicPower",\
 "Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.innerTorque",\
 "Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.innerTorque", 1,\
 5, 930, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.machineAngle",\
 "Ratio of on-time to period duration [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.machineSpeed",\
 "Ratio of on-time to period duration [rad/s|1/min]", "drive.controller.bldcBus.machineSpeed", 1,\
 5, 1017, 4)
DeclareVariable("drive.machine.angleSensor.hallSensorOutput.electricDriveBus.voltageDC",\
 "DC current of the inverter [V]", 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 4)
DeclareAlias2("drive.machine.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 4)
DeclareAlias2("drive.machine.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 4)
DeclareAlias2("drive.machine.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 4)
DeclareAlias2("drive.machine.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.bldcBus.electricMachinePower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 518, 4)
DeclareAlias2("drive.machine.bldcBus.hallSensorOutput[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 79, 69)
DeclareAlias2("drive.machine.bldcBus.hallSensorOutput[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 80, 69)
DeclareAlias2("drive.machine.bldcBus.hallSensorOutput[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 81, 69)
DeclareAlias2("drive.machine.bldcBus.innerMechanicPower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 519, 4)
DeclareAlias2("drive.machine.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.machine.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.machine.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 4)
DeclareVariable("drive.machine.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.controller.bldcBus.airgapTorque", 1,\
 5, 1013, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.currentDC", \
"DC current of the inverter [A]", "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.dutyCycle", \
"Ratio of on-time to period duration [1]", "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.innerTorque", 1,\
 5, 930, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.electricMachinePower.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.controller.bldcBus.machineSpeed", 1,\
 5, 1017, 4)
DeclareVariable("drive.machine.electricMachinePower.bldcBus.voltageDC", \
"DC current of the inverter [V]", 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.controller.bldcBus.airgapTorque", 1,\
 5, 1013, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.currentDC", \
"DC current of the inverter [A]", "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.dutyCycle", \
"Ratio of on-time to period duration [1]", "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.innerTorque", \
"Ratio of on-time to period duration [N.m]", "drive.machine.coreElement.innerTorque", 1,\
 5, 930, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareAlias2("drive.machine.innerMachinePower.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.controller.bldcBus.machineSpeed", 1,\
 5, 1017, 4)
DeclareVariable("drive.machine.innerMachinePower.bldcBus.voltageDC", \
"DC current of the inverter [V]", 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.innerTorque.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.machine.innerTorque.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.machine.innerTorque.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.innerTorque.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.machine.innerTorque.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 4)
DeclareVariable("drive.machine.innerTorque.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.machineAngle.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.controller.bldcBus.airgapTorque", 1,\
 5, 1013, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.machine.machineAngle.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.machine.machineAngle.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.machineAngle.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.machine.machineAngle.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.controller.bldcBus.machineSpeed", 1,\
 5, 1017, 4)
DeclareVariable("drive.machine.machineAngle.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.controller.bldcBus.airgapTorque", 1,\
 5, 1013, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.machine.machineSpeed.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareVariable("drive.machine.machineSpeed.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.modulation.bldcBus.airgapTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.controller.bldcBus.airgapTorque", 1, 5, 1013, 4)
DeclareAlias2("drive.modulation.bldcBus.currentAC[1]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[1]", 1, 5, 1014, 4)
DeclareAlias2("drive.modulation.bldcBus.currentAC[2]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[2]", 1, 5, 1015, 4)
DeclareAlias2("drive.modulation.bldcBus.currentAC[3]", "DC current of the inverter [A]",\
 "drive.controller.bldcBus.currentAC[3]", 1, 5, 1016, 4)
DeclareAlias2("drive.modulation.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.modulation.bldcBus.dutyCycle", "Ratio of on-time to period duration [1]",\
 "dutyCycle", 1, 2, 1, 4)
DeclareAlias2("drive.modulation.bldcBus.electricMachinePower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.electricMachinePower", 1, 5, 518, 4)
DeclareAlias2("drive.modulation.bldcBus.hallSensorOutput[1]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[1]", 1, 5, 79, 69)
DeclareAlias2("drive.modulation.bldcBus.hallSensorOutput[2]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[2]", 1, 5, 80, 69)
DeclareAlias2("drive.modulation.bldcBus.hallSensorOutput[3]", "Gate (switch) control signal [:#(type=Boolean)]",\
 "drive.controller.coreElement.u[3]", 1, 5, 81, 69)
DeclareAlias2("drive.modulation.bldcBus.innerMechanicPower", "Ratio of on-time to period duration [W]",\
 "drive.machine.powerBalance.innerMachinePower", 1, 5, 519, 4)
DeclareAlias2("drive.modulation.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.modulation.bldcBus.machineAngle", "Ratio of on-time to period duration [rad|deg]",\
 "drive.multiSensorMotor.flange_a.phi", 1, 1, 0, 4)
DeclareAlias2("drive.modulation.bldcBus.machineSpeed", "Ratio of on-time to period duration [rad/s|1/min]",\
 "drive.controller.bldcBus.machineSpeed", 1, 5, 1017, 4)
DeclareVariable("drive.modulation.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.airgapTorque", \
"Ratio of on-time to period duration [N.m]", "drive.controller.bldcBus.airgapTorque", 1,\
 5, 1013, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.currentAC[1]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[1]", 1, 5,\
 1014, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.currentAC[2]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[2]", 1, 5,\
 1015, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.currentAC[3]", \
"DC current of the inverter [A]", "drive.controller.bldcBus.currentAC[3]", 1, 5,\
 1016, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.currentDC", "DC current of the inverter [A]",\
 "batteryPack.n.i", 1, 5, 999, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.electricMachinePower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.electricMachinePower", 1,\
 5, 518, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.hallSensorOutput[1]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[1]", 1,\
 5, 79, 69)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.hallSensorOutput[2]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[2]", 1,\
 5, 80, 69)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.hallSensorOutput[3]", \
"Gate (switch) control signal [:#(type=Boolean)]", "drive.controller.coreElement.u[3]", 1,\
 5, 81, 69)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.innerMechanicPower", \
"Ratio of on-time to period duration [W]", "drive.machine.powerBalance.innerMachinePower", 1,\
 5, 519, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.innerTorque", "Ratio of on-time to period duration [N.m]",\
 "drive.machine.coreElement.innerTorque", 1, 5, 930, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.machineAngle", \
"Ratio of on-time to period duration [rad|deg]", "drive.multiSensorMotor.flange_a.phi", 1,\
 1, 0, 4)
DeclareAlias2("drive.modulation.dutyCycle.bldcBus.machineSpeed", \
"Ratio of on-time to period duration [rad/s|1/min]", "drive.controller.bldcBus.machineSpeed", 1,\
 5, 1017, 4)
DeclareVariable("drive.modulation.dutyCycle.bldcBus.voltageDC", "DC current of the inverter [V]",\
 65.0, 0.0,0.0,0.0,0,521)
DeclareVariable("DymolaConvertInputToReal0", "", 0.0, 0.0,0.0,0.0,0,1664)
DeclareAlias2("DymolaConvertInputToREAL0", "[:#(type=Boolean)]", \
"drive.controller.coreElement.rotateCW", 1, 5, 78, 577)
DeclareOutput("CPUtime", "[s]", 4, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("EventCounter", "", 5, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
StartPreBlock
pre(DYNX(W_,82),"drive.controller.coreElement.halfBridgeOutput[1]", 1, 1);
pre(DYNX(W_,83),"drive.controller.coreElement.halfBridgeOutput[2]", 1, 2);
pre(DYNX(W_,84),"drive.controller.coreElement.halfBridgeOutput[3]", 1, 3);
pre(DYNX(W_,77),"drive.controller.coreElement.same", false, 0);
EndPreBlock
StartEqBlock
DoRemember_(DYNX(W_,871), 0.0, 13);
DoRemember_(DYNX(W_,872), 0.0, 12);
DoRemember_(DYNX(W_,400), 0, 2);
DoRemember_(DYNX(W_,414), 0, 6);
DoRemember_(DYNX(W_,428), 0, 10);
DoRemember_(DYNX(W_,277), 0.0, 3);
DoRemember_(DYNX(W_,289), 0.0, 7);
DoRemember_(DYNX(W_,301), 0.0, 11);
DoRemember_(DYNX(W_,337), 0, 1);
DoRemember_(DYNX(W_,350), 0, 5);
DoRemember_(DYNX(W_,363), 0, 9);
DoRemember_(DYNX(W_,221), 0.0, 0);
DoRemember_(DYNX(W_,233), 0.0, 4);
DoRemember_(DYNX(W_,245), 0.0, 8);
EndEqBlock
EndDataBlock

BreakSectionFunctionStart(0);
BreakSectionFunctionCallNew(1);
BreakSectionFunctionCallNew(2);
BreakSectionFunctionCallNew(3);
BreakSectionFunctionEnd()
