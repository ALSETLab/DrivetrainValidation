/* DSblock model generated by Dymola from Modelica model DrivetrainValidation.FMU.SimplifiedDC.SimplifiedDrive_L_fmu
 Dymola Version 2021x (64-bit), 2020-11-26 translated this at Wed Jan 27 13:30:09 2021

  Evaluate = true;
OutputCPUtime = true;
 */
#ifndef DYN_MULTINSTANCE
#define DYN_MULTINSTANCE 1
#endif

#include <matrixop.h>
#if defined(DynSimStruct) || defined(BUILDFMU)
static double DymArrays0[3]={0.0155, 300.15, 0.0};
static double DymArrays3[3]={1.0, 1.0, 0.0};
static double DymArrays1[3]={1000.0, 300.15, 0.0};
static double DymArrays4[4]={0.0, 0.0, 0.0, 0.0};
static double DymArrays2[7]={0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0};
#endif
/* Declaration of C-structs */
/* Prototypes for functions used in model */
/* Codes used in model */
/* DSblock C-code: */

#define NX_    3
#define NX2_   0
#define NU_    3
#define NY_    6
#define NW_    115
#define NP_    0
#define NPS_   0
#define ND_   0
#define NXP_   0
#define NInitial_   0
#define MAXAuxStr_   0
#define MAXAuxStrLen_   500
#define NHash1_ -1586827877
#define NHash2_ 1952122308
#define NHash3_ 0
#define NI_    0
#define NRelF_ 3
#define NRel_  3
#define NTim_  0
#define NSamp_ 0
#define NCons_ 0
#define NA_    106
#define SizePre_ 0
#define SizeEq_ 0
#define SizeDelay_ 0
#define QNLmax_ 0
#define MAXAux 0
#define NrDymolaTimers_ 0
#define NWhen_ 0
#define NCheckIf_ 0
#define NGlobalHelp_ 0
#define NGlobalHelpI_ 0
#ifndef NExternalObject_
#define NExternalObject_ 0
#endif
#include <moutil.c>
DYMOLA_STATIC unsigned int FMIClockValueReferences_[1]={0};
DYMOLA_STATIC unsigned int FMIClockFirstValueReferences_[1]={0};
PreNonAliasDef(0)
PreNonAliasDef(1)
PreNonAliasDef(2)
PreNonAliasDef(3)
PreNonAliasDef(4)
PreNonAliasDef(5)
#if !defined(DYM2CCUR)
 DYMOLA_STATIC const char*modelName="DrivetrainValidation.FMU.SimplifiedDC.SimplifiedDrive_L_fmu";
#endif
DYMOLA_STATIC const char*usedLibraries[]={"BrushlessDCDrivesLib",0};
DYMOLA_STATIC const char*dllLibraryPath[]={0};
DYMOLA_STATIC const char*default_dymosim_license_filename=
 "c:/users/meagh/appdata/roaming/dassaultsystemes/dymola/dymola.lic";
DYMOLA_STATIC const char*GUIDString="{138261c2-621c-49b0-a84c-b957356d91d0}";
DYMOLA_STATIC const double cvodeTolerance=1E-05;
#define FMIStateValueReferencesDef_ 1
DYMOLA_STATIC unsigned int FMIStateValueReferences_[3]={
33554432, 33554433, 33554434};
#define QJacobianCGDef_ 1
DYMOLA_STATIC int QJacobianCG_[8]={2 , 2 , 1 , 2 , 1 , 3 , 0 , 0};
static int QJacobianGrp0[4]={1, 0, 1, 0};
static int QJacobianGrp1[4]={3, 3, 3, 0};
DYMOLA_STATIC struct QJacobianTag_ QJacobianGC2_[3]={
{0, QJacobianGrp0},{0, QJacobianGrp1},{0,0}};
DYMOLA_STATIC double QJacobianCD_[4]={0  , 44 , 55 , 60};
#include <dsblock1.c>

/* Define variable names. */

#define Sections_

TranslatedEquations
DYNX(Y_,4) = CurrentClockTime;
if (DYNEvent) DYNX(Y_,5) += 1;

InitialSection
#if defined(DynSimStruct) || defined(BUILDFMU)
DYNX(W_,8) = false;
DYNX(W_,21) = false;
DYNX(W_,32) = false;
DYNX(W_,39) = false;
DYNX(W_,96) = 3;
DYNX(W_,14) = 5E-05;
DYNX(W_,3) = 5E-05;
DYNX(W_,13) = 0.0155;
memcpy(&DYNX(W_,4), &DymArrays0, sizeof(double)*3);
DYNX(W_,9) = 300.15;
DYNX(W_,26) = 1000;
memcpy(&DYNX(W_,15), &DymArrays1, sizeof(double)*3);
DYNX(W_,22) = 300.15;
DYNX(W_,27) = 0.1365;
DYNX(W_,33) = 0.1365;
DYNX(W_,35) = 0;
DYNX(W_,48) = false;
DYNX(W_,51) = false;
memcpy(&DYNX(W_,53), &DymArrays2, sizeof(double)*7);
memcpy(&DYNX(W_,61), &DymArrays3, sizeof(double)*3);
DYNX(W_,65) = 1.0;
DYNX(W_,66) = 0.0;
DYNX(W_,67) = false;
DYNX(W_,68) = 2;
DYNX(W_,95) = 0.0629;
DYNX(W_,101) = 60;
DYNX(W_,102) = 60;
DYNX(W_,47) = 0;
DYNX(W_,100) = 60.0;
DYNX(W_,69) = 60.0;
DYNX(W_,29) = 0;
DYNX(W_,37) = 0;
DYNX(Y_,2) = 60.0;
DYNX(W_,41) = 0;
DYNX(W_,87) = 0;
DYNX(W_,89) = 0;
DYNX(W_,90) = 60.0;
DYNX(W_,98) = 0;
DYNX(W_,93) = 0.0;
DYNX(W_,110) = 60.0;
DYNX(W_,72) = 0.0;
DYNX(W_,74) = 0.0;
DYNX(W_,71) = 60.0;
DYNX(W_,78) = 0.0;
DYNX(W_,77) = 0.0;
DYNX(W_,76) = 60.0;
DYNX(W_,60) = 0.0;
DYNX(W_,64) = 0.0;
DYNX(W_,111) = 60.0;
DYNX(W_,112) = 60.0;
DYNX(W_,83) = 60.0;
DYNX(W_,82) = 60.0;
DYNX(W_,80) = 0.0;
DYNX(W_,49) = 0.0;
DYNX(W_,45) = 60.0;
DYNX(W_,109) = 60.0;
DYNX(W_,91) = 60.0;
DYNX(W_,88) = 0.0;
DYNX(W_,86) = 60.0;
DYNX(W_,104) = 0.0;
DYNX(W_,103) = 60.0;
DYNX(W_,92) = 0.0;
DYNX(W_,97) = 60.0;
DYNX(W_,99) = 60.0;
DYNX(W_,36) = 0.0;
DYNX(W_,38) = 0.0;
DYNX(W_,34) = 0.0;
DYNX(W_,25) = 1000.0;
DYNX(W_,24) = 300.15;
DYNX(W_,19) = 0.0;
DYNX(W_,12) = 0.0155;
DYNX(W_,11) = 300.15;
memcpy(&DYNX(W_,105), &DymArrays4, sizeof(double)*4);
#endif
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
BoundParameterSection
InitialSection
InitialSection
InitialStartSection
InitialSection
if (!DymolaUserHomotopy) UpdateInitVars(time, X_, XD_, U_, DP_, IP_, LP_, F_, Y_, W_, QZ_, duser_, iuser_, cuser_, did_, 1);
DefaultSection
InitializeData(0)
InitialSection
InitialSection2
DYNX(W_,52) = homotopy(IF GreaterS(DYNX(U_,1),"omega", 1.0,"1.0", 0) THEN 1.0
   ELSE IF LessS(DYNX(U_,1),"omega", 0.0,"0.0", 1) THEN 0.0 ELSE DYNX(U_,1), 
  DYNX(U_,1));
InitialSection
InitialSectionB
Init_=false;InitializeData(2);Init_=true;
EndInitialSection

OutputSection
DYNX(W_,2) = 0.1365*DYNX(X_,2);
DYNX(W_,18) = 0.001*DYNX(W_,2);
DYNX(Y_,3) = DYNX(X_,0)-DYNX(W_,18);
DYNX(Y_,0) = 0.1365*DYNX(Y_,3);
DYNX(Y_,1) = DYNX(X_,2);
DYNX(W_,43) =  -DYNX(Y_,0);
DYNX(W_,31) =  -DYNX(Y_,3);
DYNX(W_,20) =  -DYNX(W_,18);
DYNX(W_,42) = DYNX(Y_,1);
DYNX(W_,94) = DYNX(Y_,0);

DynamicsSection
DYNX(F_,2) = 15.89825119236884*(DYNX(Y_,0)+DYNX(U_,2));
DYNX(F_,1) = DYNX(X_,2);
DYNX(W_,7) = 0.0155*DYNX(X_,0);
DYNX(W_,52) = IF GreaterS(DYNX(U_,1),"omega", 1.0,"1.0", 0) THEN 1.0 ELSE IF 
  LessS(DYNX(U_,1),"omega", 0.0,"0.0", 1) THEN 0.0 ELSE DYNX(U_,1);
DYNX(W_,113) = IF DYNX(U_,0) THEN 2 ELSE 0.0;
DYNX(W_,114) = Greater(DYNX(W_,113),"DymolaConvertInputToReal0", 1,"1", 2);
DYNX(W_,79) = IF DYNX(W_,114) THEN -1 ELSE 1;
DYNX(W_,75) = DYNX(W_,52)*DYNX(W_,79);
DYNX(W_,28) = 60.0*DYNX(W_,75);
DYNX(W_,1) = DYNX(W_,28)-DYNX(W_,7);
DYNX(W_,0) = DYNX(W_,1)-DYNX(W_,2);
DYNX(F_,0) = 20000.0*DYNX(W_,0);

AcceptedSection1

AcceptedSection2
DYNX(W_,10) = DYNX(W_,7)*DYNX(X_,0);
DYNX(W_,23) = DYNX(W_,2)*DYNX(W_,18);
DYNX(W_,30) =  -(DYNX(Y_,3)+DYNX(W_,18));
DYNX(W_,44) = DYNX(Y_,0)*DYNX(X_,2);
DYNX(W_,46) = DYNX(W_,75)*DYNX(X_,0);
DYNX(W_,81) =  -(DYNX(W_,30)+DYNX(X_,0));
DYNX(W_,85) = IF DYNX(W_,114) THEN -1 ELSE 1;
DYNX(W_,84) = DYNX(X_,0)*DYNX(W_,85);
DYNX(W_,70) =  -DYNX(X_,0);
DYNX(W_,73) =  -DYNX(W_,46);
DYNX(W_,50) =  -DYNX(W_,30);
DYNX(W_,40) =  -DYNX(U_,2);

DefaultSection
InitializeData(1)
EndTranslatedEquations

#include <dsblock6.c>

PreNonAliasNew(0)
StartNonAlias(0)
DeclareAlias2("drive.tau_out", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.inertia.flange_a.tau", 1, 5, 94, 0)
DeclareAlias2("drive.omega_out", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive.multiSensorLoad.flange_a.der(phi)", 1, 5, 42, 0)
DeclareVariable("drive.simpleMotor_EMF.inductor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.simpleMotor_EMF.inductor.p.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.simpleMotor_EMF.inductor.p.i", "Current flowing into the pin [A]",\
 "drive.simpleMotor_EMF.inductor.i", 1, 1, 0, 132)
DeclareVariable("drive.simpleMotor_EMF.inductor.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.simpleMotor_EMF.inductor.n.i", "Current flowing into the pin [A]",\
 "drive.averaged.coreElement.idealBuckConverter.i2", 1, 5, 70, 132)
DeclareState("drive.simpleMotor_EMF.inductor.i", "Current flowing from pin p to pin n [A]",\
 0, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.simpleMotor_EMF.inductor.der(i)", "der(Current flowing from pin p to pin n) [A/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.simpleMotor_EMF.inductor.L", "Inductance [H]", 5E-05, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.resistor.R", "Resistance at temperature T_ref [Ohm]",\
 0.0155, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.resistor.T_ref", "Reference temperature [K|degC]",\
 300.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.resistor.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.resistor.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.simpleMotor_EMF.resistor.p.v", "Potential at the pin [V]", \
"drive.simpleMotor_EMF.p.v", 1, 5, 28, 4)
DeclareAlias2("drive.simpleMotor_EMF.resistor.p.i", "Current flowing into the pin [A]",\
 "drive.simpleMotor_EMF.inductor.i", 1, 1, 0, 132)
DeclareAlias2("drive.simpleMotor_EMF.resistor.n.v", "Potential at the pin [V]", \
"drive.simpleMotor_EMF.inductor.p.v", 1, 5, 1, 4)
DeclareAlias2("drive.simpleMotor_EMF.resistor.n.i", "Current flowing into the pin [A]",\
 "drive.averaged.coreElement.idealBuckConverter.i2", 1, 5, 70, 132)
DeclareAlias2("drive.simpleMotor_EMF.resistor.i", "Current flowing from pin p to pin n [A]",\
 "drive.simpleMotor_EMF.inductor.i", 1, 1, 0, 0)
DeclareVariable("drive.simpleMotor_EMF.resistor.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.simpleMotor_EMF.resistor.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 300.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.resistor.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.simpleMotor_EMF.resistor.T_heatPort", "Temperature of heatPort [K|degC]",\
 300.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.resistor.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 0.0155, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.R_trs", "Effective resistance for transport  ac loss [Ohm]",\
 0.0155, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.X_s", "Reactance [H]", 5E-05, 0.0,0.0,0.0,\
0,513)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.R", "Resistance at temperature T_ref [Ohm]",\
 1000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.T_ref", "Reference temperature [K|degC]",\
 300.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.alpha", "Temperature coefficient of resistance (R_actual = R*(1 + alpha*(T_heatPort - T_ref)) [1/K]",\
 0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.simpleMotor_EMF.hysteresis.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 "drive.simpleMotor_EMF.inductor.n.v", 1, 5, 2, 0)
DeclareAlias2("drive.simpleMotor_EMF.hysteresis.p.v", "Potential at the pin [V]",\
 "drive.simpleMotor_EMF.inductor.n.v", 1, 5, 2, 4)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.simpleMotor_EMF.hysteresis.i", "Current flowing from pin p to pin n [A]",\
 "drive.simpleMotor_EMF.hysteresis.p.i", 1, 5, 18, 0)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.useHeatPort", "= true, if heatPort is enabled [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.T", "Fixed device temperature if useHeatPort = false [K|degC]",\
 300.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.LossPower", "Loss power leaving component via heatPort [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.T_heatPort", "Temperature of heatPort [K|degC]",\
 300.15, 0.0,1E+100,300.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.hysteresis.R_actual", "Actual resistance = R*(1 + alpha*(T_heatPort - T_ref)) [Ohm]",\
 1000.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.R_hyst", "Effective resistance for hysteresis ac loss [Ohm]",\
 1000, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.simpleMotor_EMF.k", "Transformation coefficient of back EMF [N.m/A]",\
 0.1365, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.simpleMotor_EMF.flange1.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("drive.simpleMotor_EMF.flange1.tau", "Cut torque in the flange [N.m]",\
 "drive.multiSensorLoad.flange_b.tau", 1, 5, 43, 132)
DeclareVariable("drive.simpleMotor_EMF.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,520)
DeclareAlias2("drive.simpleMotor_EMF.p.i", "Current flowing into the pin [A]", \
"drive.simpleMotor_EMF.inductor.i", 1, 1, 0, 132)
DeclareVariable("drive.simpleMotor_EMF.n.v", "Potential at the pin [V]", 0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.simpleMotor_EMF.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.simpleMotor_EMF.currentSensor.p.v", "Potential at the pin [V]",\
 "drive.simpleMotor_EMF.inductor.n.v", 1, 5, 2, 4)
DeclareAlias2("drive.simpleMotor_EMF.currentSensor.p.i", "Current flowing into the pin [A]",\
 "i1", 1, 3, 3, 132)
DeclareAlias2("drive.simpleMotor_EMF.currentSensor.n.v", "Potential at the pin [V]",\
 "drive.simpleMotor_EMF.inductor.n.v", 1, 5, 2, 4)
DeclareVariable("drive.simpleMotor_EMF.currentSensor.n.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.simpleMotor_EMF.currentSensor.i", "Current in the branch from p to n as output signal [A]",\
 "i1", 1, 3, 3, 0)
DeclareAlias2("drive.simpleMotor_EMF.i1", "Current in the branch from p to n as output signal [A]",\
 "i1", 1, 3, 3, 0)
DeclareVariable("drive.simpleMotor_EMF.emf1.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareVariable("drive.simpleMotor_EMF.emf1.k", "Transformation coefficient [N.m/A]",\
 0.1365, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.simpleMotor_EMF.emf1.v", "Voltage drop between the two pins [V]",\
 "drive.simpleMotor_EMF.inductor.n.v", 1, 5, 2, 0)
DeclareAlias2("drive.simpleMotor_EMF.emf1.i", "Current flowing from positive to negative pin [A]",\
 "i1", 1, 3, 3, 0)
DeclareAlias2("drive.simpleMotor_EMF.emf1.phi", "Angle of shaft flange with respect to support (= flange.phi - support.phi) [rad|deg]",\
 "drive.inertia.phi", 1, 1, 1, 0)
DeclareAlias2("drive.simpleMotor_EMF.emf1.der(phi)", "der(Angle of shaft flange with respect to support (= flange.phi - support.phi)) [rad/s]",\
 "drive.multiSensorLoad.flange_a.der(phi)", 1, 5, 42, 0)
DeclareAlias2("drive.simpleMotor_EMF.emf1.w", "Angular velocity of flange relative to support [rad/s]",\
 "drive.multiSensorLoad.flange_a.der(phi)", 1, 5, 42, 0)
DeclareAlias2("drive.simpleMotor_EMF.emf1.tau", "Torque of flange [N.m]", \
"drive.multiSensorLoad.flange_b.tau", 1, 5, 43, 0)
DeclareAlias2("drive.simpleMotor_EMF.emf1.tauElectrical", "Electrical torque [N.m]",\
 "drive.inertia.flange_a.tau", 1, 5, 94, 0)
DeclareAlias2("drive.simpleMotor_EMF.emf1.p.v", "Potential at the pin [V]", \
"drive.simpleMotor_EMF.inductor.n.v", 1, 5, 2, 4)
DeclareAlias2("drive.simpleMotor_EMF.emf1.p.i", "Current flowing into the pin [A]",\
 "i1", 1, 3, 3, 132)
DeclareVariable("drive.simpleMotor_EMF.emf1.n.v", "Potential at the pin [V]", \
0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.simpleMotor_EMF.emf1.n.i", "Current flowing into the pin [A]",\
 "drive.simpleMotor_EMF.currentSensor.n.i", 1, 5, 31, 132)
DeclareAlias2("drive.simpleMotor_EMF.emf1.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("drive.simpleMotor_EMF.emf1.flange.tau", "Cut torque in the flange [N.m]",\
 "drive.multiSensorLoad.flange_b.tau", 1, 5, 43, 132)
DeclareVariable("drive.simpleMotor_EMF.emf1.fixed.phi0", "Fixed offset angle of housing [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.simpleMotor_EMF.emf1.fixed.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 0.0, 0.0,0.0,0.0,0,2569)
DeclareAlias2("drive.simpleMotor_EMF.emf1.fixed.flange.tau", "Cut torque in the flange [N.m]",\
 "drive.multiSensorLoad.flange_b.tau", 1, 5, 43, 1156)
DeclareAlias2("drive.simpleMotor_EMF.emf1.internalSupport.tau", "External support torque (must be computed via torque balance in model where InternalSupport is used; = flange.tau) [N.m]",\
 "drive.inertia.flange_a.tau", 1, 5, 94, 1024)
DeclareVariable("drive.simpleMotor_EMF.emf1.internalSupport.phi", \
"External support angle (= flange.phi) [rad|deg]", 0, 0.0,0.0,0.0,0,2561)
DeclareVariable("drive.simpleMotor_EMF.emf1.internalSupport.flange.phi", \
"Absolute rotation angle of flange [rad|deg]", 0.0, 0.0,0.0,0.0,0,2569)
DeclareAlias2("drive.simpleMotor_EMF.emf1.internalSupport.flange.tau", \
"Cut torque in the flange [N.m]", "drive.inertia.flange_a.tau", 1, 5, 94, 1156)
DeclareVariable("drive.speedDependentTorque.useSupport", "= true, if support flange enabled, otherwise implicitly grounded [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,1539)
DeclareAlias2("drive.speedDependentTorque.flange.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.inertia.phi", 1, 1, 1, 4)
DeclareVariable("drive.speedDependentTorque.flange.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.speedDependentTorque.phi_support", "Absolute angle of support flange [rad|deg]",\
 0, 0.0,0.0,0.0,0,2561)
DeclareAlias2("drive.speedDependentTorque.tau", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "tau", 1, 2, 2, 0)
DeclareAlias2("drive.multiSensorLoad.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.inertia.phi", 1, 1, 1, 4)
DeclareVariable("drive.multiSensorLoad.flange_a.der(phi)", "der(Absolute rotation angle of flange) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,520)
DeclareAlias2("drive.multiSensorLoad.flange_a.tau", "Cut torque in the flange [N.m]",\
 "drive.inertia.flange_a.tau", 1, 5, 94, 132)
DeclareAlias2("drive.multiSensorLoad.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.inertia.phi", 1, 1, 1, 4)
DeclareVariable("drive.multiSensorLoad.flange_b.tau", "Cut torque in the flange [N.m]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.multiSensorLoad.power", "Power in flange flange_a as output signal [W]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.multiSensorLoad.w", "Absolute angular velocity of flange_a as output signal [rad/s]",\
 "drive.multiSensorLoad.flange_a.der(phi)", 1, 5, 42, 0)
DeclareAlias2("drive.multiSensorLoad.tau", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal [N.m]",\
 "drive.inertia.flange_a.tau", 1, 5, 94, 0)
DeclareAlias2("drive.tau_in", "Accelerating torque acting at flange (= -flange.tau) [N.m]",\
 "tau", 1, 2, 2, 0)
DeclareVariable("drive.averaged.pin_p.v", "Potential at the pin [V]", 60.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.averaged.pin_p.i", "Current flowing into the pin [A]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.averaged.pin_n.v", "Potential at the pin [V]", 0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.pin_n.i", "Current flowing into the pin [A]", \
"drive.averaged.coreElement.idealBuckConverter.n1.i", 1, 5, 73, 132)
DeclareVariable("drive.averaged.data.bidirectional", "Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive.averaged.dutyCycleIn", "Ratio of on-time to period duration [1]",\
 "omega", 1, 2, 1, 0)
DeclareAlias2("drive.averaged.pin_p_Out.v", "Potential at the pin [V]", \
"drive.simpleMotor_EMF.p.v", 1, 5, 28, 4)
DeclareAlias2("drive.averaged.pin_p_Out.i", "Current flowing into the pin [A]", \
"drive.averaged.coreElement.idealBuckConverter.i2", 1, 5, 70, 132)
DeclareVariable("drive.averaged.pin_n_Out.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.averaged.pin_n_Out.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.averaged.coreElement.bidirectional", "Inverter acts like it is controlled by a bidirectional modulation method [:#(type=Boolean)]",\
 false, 0.0,0.0,0.0,0,515)
DeclareAlias2("drive.averaged.coreElement.uniOrBidirectional.u", \
"Connector of Real input signal [1]", "omega", 1, 2, 1, 0)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.u1", \
"Lower boundary of input u, switching from constant value y1 to linear interpolation",\
 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.u2", \
"Upper boundary of input u, switching from linear interpolation to constant value y2",\
 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.y1", \
"Minimum value for y", 0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.y2", \
"Maximum value for y", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.k", \
"Slope of the resulting line equation [1]", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.y0", \
"Offset of the resulting line equation", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.gradient.k", \
"Gain value multiplied with input signal [1]", 1.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.averaged.coreElement.uniOrBidirectional.gradient.u", \
"Input signal connector [1]", "omega", 1, 2, 1, 0)
DeclareAlias2("drive.averaged.coreElement.uniOrBidirectional.gradient.y", \
"Output signal connector [1]", "omega", 1, 2, 1, 0)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.add.u1", \
"Connector of Real input signal 1", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.averaged.coreElement.uniOrBidirectional.add.u2", \
"Connector of Real input signal 2 [1]", "omega", 1, 2, 1, 0)
DeclareAlias2("drive.averaged.coreElement.uniOrBidirectional.add.y", \
"Connector of Real output signal", "omega", 1, 2, 1, 0)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.add.k1", \
"Gain of input signal 1", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.add.k2", \
"Gain of input signal 2", 1, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.offset.k", \
"Constant output value", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.offset.y", \
"Connector of Real output signal", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.limiter.uMax", \
"Upper limits of input signals", 1.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.limiter.uMin", \
"Lower limits of input signals", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.limiter.strict", \
"= true, if strict limits with noEvent(..) [:#(type=Boolean)]", false, 0.0,0.0,\
0.0,0,515)
DeclareVariable("drive.averaged.coreElement.uniOrBidirectional.limiter.homotopyType",\
 "Simplified model for homotopy-based initialization [:#(type=Modelica.Blocks.Types.LimiterHomotopy)]",\
 2, 1.0,4.0,0.0,0,517)
DeclareAlias2("drive.averaged.coreElement.uniOrBidirectional.limiter.u", \
"Connector of Real input signal", "omega", 1, 2, 1, 0)
DeclareAlias2("drive.averaged.coreElement.uniOrBidirectional.limiter.y", \
"Connector of Real output signal", "drive.averaged.coreElement.uniOrBidirectional.y", 1,\
 5, 52, 0)
DeclareAlias2("drive.averaged.coreElement.uniOrBidirectional.limiter.simplifiedExpr",\
 "Simplified expression for homotopy-based initialization", "omega", 1, 2, 1, 1024)
DeclareVariable("drive.averaged.coreElement.idealBuckConverter.v1", \
"Voltage drop of port 1 (= p1.v - n1.v) [V]", 60.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.averaged.coreElement.idealBuckConverter.v2", \
"Voltage drop of port 2 (= p2.v - n2.v) [V]", "drive.simpleMotor_EMF.p.v", 1, 5,\
 28, 0)
DeclareAlias2("drive.averaged.coreElement.idealBuckConverter.i1", \
"Current flowing from pos. to neg. pin of port 1 [A]", "drive.averaged.pin_p.i", 1,\
 5, 46, 0)
DeclareVariable("drive.averaged.coreElement.idealBuckConverter.i2", \
"Current flowing from pos. to neg. pin of port 2 [A]", 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.averaged.coreElement.idealBuckConverter.p1.v", \
"Potential at the pin [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.coreElement.idealBuckConverter.p1.i", \
"Current flowing into the pin [A]", "drive.averaged.pin_p.i", 1, 5, 46, 132)
DeclareVariable("drive.averaged.coreElement.idealBuckConverter.n1.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.averaged.coreElement.idealBuckConverter.n1.i", \
"Current flowing into the pin [A]", 0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.averaged.coreElement.idealBuckConverter.p2.v", \
"Potential at the pin [V]", "drive.simpleMotor_EMF.p.v", 1, 5, 28, 4)
DeclareAlias2("drive.averaged.coreElement.idealBuckConverter.p2.i", \
"Current flowing into the pin [A]", "drive.averaged.coreElement.idealBuckConverter.i2", 1,\
 5, 70, 132)
DeclareVariable("drive.averaged.coreElement.idealBuckConverter.n2.v", \
"Potential at the pin [V]", 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.coreElement.idealBuckConverter.n2.i", \
"Current flowing into the pin [A]", "drive.simpleMotor_EMF.inductor.i", 1, 1, 0,\
 132)
DeclareVariable("drive.averaged.coreElement.idealBuckConverter.dutyCycle", "[1]",\
 0.0, 0.0,1.0,0.0,0,512)
DeclareAlias2("drive.averaged.coreElement.dutyCycle", "[1]", "omega", 1, 2, 1, 0)
DeclareVariable("drive.averaged.coreElement.pin_p_supply.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.coreElement.pin_p_supply.i", "Current flowing into the pin [A]",\
 "drive.averaged.pin_p.i", 1, 5, 46, 132)
DeclareVariable("drive.averaged.coreElement.pin_n_supply.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.coreElement.pin_n_supply.i", "Current flowing into the pin [A]",\
 "drive.averaged.coreElement.idealBuckConverter.n1.i", 1, 5, 73, 132)
DeclareAlias2("drive.averaged.coreElement.pin_p.v", "Potential at the pin [V]", \
"drive.simpleMotor_EMF.p.v", 1, 5, 28, 4)
DeclareAlias2("drive.averaged.coreElement.pin_p.i", "Current flowing into the pin [A]",\
 "drive.averaged.coreElement.idealBuckConverter.i2", 1, 5, 70, 132)
DeclareVariable("drive.averaged.coreElement.pin_n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.coreElement.pin_n.i", "Current flowing into the pin [A]",\
 "drive.simpleMotor_EMF.inductor.i", 1, 1, 0, 132)
DeclareAlias2("drive.averaged.coreElement.rotateCW", "[:#(type=Boolean)]", \
"DymolaConvertInputToREAL0", 1, 5, 114, 65)
DeclareVariable("drive.averaged.coreElement.signChanger.y", "Value of Real output",\
 0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("drive.averaged.coreElement.product.u1", "Connector of Real input signal 1",\
 "drive.averaged.coreElement.uniOrBidirectional.y", 1, 5, 52, 0)
DeclareAlias2("drive.averaged.coreElement.product.u2", "Connector of Real input signal 2",\
 "drive.averaged.coreElement.signChanger.y", 1, 5, 79, 0)
DeclareAlias2("drive.averaged.coreElement.product.y", "Connector of Real output signal [1]",\
 "drive.averaged.coreElement.idealBuckConverter.dutyCycle", 1, 5, 75, 0)
DeclareAlias2("drive.averaged.rotateCW", "[:#(type=Boolean)]", "DymolaConvertInputToREAL0", 1,\
 5, 114, 65)
DeclareVariable("drive.averaged.ground.p.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.averaged.ground.p.i", "Current flowing into the pin [A]",\
 0.0, 0.0,0.0,0.0,0,776)
DeclareVariable("drive.averaged.currentSensorDC.p.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.currentSensorDC.p.i", "Current flowing into the pin [A]",\
 "drive.averaged.pin_p.i", 1, 5, 46, 132)
DeclareVariable("drive.averaged.currentSensorDC.n.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.currentSensorDC.n.i", "Current flowing into the pin [A]",\
 "drive.averaged.coreElement.idealBuckConverter.n1.i", 1, 5, 73, 132)
DeclareAlias2("drive.averaged.currentSensorDC.i", "Current in the branch from p to n as output signal [A]",\
 "drive.averaged.pin_p.i", 1, 5, 46, 0)
DeclareAlias2("drive.averaged.currentDC.u", "DC current of the inverter [A]", \
"drive.averaged.pin_p.i", 1, 5, 46, 0)
DeclareAlias2("drive.averaged.currentSensorAC.p.v", "Potential at the pin [V]", \
"drive.simpleMotor_EMF.p.v", 1, 5, 28, 4)
DeclareAlias2("drive.averaged.currentSensorAC.p.i", "Current flowing into the pin [A]",\
 "drive.simpleMotor_EMF.inductor.i", 1, 1, 0, 132)
DeclareAlias2("drive.averaged.currentSensorAC.n.v", "Potential at the pin [V]", \
"drive.simpleMotor_EMF.p.v", 1, 5, 28, 4)
DeclareAlias2("drive.averaged.currentSensorAC.n.i", "Current flowing into the pin [A]",\
 "drive.averaged.coreElement.idealBuckConverter.i2", 1, 5, 70, 132)
DeclareAlias2("drive.averaged.currentSensorAC.i", "Current in the branch from p to n as output signal [A]",\
 "drive.simpleMotor_EMF.inductor.i", 1, 1, 0, 0)
DeclareVariable("drive.averaged.currentAC_Averaged.u", "DC current of the inverter [A]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareVariable("drive.averaged.voltageChanger.y", "Value of Real output [1]", \
0.0, 0.0,0.0,0.0,0,640)
DeclareAlias2("drive.averaged.product.u1", "Connector of Real input signal 1 [A]",\
 "drive.simpleMotor_EMF.inductor.i", 1, 1, 0, 0)
DeclareAlias2("drive.averaged.product.u2", "Connector of Real input signal 2 [1]",\
 "drive.averaged.voltageChanger.y", 1, 5, 85, 0)
DeclareAlias2("drive.averaged.product.y", "Connector of Real output signal [A]",\
 "drive.averaged.currentAC_Averaged.u", 1, 5, 84, 0)
DeclareVariable("drive.averaged.voltageSensorDC.p.v", "Potential at the pin [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.averaged.voltageSensorDC.p.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.averaged.voltageSensorDC.n.v", "Potential at the pin [V]",\
 0.0, 0.0,0.0,0.0,0,521)
DeclareVariable("drive.averaged.voltageSensorDC.n.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.averaged.voltageSensorDC.v", "Voltage between pin p and n (= p.v - n.v) as output signal [V]",\
 60.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.averaged.voltageDC.u", "DC current of the inverter [V]", \
60.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.dutyCycleIn1", "Ratio of on-time to period duration [1]", \
"omega", 1, 2, 1, 0)
DeclareAlias2("drive.rotateCW1", "[:#(type=Boolean)]", "DymolaConvertInputToREAL0", 1,\
 5, 114, 65)
DeclareVariable("drive.ground2.p.v", "Potential at the pin [V]", 0.0, 0.0,0.0,\
0.0,0,521)
DeclareVariable("drive.ground2.p.i", "Current flowing into the pin [A]", 0.0, \
0.0,0.0,0.0,0,777)
DeclareAlias2("drive.inertia.flange_a.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.inertia.phi", 1, 1, 1, 4)
DeclareVariable("drive.inertia.flange_a.tau", "Cut torque in the flange [N.m]", \
0.0, 0.0,0.0,0.0,0,776)
DeclareAlias2("drive.inertia.flange_b.phi", "Absolute rotation angle of flange [rad|deg]",\
 "drive.inertia.phi", 1, 1, 1, 4)
DeclareAlias2("drive.inertia.flange_b.tau", "Cut torque in the flange [N.m]", \
"tau", 1, 2, 2, 132)
DeclareVariable("drive.inertia.J", "Moment of inertia [kg.m2]", 0.0629, 0.0,\
1E+100,0.0,0,513)
DeclareVariable("drive.inertia.stateSelect", "Priority to use phi and w as states [:#(type=StateSelect)]",\
 3, 1.0,5.0,0.0,0,1541)
DeclareState("drive.inertia.phi", "Absolute rotation angle of component [rad|deg]",\
 1, 0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.inertia.der(phi)", "der(Absolute rotation angle of component) [rad/s]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareState("drive.inertia.w", "Absolute angular velocity of component (= der(phi)) [rad/s]",\
 2, 0.0, 0.0,0.0,0.0,0,560)
DeclareDerivative("drive.inertia.der(w)", "der(Absolute angular velocity of component (= der(phi))) [rad/s2]",\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.inertia.a", "Absolute angular acceleration of component (= der(w)) [rad/s2]",\
 "drive.inertia.der(w)", 1, 6, 2, 0)
DeclareVariable("drive.potentialSensor.p.v", "Potential at the pin [V]", 60.0, \
0.0,0.0,0.0,0,521)
DeclareVariable("drive.potentialSensor.p.i", "Current flowing into the pin [A]",\
 0, 0.0,0.0,0.0,0,777)
DeclareVariable("drive.potentialSensor.phi", "Absolute voltage potential as output signal [V]",\
 60.0, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.phi1", "Absolute voltage potential as output signal [V]",\
 60.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("drive.i1", "Current in the branch from p to n as output signal [A]",\
 "i1", 1, 3, 3, 0)
DeclareVariable("drive.batteryPack.V", "Value of constant voltage [V]", 60, \
0.0,0.0,0.0,0,513)
DeclareVariable("drive.batteryPack.v", "Voltage drop of the two pins (= p.v - n.v) [V]",\
 60, 0.0,0.0,0.0,0,513)
DeclareVariable("drive.batteryPack.p.v", "Potential at the pin [V]", 60.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("drive.batteryPack.p.i", "Current flowing into the pin [A]", \
"drive.averaged.coreElement.idealBuckConverter.n1.i", 1, 5, 73, 132)
DeclareVariable("drive.batteryPack.n.v", "Potential at the pin [V]", 0.0, \
0.0,0.0,0.0,0,521)
DeclareAlias2("drive.batteryPack.n.i", "Current flowing into the pin [A]", \
"drive.averaged.pin_p.i", 1, 5, 46, 132)
DeclareAlias2("drive.batteryPack.i", "Current flowing from pin p to pin n [A]", \
"drive.averaged.coreElement.idealBuckConverter.n1.i", 1, 5, 73, 0)
DeclareInput("rotationCW", "[:#(prefix=input):#(type=Boolean)]", 0, false, \
0.0,0.0,0.0,0,642)
DeclareInput("omega", "[1:#(prefix=input)]", 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareInput("tau", "Accelerating torque acting at flange (= -flange.tau) [N.m:#(prefix=input)]",\
 2, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("tau_out", "Torque in flange flange_a and flange_b (tau = flange_a.tau = -flange_b.tau) as output signal",\
 0, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("omega_out", "Absolute angular velocity of flange_a as output signal",\
 1, 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("realExtend.u", "[N.m]", "drive.inertia.flange_a.tau", 1, 5, 94, 0)
DeclareVariable("realExtend.y[1]", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("realExtend.y[2]", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("realExtend.y[3]", "", "tau_out", 1, 3, 0, 0)
DeclareAlias2("realExtend1.u", "[rad/s]", "drive.multiSensorLoad.flange_a.der(phi)", 1,\
 5, 42, 0)
DeclareVariable("realExtend1.y[1]", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareVariable("realExtend1.y[2]", "", 0.0, 0.0,0.0,0.0,0,513)
DeclareAlias2("realExtend1.y[3]", "", "omega_out", 1, 3, 1, 0)
DeclareOutput("phi1", "Absolute voltage potential as output signal [V]", 2, 60.0,\
 0.0,0.0,0.0,0,513)
DeclareOutput("i1", "Current in the branch from p to n as output signal [A]", 3,\
 0.0, 0.0,0.0,0.0,0,512)
DeclareAlias2("drive.averaged.currentDC.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.averaged.pin_p.i", 1, 5, 46, 4)
DeclareAlias2("drive.averaged.currentAC_Averaged.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive.averaged.currentAC_Averaged.u", 1, 5, 84,\
 4)
DeclareVariable("drive.averaged.voltageDC.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.bldcBus.currentAC_Averaged", "DC current of the inverter [A]",\
 "drive.averaged.currentAC_Averaged.u", 1, 5, 84, 4)
DeclareAlias2("drive.averaged.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.averaged.pin_p.i", 1, 5, 46, 4)
DeclareVariable("drive.averaged.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.currentAC_Averaged.bldcBus.currentDC", \
"DC current of the inverter [A]", "drive.averaged.pin_p.i", 1, 5, 46, 4)
DeclareVariable("drive.averaged.currentAC_Averaged.bldcBus.voltageDC", \
"DC current of the inverter [V]", 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.currentDC.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive.averaged.currentAC_Averaged.u", 1, 5, 84,\
 4)
DeclareVariable("drive.averaged.currentDC.bldcBus.voltageDC", "DC current of the inverter [V]",\
 60.0, 0.0,0.0,0.0,0,521)
DeclareAlias2("drive.averaged.voltageDC.bldcBus.currentAC_Averaged", \
"DC current of the inverter [A]", "drive.averaged.currentAC_Averaged.u", 1, 5, 84,\
 4)
DeclareAlias2("drive.averaged.voltageDC.bldcBus.currentDC", "DC current of the inverter [A]",\
 "drive.averaged.pin_p.i", 1, 5, 46, 4)
DeclareVariable("DymolaConvertInputToReal0", "", 0.0, 0.0,0.0,0.0,0,1664)
DeclareVariable("DymolaConvertInputToREAL0", "[:#(type=Boolean)]", false, \
0.0,0.0,0.0,0,1666)
DeclareOutput("CPUtime", "[s]", 4, 0.0, 0.0,0.0,0.0,0,512)
DeclareOutput("EventCounter", "", 5, 0.0, 0.0,0.0,0.0,0,512)
EndNonAlias(0)

#define DymolaHaveUpdateInitVars 1
#include <dsblock5.c>

DYMOLA_STATIC void UpdateInitVars(double*time, double* X_, double* XD_, double* U_, double* DP_, int IP_[], Dymola_bool LP_[], double* F_, double* Y_, double* W_, double QZ_[], double duser_[], int iuser_[], void*cuser_[],struct DYNInstanceData*did_,int initialCall) {
}
StartDataBlock
EndDataBlock
